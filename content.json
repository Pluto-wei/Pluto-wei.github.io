{"meta":{"title":"Pluto-wei","subtitle":"Hello,nice to meet you!","description":"你好\\(@^0^@)/","author":"Pluto-wei","url":"http://Pluto-wei.github.io","root":"/blog/"},"pages":[],"posts":[{"title":"Crash Course Computer Science 笔记","slug":"Crash-Course-Computer-science-笔记","date":"2020-01-31T03:53:23.000Z","updated":"2020-02-02T04:26:45.923Z","comments":true,"path":"2020/01/31/Crash-Course-Computer-science-笔记/","link":"","permalink":"http://pluto-wei.github.io/2020/01/31/Crash-Course-Computer-science-%E7%AC%94%E8%AE%B0/","excerpt":"硬件Hardware 继电器，真空管，晶体管 二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门） 算术存储单元ALU（算术单元和逻辑单元） 集成电路（都是晶体管组成的）","text":"硬件Hardware 继电器，真空管，晶体管 二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门） 算术存储单元ALU（算术单元和逻辑单元） 集成电路（都是晶体管组成的） 锁存器 （存储一个位）0 1 寄存器 （一组锁存器） 8位寄存器 16 32 64 写入寄存器前要先启用里面所有的锁存器（允许写入线） 存大量寄存器：矩阵排列 例如16×16网格的锁存器 通过行列的某根线还可以确定到某个确定的锁存器来启动 emm.png 允许写入线，允许读取线，数据线 连接所有的锁存器 多路复用器.png again 把256位内存作为一个整体 （通过8位地址能储存256个数据？错，每一个位置上是一个0或者1，整体表示一个数据，有256个二进制数（也不是256种可能性，而是$2^{256}$）） 8位就是一个字节（这里都是单位，八位的字节包含8个二进制数） 一个字节有$2^{256}$种0和1的可能性 把8个256位内存排一排 存储8个数，给他们相同的地址 于是一个8位的地址可以存取一个8位数， （这里好奇怪 无法理解：） 又把这个256位内存叫一位（可能是一位数字的意思？），把8个这样的内存排一排叫1字节？ 为了存储这样的一个8位数，我们同时给8个256位内存一样的地址（如图） 嗷，懂了，这样就能存储一个8位数了！地址是8位 Think about it :一位数相当于有256种可能性，$2^{256^8}=2^{2^{64}} $ 整体的可寻址内存 RAM–随机存取存储器 8位的地址 256个地址 每个地址可以读或写一个8位值（8 bits=$2^8$种） RAM.png 前四位是操作码（OPCODE：LOAD ADD） 后四位是内存地址（if is LOAD） CPU–中央处理器（指令和程序） 中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元 组成 ALU 控制单元 RAM 时钟 CPU.png 取址–&gt;解码–&gt;执行 可操作的指令有 LOAD ADD SUB JUMP HALT 英特尔集成4004，第一个集成CPU 有46条指令 现代CPU有上千个指令和指令变种，有各种巧妙复杂的电路 一秒十亿条指令 高级CPU设计 缓存 在RAM中取一整块存在CPU内部，方便数据的存取。 CPU与RAM中间只有一根数据线，效率较低 当数据有改变时，通过检测脏位，将数据同步给RAM 提高效率 并行处理，同时用上CPU中的取址，解码，执行 高端处理器 会猜测JUMP的下一步，进行推测执行 超标量处理器 一个时间周期完成多条指令 优化**一个指令流**的吞吐量 一个CPU中有多个ALU CPU2.png 多核处理器 同时运行多个指令流 一个CPU芯片中，有多个独立处理单元 CPU3 2个/4个CPU 多核不够时可以用多个CPU 超级计算机 神威太湖之光有40960个CPU，每个CPU有256个核心，每个核心的频率是1.56GHz，每秒钟可以进行9.3亿亿次浮点运算 集成电路 锗-&gt;硅 早期 IC 几个晶体管：把简单电路（逻辑门）封装成单独组件 印刷电路板PCB：通过蚀刻金属线把零件连接在一起 光刻：用光把复杂图案印在材料上，如半导体 用晶圆做基础，把复杂的金属电路放在上面集成所有东西–氧化层–光 刻胶–光掩膜，金属化 光刻还可以制作电阻 电容 一片晶圆可以做很多 IC，整块做完后切割包进微型芯片 芯片的核心是 IC 摩尔定律：每两年左右，材料和制造技术的发展，同样的空间大小，能塞进两倍数量的晶体管 超大规模集成 VLSI 软件：用来自动生成芯片设计 软件Software 早期编程方式 程序怎么进入内存？？ 一.纸卡 最早的编程雅卡尔织布机 早期汇总机–不算计算机，只汇总数据（穿孔纸卡），不能编程 二.插线板 Control panel 控制面板–插线板–&gt;可拔插 有很多小插孔，可以插电线，让机器的不同部分可以相互传数据和信号 世界上第一台通用电子计算机ENIAC–用插线板编程 存取程序计算机 程序和数据都存在–冯诺伊曼结构 一个处理器（有算术逻辑单元），数据寄存器，指令寄存器，指令，内存（负责存数据和指令） 三.面板编程 大量使用开关 编程语言(Software) 二进制是处理器的母语（机器语言，机器码） 对程序的高层次描述–伪代码 汇编器 读取汇编语言的写的程序。然后转成机器码 自己搞定跳转地址（插入可跳转标签） 一般一条机器指令对应一条机器指令 编译器 专门把高级语言转成低级语言(汇编或机器码) 一行高级编程语言，可能转成几十条二进制指令 程序员只需要创建变量–代表内存地址的抽象 解释器 运行时进行转换，而编译器是运行前转换 编程基础（语句和函数） 语法–规定句子结构的一系列规则 赋值语句，if语句，循环语句，把代码打包成函数（子程序） 算法–解决问题的具体步骤 排序：选择排序$n^2$，归并排序$nlogn$ 图搜索（找最佳路线）：Dijkstra算法 算法的复杂度–算法的输入大小和运行步骤 数据结构 数组（列表，也叫向量） 字符串（数组的亲戚）：字母 数字 标点符号 矩阵（二维数组，数组的数组） 结构体（多个变量打包，多个不同类型数据放在一起） 链表（一个灵活的数据结构，能存很多个节点）：容易重新排序，插入，两端缩减，倒序 很多复杂的数据结构也用链表：队列和栈 队列：先进先出 栈：后进先出 树（把一个节点的指针变成多个指针）：根节点，子节点，母/父节点（直属上层节点），叶节点（树结束的地方） 二叉树：节点最多只有两个子节点 甚至节点可以用链表来存储你所有的子节点 树的特点：根到叶是单向的 图：数据随意连接，包括循环。用有多个节点的指针表示，可随意指向 红黑树和堆？ 计算机科学之父–图灵 图灵机：规则，状态和纸带 停机问题 无法解决 提出智能，图灵测试（验证码） 软件工程 把函数打包成层级，把相关代码都放在一起，打包成对象 对象.png 对象可以包含其他对象，函数 和变量 对象2.png 把函数打包成对象的思想叫面向对象编程 Object Oriented Programming 文档 （帮助理解代码都做了什么）以及定义好的程序编程接口API API 控制哪些函数和数据让外部访问，哪些仅供内部 面向对象的编程语言可以指定函数是private/public，隐藏复杂度，选择性的公布 集成开发环境 IDE debug 调试 写文档 README 源代码管理（版本控制） 把代码放在一个中心服务器上，叫做代码仓库 Code repository check out，commit（提交） master（代码的总版本） 质量保证测试 QA β版本软件（快完成时向公众发布）免费的QA团队 alpha版本（只在公司内部测试） 操作系统OS 操作硬件的特殊权限，可以运行和管理其他程序 （1950年代） 操作系统充当硬件和软件之间的媒介 操作系统提供API来抽象硬件，叫设备驱动程序 批处理（连续进行多个程序，自动加载程序）–&gt;在单个CPU上同时运行几个程序–&gt;多任务处理（给每个程序分配专属内存块，内存地址的虚拟化，内存保护）–&gt;分时操作系统（处理多个用户） Multics（功能太多）–&gt;Unix（把操作系统分为两个部分：内核（内存管理，多任务输入输出处理）和一堆有用的工具（例如程序和运行库），功能并不是很全面，内存崩溃时“恐慌”）–&gt;Windows（早期经常蓝屏）–&gt;Mac OS X,Linux,iOS,Android 多任务，虚拟内存，内存保护 内存&amp;储存介质 存储介质 打孔纸卡，打孔纸带–&gt;延迟线存储器（扬声器压力波/金属线的震动，顺序存储器/循环存储器）–&gt;磁芯存储器（可访问某一特定位置）–&gt;磁带–&gt;磁鼓储存器–&gt;硬盘（机械硬盘，固态硬盘SSD）–&gt;软盘–&gt;密度更高的软盘（Zip Disks）–&gt;光学存储器（光盘CD，DVD）光盘表面有很多小坑，造成光的不同反射，光学传感器捕获并解码为1和0 文件与文件系统 文件格式： TXT（文本）WAVE（音频，振幅） Bitmap.bmp（图片，像素块：红绿蓝） 元数据（类型，图片宽度，图片高度，深度）+Date 怎么储存文件 为了存多个文件，需要一个特殊文件记录文件的位置（文件目录，通常在最开头） 文件目录.png 文件系统专门负责管理文件 平面文件系统： （文件都在同一个目录里） 分配块–增大或减小 碎片处理–把数据来回移动，排列成正确的数据 分层文件系统 目录文件不仅要指向文件，还要指向目录 根目录.png 压缩 Compression 把数据占用的空间压到更小 作用：高效储存图片，音乐，视频 无损压缩 消除冗余 游程编码适合经常出现相同值的文件 用更紧凑的表示方法 字典编码 GIF,PNG,PDF,ZIP 有损压缩 感知编码 用不同的精度编码不同的频段 例如声音，超声波/低音 FLAC / WAV --&gt; MP3 有损压缩文件格式 JPEG 视频，每一帧，时间冗余，只存变化的部分，补丁的移动和转换 MPEG-4 人机交互 命令行 历史 机械输入，齿轮 旋钮 开关 等机械结构 ，一大堆机械面板和线， –&gt;打孔纸卡和磁带，输入依然是打印纸ang实时指示灯 –&gt;键盘 打字机 –&gt;电传打字机：可用电话线发送和接收文本（蒸汽朋克版聊天室） –&gt;电传交互（来回对话）–命令行界面 cmd –&gt;屏幕代替电传打字机：虚拟电传打印机/玻璃电传打印机 --叫做终端 terminal –&gt; 文字游戏，互动式小说–&gt; MUD 多人地牢游戏（MMORPG的前辈–大型多人在线角色扮演） 命令行指令 ls (list) 列出当前目录里的所有文件 cat (concatenate 连接)（unix）显示文件内容 finger 找朋友 屏幕 and 2D图形显示 早期屏幕的用途：跟踪程序的运行情况，结果打印在纸上，或是保存更永久的地方 （屏幕更新快，对临时值简直完美） 阴极射线管CRT：把电子发射到有磷光体图层的屏幕上，路径由磁场控制 1.矢量扫描，用电子束描述出形状 2.光栅扫描，一行行，从上自下，从左往右，只在特定地方打开电子束 早期不存像素（占用内存过多），存符号 字符生成器–第一代显卡 只读存储器 ROM，存每个字符的图形（点阵图案） 访问内存中的屏幕缓冲区（专为图形保留） 用字符模仿图形界面：_ + 画盒子和线 字符集： 用额外的bit定义字体颜色和背景颜色 用CRT上的矢量模式，所有的东西都用线组成 （海龟作图）–&gt;动画 位图显示–内存中的位对应屏幕上的像素 Sketchpad （几何画板）一个交互式图形界面–计算机辅助设计 CAD 输入设备–光笔 图形界面 直接显示了你可以做什么，直接在屏幕上找选项即可，\"选择并点击界面” 图形用户界面–GUI 鼠标–用户和屏幕上的信息互动（光标） 桌面–模拟实际桌面，有窗口，时钟等小组件 用户触发事件–如点击按钮，选一个菜单项，滚动窗口–有对应的执行函数 3D图形 有图型算法负责把3D坐标拍平显示到2D屏幕上–3D投影 线框渲染：正交投影，透视投影 扫描线渲染（填充图形）：抗锯齿 抗锯齿.png 遮挡：排序算法，画家算法–由远到近 深度缓冲 明暗处理：平面着色–最基本的照明算法，高洛德着色，冯氏着色 明暗处理.png 纹理：纹理映射 加速渲染： 并行渲染 GPU–图形处理单元（在显卡上，周围有专用的RAM） 计算机网络 👉开放式系统互联通信参考模型 OSI 物理层：线路里的电信号，无线网络里的无线信号 数据链路层：负责管理物理层 有媒体访问控制地址MAC，冲突检测，指数退避和其他的一些底层协议 网络层：负责各种报文交换和路由 IP 传输层：UDP TCP这些协议，负责在计算机之间进行点到点的传输，检修和修复错误 会话层：使用UDO TCP创建连接，传递信息，然后关掉连接 表示层和应用程序层：浏览器，HTML解码，在线看电影 详情：&lt;https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B&gt; OSI.png 互联网 早期 需要分享数据和资源–&gt;公司或研究室内部使用 球鞋网络，共享物理资源–大家共享一台联网的打印机 早期网络也共享存储空间，不是每台电脑都有存储器 局域网 计算机近距离构成的小型网络LAN 最著名最成功的：以太网 载波侦听多路访问 CSMA（属于链路层②） CSMA.png 使用共享载体 以一台以太电线连接所有计算机，以电信号的形式将数据传入电缆 每台机器需要有唯一的媒体访问控制地址（MAC地址） 数据的接受方的地址放在数据的头部，作为数据的前缀发送到网络中 计算机看到自己的MAC才处理数据 这种 多台电脑共享一个传输媒介 的方法 叫–CSMA 载波侦听多路访问 含义：载体，运输数据的共享媒体，以太网的载体是铜线，wifi的载体是传播无线电波的空气。很多计算机同时侦听载体，侦听，多路。 带宽：载体传播数据的速度 冲突（属于链路层②） 多个计算机想同时传入数据时就会冲突。 如果冲突，会等一小段随机时间，指数退避–指数级增长等待时间（以太网） 载体和其中的设备–冲突域 可以用交换机把其分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络间传数据（属于链路层） 大的计算机网络也是如此，包括最大的网络–互联网，也是多个连在一起的小一点的网络，是不同网络之间可以传递信息 路由（属于网络层③） 路由—通过互联的网络把信息从源地址传输到目的地址的活动 专用的通信线路（电路交换，电话占线）—&gt;报文交换（如同邮件系统，有几个站点）（分布式网络） 报文交换的好处：可以用不同路由使通信更可靠更能容错 消息沿路由跳转的次数，跳数限制–解决路由问题 协议（属于传输层④） 报文交换的缺点是某个文件太大堵塞网络 解决方法：把大报文分成很多小块–数据包–分组交换 报文具体格式由互联网协议定义–IP（网络层？） **IP是一个非常底层的协议 Internet Protocol** IP之上还有其他协议：用户数据报协议 UDP IP负责把数据包送到正确的电脑IP header **UDP负责把数据包送到正确的程序 （UDP中的端口port）** UDP头部还有校验和–checksum，但不提供数据修复和数据重发，并无法得知数据包是否到达（应用于直播，视频通话，对时间要求很高：射击游戏，“丢包”） UDP.png **传输控制协议 TCP（所有数据必须到达）：** TCP头部也有端口号和校验和 TCP IP.png 👇 这个组合被称为TCP/IP TCP数据包有序号，使得接收方可以把数据包正确排序 接收方校验无误后会给发送方发送一个确认码ACK 能删掉重复数据包 可以同时发多个数据包，接收多个确认码 可以调整同时发包数量，解决拥堵问题（确认码的成功率和来回时间可以推断网络的拥堵程度） 缺点：确认码数据包把数量翻了一倍但并没有传播更多的信息 TCP.png 每台联网的计算机都需要一个IP地址，以点分隔的四组数据172.217.7.238 阻塞控制–路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠 当计算机访问一个网站时，需要两个东西：IP地址，端口号 互联网负责把域名和IP地址一一对应，就像电话簿–域名系统 DNS DNS服务器由互联网供应商ISP提供 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求**（会话层④）** 为了更好的管理上亿个域名，DNS存成树状结构（有3千万个二级域名） 顶级域名，二级域名，子域名 DNS.png 这些数据散布在很多DNS服务器上 WIFI 路由器连接的所有设备组成了局域网LAN，局域网再连接到广域网WAN，广域网的路由器属于你的互联网提供商ISP 广域网先连接到一个区域性路由器（覆盖一个街区），然后连接到一个更大的WAN（覆盖整个城市），最终到达互联网主干（由一群超大型，带宽超高路由器组成） 网.jpg 万维网 world wide web 互联网是传递数据的管道，传播最多数据的程序是万维网 万维网的基本单位是页面 页面有内容，有去往其他页面的链接–超链接，这些超链接形成巨大的互联网络 文字超链接–超文本（关联式索引） 为了使网页相互连接，每个网页需要一个唯一的地址–统一资源定位器 URL 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求，连接到这个IP，这个地址运行着“网络服务器”，网络服务器的标准端口是80端口，下一步是向服务器请求更进一步的页面（这里会用超文本传输协议HTTP：例如GET，还有状态码），例如向服务器发送指令“GET/courses”，服务器收到后会返回该地址对应的网页，然后浏览器会渲染到屏幕上。 👇超文本标记语言 HTML HTML.png 网页浏览器可以和网页服务器沟通 浏览器获取网页和媒体，并负责显示 人工编辑目录–&gt;搜索引擎–&gt;搜索算法 网络中立性：所有的数据包平等，优先级相同 计算机安全 Secrety,Integrity,Availability 保密性，完整性，可用性 威胁模型分析：以能力水平区分 💡身份认证： 你知道什么：用户名/密码–复杂组合（暴力攻击） 你有什么：用户有特定物品，如钥匙🔑和锁🔒 你是谁：生物识别–但有概率性，不能重设 建议“双因素”，“多因素”认证 💡访问控制：通过权限或访问控制列表ACL来实现 权限有：Read，Write，Execute 有很多种访问控制模型，例如：Chinese wall model，Biba model 例如美国的模型： 不能“读上”，读更高等级的内容 不能“写下”，改更低等级的文件（确保顶级机密不外泄） 其他措施：安全大会，安全行业的来审计代码,安全型代码一般开源 黑客与攻击 社会工程学：欺骗别人让别人泄露信息 配置别人的系统 网络钓鱼：邮件发送连接 假托：（电信诈骗） 邮件里带木马：恶意软件伪装成照片等 NAND镜像：暴力攻击被罚时时，增加几根线复制内存，罚时时覆盖内存继续尝试 漏洞利用：远程攻击需要攻击者利用系统漏洞来获得某些能力或访问权限 例如：缓冲区溢出：溢出部分改掉重要值，例如修改权限admin（应对方法：边界检查，随机存放变量在内存中的位置，金丝雀：缓冲区后面跟踪变化） 代码注入：攻击用数据库的网站 结构化查询语言SQL，一种流行的数据库API SQL.png DROP TABLE users，删掉用户这张表。凉凉 应对：检测特殊字符… 蠕虫：恶意程序在电脑间互相传播，这些电脑组成僵尸网络 DDoS：僵尸网络里的所有电脑发一大堆垃圾信息，堵塞网络 加密 计算机的现状和未来 机器学习＆人工智能 计算机视觉 自然语言处理 机器人 计算机心理学 教育科技 奇点，天网，未来 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-17T16:28:39.391Z","updated":"2020-02-01T17:00:58.231Z","comments":true,"path":"2019/11/18/hello-world/","link":"","permalink":"http://pluto-wei.github.io/2019/11/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}