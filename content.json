{"meta":{"title":"Pluto-wei","subtitle":"Hello,nice to meet you!","description":"你好\\(@^0^@)/","author":"Pluto-wei","url":"http://Pluto-wei.github.io","root":"/blog/"},"pages":[{"title":"关于","date":"2020-02-12T05:51:17.000Z","updated":"2020-02-12T07:05:44.954Z","comments":true,"path":"about/index.html","permalink":"http://pluto-wei.github.io/about/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"标签","date":"2020-02-12T05:36:35.000Z","updated":"2020-02-12T07:02:43.518Z","comments":true,"path":"tags/index.html","permalink":"http://pluto-wei.github.io/tags/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"},{"title":"文章分类","date":"2020-02-12T05:33:09.000Z","updated":"2020-02-12T07:03:19.457Z","comments":true,"path":"categories/index.html","permalink":"http://pluto-wei.github.io/categories/index.html","excerpt":"","text":"document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });"}],"posts":[{"title":"记第一次面试经历","slug":"记第一次正规面试经历","date":"2020-05-02T13:51:01.000Z","updated":"2020-05-03T01:35:31.382Z","comments":true,"path":"2020/05/02/记第一次正规面试经历/","link":"","permalink":"http://pluto-wei.github.io/2020/05/02/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%AD%A3%E8%A7%84%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/","excerpt":"🎉🎉🎉 人生之大喜大悲 得之我幸，失之我命","text":"🎉🎉🎉 人生之大喜大悲 得之我幸，失之我命 序 🎊—迟到了一周的记事 👉还是想记一下 要说也不是第一次面试了，上大学之前似乎没有面试过，当时考外校好像是交了材料以后就没后文了，那些材料也都是我爸帮我准备的，我也不知道有些啥东西。上了大学之后呢，刚开学还是经历了好多，有技术中心部门面试，俱乐部面试，创新创业中心面试，这都是过了的，还有没过的，影像工作室，辩论队。。哎呀这一数还挺多的 除了某部门面试超划水以外，其他的面试感觉还是挺正规的。形式呢有自我介绍+提问，无领导小组讨论（二面）。每一次都会提前准备，都会紧张。面试前真的都特别特别紧张（跟跑800米之前一样的感觉，即使结果再不重要，我真的没见过跑800米之前比我更紧张的了，从初中高中到大学的所有运动会+测试，即使可以到前3） 然后呢，这个是第一次线上面试，最大场面，也是最。。大喜大悲吧 面试前 一直在逃避 从公布面试时间到面试有7天左右的时间吧，就一直不愿意想这件事，不想准备，甚至不想参加不想去了。 当时找英才dg问了一些课程设置，然后也是有一点劝退吧，基本上已经是决定放弃了。。因为要补很多课啊🍐会很大，而且这个疫情这个情况。。就很纠结 小朋友真的是劝了我好久，让我再认真想想 然后dl建议我去某乎或者清水河畔了解一下， &amp;&amp;两个小姐妹：冲就完事了 然后我就真香了。。。 既然准备参加了就好好准备吧，毕竟一向认为做一件事又不认真做那还不如不做 准备了简历+发言稿，在超级简历里找的一个研究生复试模板 $Attention$：一定要自信，说自己擅长的地方，这不是你需要谦虚的时候，你自己都不相信自己可以，那别人凭什么要你？你自己不把闪光点说出来，那别人怎么知道？ –：你说的都是你的优点，那你觉得你有什么缺点呢 xpy: 经验还不足，阅历不够（年纪小） 具体的我就不说了，还是感谢这学期学的某几个课程做的项目，让我有那么一点点可以说的。当时自认为简历写的好好啊😂😂结果后来被告知不被参考？？那至少也说明了我的态度吧哈哈（除非他们根本就不打开看），整理了简历之后在写自我介绍也顺手多了 大插曲 由于五一假期调休，本来的两天面试调到一天，第二天调成第一天，说好头一天晚上发面试时间的，结果等到12点都没等到，也没人说发还是不发了 第二天10点醒的，当时还没练过怎么自我介绍，收到了消息说下午2：10面试，说的这么具体以为是具体的时间，从11点多种开始就一直进入面试的网站，说我前面还有18个人，一个人10分钟，算起来刚刚好的样子。 然后就一直等，等到4个人的时候好像人数就不减少了，2个小时过去了，同学说前面一直有一个人几个小时过了人数都不变？？？ 结果才知道这前面的人数跟时间都是虚拟时间？？？心态崩了。从12点的超级紧张，到2点钟的不想等了，到3点钟的气愤，4点钟等来了短信，结果硬是等到了5点半才开始？？？ 真的搞人心态啊？安排一个次序，计算一个面试时间，哪怕是前后1个小时的误差，有那么难吗？？？ 极不顺利的面试 接下来就到了大悲环节 简直就是极不顺利 👎自我介绍在一下午的等待时间中试过几次，倒是没什么大差错，感觉海星 但是面试官的问题。。为什么就一个都答不上来呢👇 （面试官当时是为了一张大桌子，会议室那种，对着你一个摄像头，但是在我的瞩目里面只有一个小屏，我没有放大，没看清他们具体的样子） Q：你觉得在科研室做科研和在高校做科研有什么不同之处？ A：blablabla Q：我问的是区别，有什么不同的地方？ Q：我问的是区别！你说的是科研室还是大学？ Q：你觉得科研室要好？那你说的这些大学都不具备吗？ A：… Q：你在做五子棋的时候用到了那些具体的算法知识？ A：极大值极小值搜素… Q：极大值极小值在数学上是怎么定义的？ Q：不我要你说的具体的数学式子 Q：极大极小思想在物理方面有什么应用？ A：… Q：你觉得你写一些博客对以后的科研有什么帮助？ Q：你觉得线性代数中贯穿始终的是什么思想？ Q：（打断）用一个词来表示 Q：是空间，。。线性代数里面根本就没有你说的 xx 词 A：… Q：好了今天的面试就到这里了，右下角可以退出了。。 就这？就这？就这？？？我还啥都没说出来呢？？？？ 我凉了 我没了 /微笑/微笑 然后大哭了一场。 为什么哭？因为白白浪费了一整天的时间，第二天又要上课，唯一的一天休息时间？？就这就这就这？？？还有acm3个小时的讲座没有听，还有别的几门课真的。。掉了好多好多课！！orz！简直气死了，完全已经觉得，这面试官完全没眼光啊！！！不管宁是不是在刁难我，毕竟没答上宁的问题，但是我就是好生气！！！！！！气死了气死了气死了！！！ 面试官就是没有眼光，lj学院有什么了不起，时间管理都没学会，浪费爷一下午，计院他不香吗？？（就当我是吃不到葡萄说葡萄酸，罢了罢了） 然后这一天就成为了我，继除夕回家以来，第一次出门！！！-----下楼去打了个pingpong球 — 其实小区里早就有小朋友在下面玩了，其实武汉已经解封大半个月了 — 但是我就是一直没出门 好了，那一切就该放下了。就当是一场梦，醒来很久还是很感动 这也能反转？？ 第二天，结果出来了，同学先发来的消息，说我过了，我？？？？？？ 小问号你是否有很多朋友？？？？？ 我人傻了 迷惑我八百年。。。就这？？？？有内鬼停止交易？？ 后续…等有时间再写吧，， 坚持固然重要，但选择比坚持更重要。 --杰尼龟 我本就是一个喜欢尝试的人，恨不得所有的东西都弄一下，可能也就是在试错成本最低的大一吧。但是你要知道这么多的尝试是为了选择做准备，人的精力是有限的，这从来都不是一句玩笑话。 有舍才有得，全都要只会一无所有 ps：有人说我的博客有点随意，我估摸着，我也不是个纯技术分享博主，这不是我开心就好🐎，而且估计也没人看到这哦哈哈哈，要是有的话，祝你看的开心，哈哈 ps：不要以为进了英才有什么了不起的，比你厉害的大有人在，计院前面几名真的，都超级强，超级厉害！！每个人都有自己擅长的方面！！不过是选择不同罢了。还是要给我好好学习！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"http://pluto-wei.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"记第一次面试经历","slug":"记第一次面试经历","date":"2020-05-02T13:51:01.000Z","updated":"2020-05-02T17:45:10.037Z","comments":true,"path":"2020/05/02/记第一次面试经历/","link":"","permalink":"http://pluto-wei.github.io/2020/05/02/%E8%AE%B0%E7%AC%AC%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/","excerpt":"🎉🎉🎉 人生之大喜大悲 得之我幸，失之我命","text":"🎉🎉🎉 人生之大喜大悲 得之我幸，失之我命 序 🎊—迟到了一周的记事 👉还是想记一下 要说也不是第一次面试了，上大学之前似乎没有面试过，当时考外校好像是交了材料以后就没后文了，那些材料也都是我爸帮我准备的，我也不知道有些啥东西。上了大学之后呢，刚开学还是经历了好多，有技术中心部门面试，俱乐部面试，创新创业中心面试，这都是过了的，还有没过的，影像工作室，辩论队。。哎呀这一数还挺多的 除了某部门面试超划水以外，其他的面试感觉还是挺正规的。形式呢有自我介绍+提问，无领导小组讨论（二面）。每一次都会提前准备，都会紧张。面试前真的都特别特别紧张（跟跑800米之前一样的感觉，即使结果再不重要，我真的没见过跑800米之前比我更紧张的了，从初中高中到大学的所有运动会+测试，即使可以到前3） 然后呢，这个是第一次线上面试，最大场面，也是最。。大喜大悲吧 面试前 一直在逃避 从公布面试时间到面试有7天左右的时间吧，就一直不愿意想这件事，不想准备，甚至不想参加不想去了。 当时找英才dg问了一些课程设置，然后也是有一点劝退吧，基本上已经是决定放弃了。。因为要补很多课啊🍐会很大，而且这个疫情这个情况。。就很纠结 小朋友真的是劝了我好久，让我再认真想想 然后dl建议我去某乎或者清水河畔了解一下， &amp;&amp;两个小姐妹：冲就完事了 然后我就真香了。。。 既然准备参加了就好好准备吧，毕竟一向认为做一件事又不认真做那还不如不做 准备了简历+发言稿，在超级简历里找的一个研究生复试模板 $Attention$：一定要自信，说自己擅长的地方，这不是你需要谦虚的时候，你自己都不相信自己可以，那别人凭什么要你？你自己不把闪光点说出来，那别人怎么知道？ –：你说的都是你的优点，那你觉得你有什么缺点呢 xpy: 经验还不足，阅历不够（年纪小） 具体的我就不说了，还是感谢这学期学的某几个课程做的项目，让我有那么一点点可以说的。当时自认为简历写的好好啊😂😂结果后来被告知不被参考？？那至少也说明了我的态度吧哈哈（除非他们根本就不打开看），整理了简历之后在写自我介绍也顺手多了 大插曲 由于五一假期调休，本来的两天面试调到一天，第二天调成第一天，说好头一天晚上发面试时间的，结果等到12点都没等到，也没人说发还是不发了 第二天10点醒的，当时还没练过怎么自我介绍，收到了消息说下午2：10面试，说的这么具体以为是具体的时间，从11点多种开始就一直进入面试的网站，说我前面还有18个人，一个人10分钟，算起来刚刚好的样子。 然后就一直等，等到4个人的时候好像人数就不减少了，2个小时过去了，同学说前面一直有一个人几个小时过了人数都不变？？？ 结果才知道这前面的人数跟时间都是虚拟时间？？？心态崩了。从12点的超级紧张，到2点钟的不想等了，到3点钟的气愤，4点钟等来了短信，结果硬是等到了5点半才开始？？？ 真的搞人心态啊？安排一个次序，计算一个面试时间，哪怕是前后1个小时的误差，有那么难吗？？？ 极不顺利的面试 接下来就到了大悲环节 简直就是极不顺利 👎自我介绍在一下午的等待时间中试过几次，倒是没什么大差错，感觉海星 但是面试官的问题。。为什么就一个都答不上来呢👇 （面试官当时是为了一张大桌子，会议室那种，对着你一个摄像头，但是在我的瞩目里面只有一个小屏，我没有放大，没看清他们具体的样子） Q：你觉得在科研室做科研和在高校做科研有什么不同之处？ A：blablabla Q：我问的是区别，有什么不同的地方？ Q：我问的是区别！你说的是科研室还是大学？ Q：你觉得科研室要好？那你说的这些大学都不具备吗？ A：… Q：你在做五子棋的时候用到了那些具体的算法知识？ A：极大值极小值搜素… Q：极大值极小值在数学上是怎么定义的？ Q：不我要你说的具体的数学式子 Q：极大极小思想在物理方面有什么应用？ A：… Q：你觉得你写一些博客对以后的科研有什么帮助？ Q：你觉得线性代数中贯穿始终的是什么思想？ Q：（打断）用一个词来表示 Q：是空间，。。线性代数里面根本就没有你说的 xx 词 A：… Q：好了今天的面试就到这里了，右下角可以退出了。。 就这？就这？就这？？？我还啥都没说出来呢？？？？ 我凉了 我没了 /微笑/微笑 然后大哭了一场。 为什么哭？因为白白浪费了一整天的时间，第二天又要上课，唯一的一天休息时间？？就这就这就这？？？还有acm3个小时的讲座没有听，还有别的几门课真的。。掉了好多好多课！！orz！简直气死了，完全已经觉得，这面试官完全没眼光啊！！！不管宁是不是在刁难我，毕竟没答上宁的问题，但是我就是好生气！！！！！！气死了气死了气死了！！！ 面试官就是没有眼光，lj学院有什么了不起，时间管理都没学会，浪费爷一下午，计院他不香吗？？（就当我是吃不到葡萄说葡萄酸，罢了罢了） 然后这一天就成为了我，继除夕回家以来，第一次出门！！！-----下楼去打了个pingpong球 — 其实小区里早就有小朋友在下面玩了，其实武汉已经解封大半个月了 — 但是我就是一直没出门 好了，那一切就该放下了。就当是一场梦，醒来很久还是很感动 这也能反转？？ 第二天，结果出来了，同学先发来的消息，说我过了，我？？？？？？ 小问号你是否有很多朋友？？？？？ 我人傻了 迷惑我八百年。。。就这？？？？有内鬼停止交易？？ 后续… ps：有人说我的博客有点随意，我估摸着，我也不是个纯技术分享博主，这不是我开心就好🐎，而且估计也没人看到这哦哈哈哈，要是有的话，祝你看的开心，哈哈 ps：不要以为进了英才有什么了不起的，比你厉害的大有人在，计院前面几名真的，都超级强，超级厉害！！每个人都有自己擅长的方面！！不过是选择不同罢了。还是要给我好好学习！！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"生活","slug":"生活","permalink":"http://pluto-wei.github.io/categories/%E7%94%9F%E6%B4%BB/"}],"tags":[]},{"title":"五子棋 AI","slug":"五子棋AI","date":"2020-04-19T15:29:19.000Z","updated":"2020-04-20T04:11:02.515Z","comments":true,"path":"2020/04/19/五子棋AI/","link":"","permalink":"http://pluto-wei.github.io/2020/04/19/%E4%BA%94%E5%AD%90%E6%A3%8BAI/","excerpt":"","text":"其实这也不是一篇写算法的文章 哈哈哈哈哈 c语言后期作业–五子棋AI–几周过后我终于开始了 肝了4天！！！！！！！！ 0基础学Qt（有一种顺便学了c++的感觉），图形界面从0开始，边在小破站学边画 画了2天实现交互（按键可以显示并储存）–实现人机一样一步机器随机下–五子棋ai！！ 从0开始的五子棋AI！！！（夸我！！） 太不容易了！！！！！！ 👉效果 先放两张效果图👇 UI界面得到了赞美（骄傲） 👉测试 我一开始瞎下，基本上1/5的胜率 orz 然后拿给群友测试了一下 获胜 获胜的小朋友还是挺多的 战败 当然也有输的呀（看来这AI 还是不错的😜） 还有怎么都下赢不了自闭的（x 还有坚持下了半个小时一定要赢AI 的安宝😂😂😂 👉改进 还有一些群友意见&amp;&amp;灵感😂😂😂 👉特别感谢😂 特别感谢提供棋子图片&amp;陪我解决打包.exe文件图片不显示问题&amp;啥问题都可以问的小朋友（竟然也一盘都没赢？？？太菜了吧😏😏👎） JQ1Yin.png 👉说明 其实这AI就只搜素了两层而且没用剪枝那些（用的时候bug了就删了），只是删去了那些周围都没有棋子的。还有好多高级的算法需要学习 顺便说一下层数的问题，首先思考层数必须是偶数。因为奇数节点是AI，偶数节点是玩家，如果AI下一个子不考虑玩家防守一下，那么这个估分明显是有问题的。 然后，至少需要进行4层思考，如果连4四层都考虑不到，那就是只看眼前利益，那么棋力会非常非常弱。 如果能进行6层思考基本可以达到对战普通玩家有较高胜率的水平了（普通玩家是指没有专门研究过五子棋的玩家，棋力大约是4层的水平），如果能达到8层或以上的搜索，对普通玩家就有碾压的优势，可以做到90%以上胜率。 两层搜素能达到这个效果我已经很开心了，本来是写了四层的但是bug了就删了，后来发现还不错就没有改了，毕竟对于普通玩家还是有一定的胜率的。之前跟这个教程做的AI下棋我是真的没赢过，太没有游戏体验了（👎） 五子棋AI教程 ＆ 这个教程做的 http://gobang.light7.cn/ 👉爪巴 好了把五子棋肝出来了，短期内也不想改了，这个星期的课都没怎么听，要补大物模电微积分离散了。晚上做了一个微积分的mooc错了一个气死了，算出来没答案（确信是题目错了x）模电跟离散好多节课都没听了orz 要准备英才面试了，纠结了好久…随缘吧，进不进都挺好的，既然参加面试就好好准备吧，尽力就🆗 哦对了还有acm，前几天参加了一个cf一个牛客，只能做几个水题，而且好慢还会罚时，后面的题会是会做但是贼慢，没时间呀… 还是因为对图树啥的存储和模型不是很熟，上次想把无权图转化成树（是树）想了好久没想出来，其实直接用有向图就可以呀，无向图-&gt;有向图其实就是在每一条边标出指向（起点）就可以了。有时间还要熟悉一下模型 还有入党积极分子的党课要上… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"Qaq","slug":"qaq","date":"2020-04-11T15:24:55.000Z","updated":"2020-04-20T06:43:30.870Z","comments":true,"path":"2020/04/11/qaq/","link":"","permalink":"http://pluto-wei.github.io/2020/04/11/qaq/","excerpt":"哎呀，都有1个多月没更新了，过的也太快（shui）了 今天的我👇","text":"哎呀，都有1个多月没更新了，过的也太快（shui）了 今天的我👇 太符合了 一杯茶一包烟一道oj题做一天💔 云返校（想看甜甜的爱情）： 最近真的太水了doge 离开学还得一个月吧，要好好学习了呜呜呜 上个月有几个算法发在csdn了，有时间搬运一下，顺便再整一下博客（比如设一下密码，访问人数，评论啥的） （还想一天学一个算法的，想peach，，） 先这样吧。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心情qaq","slug":"心情qaq","permalink":"http://pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"自闭日常","slug":"自闭日常","date":"2020-03-07T07:16:40.000Z","updated":"2020-04-11T15:31:23.242Z","comments":true,"path":"2020/03/07/自闭日常/","link":"","permalink":"http://pluto-wei.github.io/2020/03/07/%E8%87%AA%E9%97%AD%E6%97%A5%E5%B8%B8/","excerpt":"又是自闭的一天","text":"又是自闭的一天 git add之后忘记git commit直接push了，也不知道用了什么操作，本地代码就不见了，git log呀啥的都没显示，在网上一通乱找啥都没找到，好像也有这样的说恢复不了了。 vscode上面好像有local history，但是装了之后才开始记录，之前的还是没有了，于是就再写了一遍。。。哭了 然后，几个小时。。。 12git stash;git stash pop; 怎么就出来了？？~！！！ 白给orz document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]},{"title":"好气！","slug":"好气！","date":"2020-02-28T13:42:13.000Z","updated":"2020-04-20T01:53:02.291Z","comments":true,"path":"2020/02/28/好气！/","link":"","permalink":"http://pluto-wei.github.io/2020/02/28/%E5%A5%BD%E6%B0%94%EF%BC%81/","excerpt":"好气啊！前几篇博客的图片都显示不了了！！ 调了半天还是只有自己可以看见！删了算了哈哈哈","text":"好气啊！前几篇博客的图片都显示不了了！！ 调了半天还是只有自己可以看见！删了算了哈哈哈 沙雕博客被发现了！以后不发沙雕文了哈哈哈😜😜😬😬 开学了一个星期天天满课，(((φ(◎ロ◎;)φ))) 晕了 床上上课体验极差！每天被各种大佬虐😭😭😭 几门水课都要做ppt，吐了🤮！！ 武汉必定最后一批返校，估计得4月底咯，惨 这篇水文顺便看看图片还能不能显示👇 要是👆还是没有图… 我就哭了 2020/04/20 更新： github的图床又被墙了？？OMG https://imgchr.com/ 先测试一下新图床的图片大小区别 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心情qaq","slug":"心情qaq","permalink":"http://pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"C++标准模板库STL介绍","slug":"C++标准模板库STL介绍","date":"2020-02-16T15:58:50.000Z","updated":"2020-02-17T06:28:29.313Z","comments":true,"path":"2020/02/16/C++标准模板库STL介绍/","link":"","permalink":"http://pluto-wei.github.io/2020/02/16/C++%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93STL%E4%BB%8B%E7%BB%8D/","excerpt":"大概是两天看完的，这一部分主要还是以后需要查阅，只是知道了大概的用法吧。想学数据结构了，应该接下来就是了！淦！！","text":"大概是两天看完的，这一部分主要还是以后需要查阅，只是知道了大概的用法吧。想学数据结构了，应该接下来就是了！淦！！ 《想见你》大结局啦，哭死了，这部剧挺好的，撒花❀ 详情见下一篇文章qaq😢 C++标准模板库（STL）介绍 💡写在前面： 除了vector和string外的STL容器都不支持*(it+i)的访问方式，只能it=name.begin( )+i it++; *it vector的常见用法 向量，可变长数组 12#include&lt;vector&gt;using namespace std; 定义 1vector&lt;typename&gt; name; //typename可以是任意类型int，double,char 1234vector&lt;int&gt; name;vector&lt;node&gt; name; //node是结构体类型vector&lt;vector&lt;int&gt; &gt; name; //&gt;&gt;之间要加空格，否则视为移位操作vector&lt;typename&gt; Arrayname[arrySize];//一维可伸长，上面的是二维 元素访问（下标访问和迭代器iterator访问） 迭代器类似指针,通过*it访问vector里元素 123456789101112131415161718vector&lt;typename&gt; vi;vi[index];//下标访问for(int i=i;i&lt;=5;i++){ vi.push_back(i);}for(vector&lt;int&gt;::iterator it=vi.begin();i!=vi.end();i++){ printf(\"%d\",*it);}for(int i=0;i&lt;vi.size();i++){ printf(\"%d\",v[i]);}vector&lt;typename&gt;::iterator it = vi.begin();//取首地址vi[0]vi.push_back(i);//在末尾赋值vi.end();//取尾地址的下一个地址printf(\"%d\",*(it+i));//输出vi[i]; 常用函数 用的时候都是name.👇 1234567push_back(x);//在vector后面添加元素xpop_back();//删除vector尾元素size();//返回vector中元素的个数clear();//清空所有元素insert(it,x);//vi.insert(vi.begin()+2,-1)在vi[2]处插入-1erase();//vi.erase(vi.begin()+3)删除vi[3] //vi.erase(vi.begin()+1,vi.begin()+4);删除vi[1]-vi[3] 用途：储存数据like数组，用邻接表储存图 set的常见用法详解 集合，内部自动有序且不含重复元素的容器 12#include &lt;set&gt;using namespace std; 定义（其实和前面的一样） 123456set&lt;typename&gt; name;set&lt;int&gt; name;set&lt;double&gt; name;set&lt;char&gt; name;set&lt;node&gt; name;set&lt;typename&gt; Arrayname[arraySize]; 访问，只能用迭代器iterator访问，且只能枚举 1set&lt;typename&gt;::iterator it; 123456789set&lt;int&gt; st;st.insert(3);st.insert(5);st.insert(2);st.insert(3);for(set&lt;int&gt;::iterator it=st.begin();i!=st.end();it++){ printf(\"%d\",*it);}输出为2 3 5（自动递增，删除重复元素） 函数 st.👇 1234567insert(x);//将x插入set容器，自动增序，去重find(value);//返回set中对应值为value的迭代器，it=find(2)erase();erase(it);erase(value);erase(first,last);//迭代器//st.erase(st.find(200)); st.erase(400);//st.erase(it,st.end)size();//元素个数clear();//清空 用途：自动去重并升序 unordered_set可以只去重不排序 multiset可以处理不唯一的情况 string的常见用法详解 12#include&lt;string&gt;using namespace std; 定义 12string str;string str=\"abcd\"; 访问 1234str[i];cin&gt;&gt;str;count&lt;&lt;str;//读入读出整个字符串只能用cin count，除非转换👇printf(\"%s\\n\",str.c_str());//用c_str()将string型str变成字符数组 1234string::iterator it;for(string::iterator it=str.begin();it!=str.end();it++){ printf(\"%c\",*it);} 常见函数 12str3=str1+str2;//将str1和str2拼接，赋值给str3str1+=str2;//将str2直接拼接到str1上 12if(str1&lt;str2) ...== != &lt; &lt;= &gt; &gt;= 比较规则是字典序 12length()/size()printf(\"%d %d\",str.length(),str.size()); 12345insert()insert(pos,string);//在pos号位置插入sringinsert(it,it2,it3);//在it处插入[it2,it3)str.insert(3,str2);str.insert(str.begin()+3,str2.begin(),str2.end()); 12345erase(it);erase(first,last);erase(pos,length);//需要删除的起始位置+删除个数str.erase(str.begin()+4);str.erase(str.begin()+2,str.end()-1); 12clear();str.clear(); 12substr(pos,len);//返回从pos号位开始，长度为len的字串cout&lt;&lt;str.substr(14,4)&lt;&lt;endl; 1string::npos==-1/4294967295;作为函数失配时的返回值 123find();str.find(str2);//str2是子串时返回第一次出现的位置，否则返回👆str.find(str2,pos);//从str的第pos号为开始匹配，返回值与上相同 12replace(pos,len,str2);//把str从pos号位长度为len的字串替换为str2replace(it1,it2,str2);//str[it1,it2)替换为str2 将数转化成科学计数法并比较的题A1060（看书(x)） map的常用用法详解 映射，可以建立任何基本类型之间的映射 12#include&lt;map&gt;using namespace std; 定义 12map&lt;typename1,typename2&gt; mp;//键，值map&lt;string,int&gt; mp;//如果时字符串到整型只能是string，不能是char 访问 会按键从小到大自动排序（内部红黑树实现同set） 12345678910map&lt;string,int&gt; mp;mp['m']=20;mp['c']=30;mp['a']=40;printf(\"%d\",mp['c']);mp&lt;typename1,typename2&gt;::iterator it;//迭代器for(map&lt;char,int&gt;::iterator it=mp.begin();it!=mp.end();it++){ printf(\"%c %d\\n\",it-&gt;first,it-&gt;second);}it-&gt;first是当前映射的键，it-&gt;second是当前映射的值 函数 mp.👇 1234find(key);//返回键为key的映射的迭代器 it=mp.find('b');erase(); mp.erase(it); mp.erase(key); mp.erase(first,last);size();//映射的对数clear(); 用途：需要建立字符与整数之间的映射，判断大整数或者其他类型数据是否存在，字符串和字符串的映射 一般一一对应，mutimap一个键可以对应多个值 unordered_map以散列代替map内部红黑树实现，不按key排序，更快 queue的常见用法详解 队列，先进先出的容器 12#include&lt;queue&gt;using namespace std; 定义 1queue &lt;typename&gt; name; 元素访问 1234queue&lt;int&gt; q;q.push(i);//push(i)将i压入队尾printf(\"%d %d\\n\",q.front(),q.back());//只能通过front()来访问队首元素，back()访问对尾元素 函数 q.👇 12345push(x);//x进入队列front();back();//分别获得对首元素和队尾元素pop();//令队首元素出列empty();//检测队列是否为空，返回true则空，false则非空size();//返回queue内元素的个数 用途：需要实现广度优先搜素 💡使用front和pop函数前必须用empty函数判断队列是否为空，否则可能出现错误 deque，双端队列，首尾皆可插入 priority_queue，优先队列，使用堆实现，默认将最大元素至置于对首 priority_queue的常见用法详解 优先队列，队首元素为当前队列中优先级最高的（底层的数据结构堆heap会随时调整结构） 12#inlcude&lt;queue&gt;using namespace std; 定义 1priority_queue&lt;typename&gt; name; 访问，没有front和back，只有top访问队首元素（堆顶元素） 12345priority_queue&lt;int&gt; q;q.push(3);q.push(4);q.push(1);printf(\"%d\",q.top()); 函数 q.👇 12345push(x);//令x入列top();//获得队首元素pop();//令首队元素出队empty();//检测队列是否为空，true/falsesize();//返回元素个数 元素优先级的设置 基本数据类型（int,double,char）, 默认数字大的优先级更高（字典序） 12345priority_queue&lt;int&gt; q;//和下面一个相同priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;//数字大的优先级大priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;//数字小的priority_queue&lt;double,vector&lt;double&gt;,less&lt;double&gt; &gt; q;priority_queue&lt;char,vector&lt;char&gt;,less&lt;char&gt; &gt; q; 结构体 123456789101112131415161718struct fruit{ string name; int price;};//现在希望水果价格高的优先级高，需要用到重载小于号&lt;struct fruit{ string name; int price; friend bool operator &lt; (fruit f1,fruit f2){ //&gt;会出错 return f1.price &lt; f2.price; }//重载后小于号还是小于号}priority_queue&lt;fruit&gt; q;//内部就是价格高的优先级高//将return中的&lt;改成&gt;即实现价格低的优先级高//如果结构体内的数据较为庞大，出现字符串/数组，建议使用引用friend bool operator &lt; (const fruit &amp;f1,const fruit &amp;f2){ return f1.price &gt; f2.price;} 也可以重载在结构体外面 123456789struct cmp{ bool operator()(fruit f1,fruit f2){ return f1.price &gt; f2.price; }//这里返回true的优先级低一些/* bool operator()(const fruit &amp;f1,const fruit &amp;f2){ return f1.price &gt; f2.price; } */}prioity_queue&lt;fruit,vector&lt;fruit&gt;,cmp&gt; q; 常见用途：可以解决一些贪心问题，对Dijkstra算法进行优化 💡使用top前必须用empty判断队列是否为空 stack的常见用法详解 栈，后进先出的容器 123#include&lt;stack&gt;using namespace std;stack&lt;typename&gt; name; 访问，只能top 12st.push(i);printf(\"%d\",st.top()); 函数 st.👇 12345push(x);top();//获得栈顶元素pop();//弹出栈顶元素empty();//检查是否为空，返回true/falsesize();//返回元素个数 常见用途：实现一些递归，防止程序对栈内存的限制而导致程序出错 pair的常见用法详解 两个元素绑在一起作为一个合成元素，可以看作内部有两个元素的结构体 且两个元素的类型可以指定 1234struct pair{ typeName1 first; typeName2 second;}; 12#include&lt;utility&gt; //或者#include&lt;map&gt;,里面包含utilityusing namespace std; 123pair&lt;typeName1,typeName2&gt; name;pair&lt;string,int&gt; p;pair&lt;string,int&gt; p(\"haha\",5); 元素访问，pair中只有两个元素，first和second 1234567p.first = \"haha\";p.second = 5;cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl;p = make_pair(\"xixi\",55);cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl;p=pair&lt;string,int&gt;(\"heihei\",555);cout&lt;&lt;p.first&lt;&lt;\" \"&lt;&lt;p.second&lt;&lt;endl; 函数，比较操作数 == != &lt; &lt;= &gt; &gt;= 先以first大小作为标准，再比较second 用途：代替二元结构体机器构造函数 作为map的键值对进行插入 123map&lt;string,int&gt; mp;mp.insert(make_pair(\"heihei\",5));mp.insert(pair&lt;string,int&gt;(\"haha\",10)); algorithm头文件下的常用函数 12#include&lt;algorithm&gt;using namespace std; max,min,abs 123max(x,y);max(x,max(y,z));//返回最大值min(x,y);abs(x);//x必须是整数，浮点型用math头文件下的fabs swap 1swap(x,y);//用来交换x和y的值 reverse 可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)的元素进行反转 1reverse(it,it2); next_permutation 给出一个序列在全排序中的下一个序列 已到达全排序最后一个则返回false 1234int a[10]={1,2,3};do{ printf(\"%d%d%d\\n\",a[0],a[1],a[2]);}while(next_permutation(a,a+3)); fill 可以把数组或容器中的某一段区间赋为某个相同的值 和memset不同，这里的赋值可以赋任意值 12int a[5]={1,2,3,4,5};fill(a,a+5,233); sort() sort函数的使用 1234#include &lt;algorithm&gt;using namespace std;sort (首元素地址,尾元素地址的下一个地址,比较函数(非必填));//第二项-排序几个数就是首元素地址加几 第三个可选参数就是compare函数（cmp），用来实现排序规则 💡注意！！这个cmp是函数！返回bool类型，要放在main外面！！ ①基本数据类型数组 默认从小到大，想要从大到小: 1234bool cmp(int a,int b){ return a &gt;b; //当a&gt;b时把a放到b前面}sort(a,a+4,cmp); ②结构体数组的排序 12345678910111213struct node{ int x,y;}ssd[10];//按照x从大到小(一级排序)bool cmp(node a,node b){ return a.x&gt;b.x; }//x相等时按y排序(二级排序)bool cmp(node a,node b){ if(a.x != b.x) return a.x &gt; b.x; else return a.x &lt; a.y;}sort(ssd,ssd+3,cmp);//排序 ③容器的排序 只有vector，string，deque是可以用sort的 像set，map这种容器都是用红黑树实现的，元素本身有序的 vector 12345678910111213bool cmp(int a,int b){ return a&gt;b;}int main(){ vector&lt;int&gt; vi; vi.push_back(3); vi.push_back(1); vi.push_back(2); sort(vi.begin(),vi.end(),cmp); for(int i=0;i&lt;3;i++){ printf(\"%d \",vi[i]); }} string，默认字典序从小到大 1234//如果要字符串长度从小到大bool cmp(string str1,string str2){ return str1.length() &lt; str2.lengh();} lower_bound 和 upper_bound lower_bound(first,last,val)返回范围内第一个值大于等于val的元素的位置（指针/迭代器） upper_bound(first,lasst,val)返回第一个值大于val元素的位置 如果找不到返回的是该元素应当在的位置 123int a[10]={1,2,2,3,3,3,5,5,5,5};printf(\"%d,%d\\n\",lower_bound(a,a+10,3)-a, / upper_bound(a,a+10,3)-a); k document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C++","slug":"C","permalink":"http://pluto-wei.github.io/tags/C/"}]},{"title":"数学入门","slug":"数学入门","date":"2020-02-15T03:12:29.000Z","updated":"2020-02-15T04:33:12.909Z","comments":true,"path":"2020/02/15/数学入门/","link":"","permalink":"http://pluto-wei.github.io/2020/02/15/%E6%95%B0%E5%AD%A6%E5%85%A5%E9%97%A8/","excerpt":"唔，这里是算法笔记第五章-数学问题💓 大概是两天半吧，内容挺少的。后面还划水了一部分😜 至此入门的三章算是看完咯！","text":"唔，这里是算法笔记第五章-数学问题💓 大概是两天半吧，内容挺少的。后面还划水了一部分😜 至此入门的三章算是看完咯！ 迟到的情人节快乐哟🤗 入门篇3–数学问题 简单数学 只要掌握简单的数理逻辑 最大公约数与最小公倍数 一般用gcd(a,b)表示a,b的最大公约数 一般用欧几里得算法（辗转相除法） 12345int gcd(int a,int b){ if(b==0) return a; else return gcd(b,a%b); //简洁：return !b?a:gcd(b,a%b);} 一般用lcm(a,b)来表示最小公倍数 最大公约数d，最小公约数a/d*b 分数的四则运算 分数的表示和化简 假分数，只有分子和分母 注意分母不能为0啦 123struct Fraction{ //分数 int up,down; //分子分母} down为非负数 若分数为0，则up=0，down=1 分子分母没有除了1以外的公约数 123456789101112131415//分数的化简Fraction reduction(Fraction result){ if(result.dowm&lt;0){ result.up=-result.up; result.down=-result.down; } if(result.up==0) { result.down=1; }else { int d=gcd(abs(result.up),result.down); result.up/=d; result.down/=d; } return result;} 分数的四则运算 加减乘除 123456789Fraction add(Fraction f1,Fraction f2){ Fraction result; result.up=f1.up*f2.down+f2.up*f1.down;//分数和的分子 result.down=f1.down*f2,down;//分数和的分母 return reduction(result);//化简 }Fraction minu(Fraction f1,Fraction f2);Fraction multi(Fraction f1,Fraction f2);Fraction divide(Fraction f1,Fraction f2); 分数的输出 123456789void showResult(Fraction r){ //输出分数r r=reduction(r); if(r.down==1) printf(\"%lld\",r.up); //整数 else if(abs(r.up)&gt;r.down) { //假分数 printf(\"%d %d/%d\",\\ r.up/r.down,abs(r.up)%r.down,r.down); }else printf(\"%d/%d\",r.up,r.down); //真分数 } 💡分数的乘法和除法过程中可能使分子或分母超过int，一般用long long 素数 素数的判断 1234567bool isPrime(int n){ if(n&lt;=1) return false; //特判 int sqr=(int)sqrt(1.0*n); //根号n, math.h for(int i=2;i&lt;sqr;i++){ //用i*i&lt;n容易溢出 if(n%i==0) return false; }return true;} 素数表 筛法，通过bool实现 123456789101112int prime[maxn];bool isPrime[maxn]={0};int findPrime(int n){ int j=0; for(int i =2;i&lt;maxn;i++){ if(!isPrime[i]){ prime[j++]=i; //第j个素数是i for(int k=i+i;k&lt;maxn;k+=i){ isPrime[k]=1; //标识i的倍数 } }if(j==n) break; }return 0; 质因子分解 定义结构体factor，用来存放质因子及其个数 123struct factor{ int x,cnt; //x为质因子，cnt为其个数 }fac[10]; fac[ ]数组存放n的所有质因子，int范围只需要fac[10]就够了 大整数运算 大整数存储 没有考虑负数 12345678struct bign{ //bignumber int d[1000]; int len; bign(){ memset(d,0,sizeof(d)); //初始化 len = 0; }} 输入字符串时，先用字符串读入，再把字符串另存为bign结构体 char数组读入时，整数的高位存储在低位，所以倒着赋给d[ ]数组 12345678bign change(char str[]){//把整数转化为bign bign a; a.len = strlen(str); for(int i=0;i&lt;a.len;i++){ a.d[i]=str[a.len-i-1]-'0';//逆着赋值 } return a;} 比较大小 12345678910int compare(bign a,bign b){ if(a.len&gt;b.len) return 1; //a大 else if(a.len&lt;b.len) return -1; //a小 else{ for(int i=a.len-1;i--){ if(a.d[i]&gt;b.d[i]) return 1; else if(a.d[i]&lt;b.d[i]) return -1; }return 0; //相等 }} 高精度四则运算 存在负号另外处理 12345678910111213bign add(bign a,bign b){ //两正数相加 bign c; int carry=0; //进位 for(int i=0;i&lt;a.len||i&lt;b.len;i++){ int temp =a.d[i]+a.d[i]+carry; c.d[c.len++]=temp%10; //注意这里是c.len carry=temp/10; } if(carry!=0){ c.d[c.len++]=carry; } return c;} 123456789101112bign sub(bign a,bign b){ //大数减小数，否则交换 bign c; for(int i=0;i&lt;a.len||i&lt;b.len;i++){ if(a.d[i]&lt;b.d[i]){ a.d[i+1]--; a.d[i]+=10; }c.d[c.len++]=a.d[i]-b.d[i]; } while(c.d[c.len-1]==0&amp;&amp;c.len!=1){ c.len--;//保证结果至少有一位数 }} 1234567891011121314bign multi(bign a,int b){ //高精度乘低精度 bign c; int carry; for(int i=0;i&lt;len.a;i++){ int temp=a.d[i]*b+carry; c.d[c.len++]= temp%10; carry=temp/10; } while(carry!=0){ c.d[c.len++]=carry%10; carry/=10; } return c;} 1234567891011bign devide(bign a,int b,int&amp; r){ //使r值可以传出，初值为0 bign c; c.len=a.len; for(int i=a.len-1;i&gt;=0;i--){ r=r*10+a.d[i]; c.d[i]=r/b; r=r%b; }while(c.d[c.len]==0&amp;&amp;c.len!=1){ c.len--; }return c;} 拓展欧几里得算法 👇都是整数解 求解 ax+by=gcd(a,b) 求解ax+by=c，c是gcd的倍数才有解 同余式ax≡c(mod m)的求解 逆元的求解 计算(b/a)%m 唔，这个看书吧 迷迷糊糊 组合数 n的阶乘的质因子p的个数 组合数的计算 好麻烦啊，，看书吧，后面跳过了几种方法，没看完。逐渐失去兴趣 over document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"写个博客纪念一下","slug":"写个博客纪念一下","date":"2020-02-13T11:03:17.000Z","updated":"2020-02-28T16:19:45.554Z","comments":true,"path":"2020/02/13/写个博客纪念一下/","link":"","permalink":"http://pluto-wei.github.io/2020/02/13/%E5%86%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E7%BA%AA%E5%BF%B5%E4%B8%80%E4%B8%8B/","excerpt":"","text":"应该昨天就发的！ 因为就是在昨天，我的博客终于有了标签和分类，算是有了完整的界面。终于没有那么多地方点开都是404了！！ 但是还是好丑嗷~~ https://www.jianshu.com/p/e17711e44e00 https://blog.csdn.net/KnownAll/article/details/81360235 https://www.jianshu.com/p/c311d31265e0 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"心情qaq","slug":"心情qaq","permalink":"http://pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"算法入门！","slug":"算法入门！","date":"2020-02-12T05:03:48.000Z","updated":"2020-02-12T07:37:14.641Z","comments":true,"path":"2020/02/12/算法入门！/","link":"","permalink":"http://pluto-wei.github.io/2020/02/12/%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8%EF%BC%81/","excerpt":"算法终于入门了！！ 快乐！！！ 从2月6号算起来刚好一个星期 这里是《算法笔记》3,4 章","text":"算法终于入门了！！ 快乐！！！ 从2月6号算起来刚好一个星期 这里是《算法笔记》3,4 章 2333还行吧，最近看剧《想见你》有点上头 还有10天就要开学了呜呜呜，学的东西好少😢淦！ 下面👇进入正题 入门篇1–入门模拟 简单模拟 查找元素 图形输出 日期处理 进制转换 字符串处理 💡 以下是一些做题过程中的笔记 12345678910int step = 0;//计数器int count = 0;//计数，num好奇怪int ans = 0;int temp;//临时存放const int maxn = 100010;//?? 210??int a[100]={0};//这是全部为0，但{1}=1,0,0,0,int row,col;//行，列int rank,score;//排名，分数char id[15];//当int不够用的时候bool flag = true;//标志 日期有点意思， 关于进制 12345//不能直接读入读出二进制数%d 十进制%o 八进制%x %X 十六进制 小写大写形式%u 无符号十进制 123#include &lt;cstdio&gt;#include &lt;cstring&gt;//可以直接用bool 12唔，scanf到底什么时候返回0什么时候返回EOF啊？？反正黑框输入的时候必须ctrl+z手动结束 入门篇2–算法初步 💡 笔记中有些代码示例没有写明哪些是主函数里的，哪些不是，需自行区分 排序 排序 冒泡排序 选择排序 插入排序 （插入用于排列多个结构体的时候就需要交换两个结构体变量，而不能直接交换他们的排名，因为实际位置不变的话，就无法寻找排名的上一位然后去比较，所以还是用sort函数吧） （而且插入排序的顺序记录好像就是数组下标，不能出现并列的情况） 排序题与sort函数的应用 对于涉及到排序的题目，建议直接使用c++中的sort函数，将精力放在题目逻辑本身 1234//sort函数的使用（详情见c++标准模板库STL）#include &lt;algorithm&gt;using namespace std;sort (首元素地址,尾元素地址的下一个地址,比较函数(非必填)); 排序题型常用的解题步骤 相关结构体的定义 cmp函数的编写 排名的实现 💡 要判断两个字符串是否相等，不能直接==，要用strcmp，返回正数，0，负数 💡（有些东西不自己做还真不知道） 12345//cmp函数的编写bool cmp(student a,student b){ if(a.score != b.score) return a.score &gt; b.score; else return strcmp(a.name,b.name)&lt;0;//string.h} 123456789//把排名记录下来stu[0].r=1;for(int i=1;i&lt;n;i++){ if(stu[i].score == stu[i-1].score){ stu[i].r = stu[i-1].r; }else { stu[i].r = i+1; }} 1234567//要输出排名的时候，不在结构体里定义可以让代码变得简洁int rank = 1;for(int i=0;i&lt;num;i++){ if(i&gt;0&amp;&amp;stu[i].score!=stu[i-1].score){ rank=i+1; }//就可以printf了，否则rank就跟上一个一样} 散列 散列(hash)是常用的算法思想之一 将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素，这个转换函数称为散列函数H 整数 key 123456//hashTable数组，记录正整数是否出现过bool hashTable[maxn] = {false};for(int i=0;i&lt;n;i++){ scanf(\"%d\",&amp;x); hashTable[x]=true; //x出现过}//或者用int型记录次数 key 元素转换后变成整数 H ( key ) 123H(key)=key;//直接定址法中的恒等变换H(key)=a*key+b;//直接定址法中的线性变换H(key)=key%mod;//除留余数法，转换很大的数，mod取成表长TSize 有时会出现冲突的情况，可以直接用标准库模板库中的map 字符串 hash 初步 将字符串转化为唯一的整数 二十六进制，五十二进制转换为十进制，len不能太长 123456789101112131415161718192021222324int hashFunc(char s[],int len){ //转换函数 int id = 0; for (int i=0;i&lt;len;i++){ //id = id*26+(s[i]-'A');//26-&gt;10 if(s[i]&gt;='A'&amp;&amp;s[i]&lt;='Z'){ id =id*52+s[i]-'A'; }else if(s[i]&gt;='a'&amp;&amp;s[i]&lt;='z'){ id = id*52+(s[i]-'a')+26; }//52-&gt;10 }}int hashTable[26*26*26+10]={0};//3位大写字母+日常加10int main (){ for(int i=0;i&lt;n;i++){ scanf(\"%s\",s[i]); int id = hashFunc(s[i],3); hashTable[id]++; } for(int i=0;i&lt;m;i++){ scanf(\"%s\",temp); int id = hashFunc(temp,3); printf(\"%d\\n\",hashTable[id]); }} 递归 分治 分而治之，分解、解决、合并，是一种算法思想，可以用递归的手段实现 分治法分解出的子问题应当是相互独立没有交叉的 子问题个数为1称为减治，子问题个数大于1称为分治 递归 反复调用自身函数，把问题范围缩小，直到可以直接得到边界 12345//求Fibonacci数列第n项int F(int n){ if(n==0||n==1) return 1; //递归边界 else return F(n-1)+F(n-2); //递归式 } 123456789101112131415161718192021//输出1~n的全排列#include &lt;cstdio&gt;const int maxn =11;int n,P[maxn],hashTable[maxn]={false};void generateP(int index){ if(index == n+1){ //递归边界 for(int i=1;i&lt;=n;i++){ printf(\"%d\",P[i]); }printf(\"\\n\"); return; } for(int x=1;x&lt;=n;x++){ if(hashTable[x]==false){ P[index]=x; hashTable[x]=true; generateP(index+1); //递归在这里！！！ hashTable[x]=false; } }}generateP(1);//从1开始的全排序 暴力法–枚举所有情况判断是否合法 回溯法–在到达递归边界前的某层，由于不需要再往前递归，直接返回上一层 12345678910//n皇后问题，对每种可能的情况暴力法bool flag = true;for(int i=1;i&lt;=n;i++){ for(int j=i+1;j&lt;=n;j++){ if(abs(i-j)==abs(P[i]-P[j])){ flag=false; break; } }}if(flag) num++; 1234567891011121314151617181920212223242526272829303132333435//回溯法就是把该判断每加一个数就执行一次，实时检验//还是自己写的好理解👇#include &lt;cstdio&gt;#include &lt;math.h&gt;int P[10];int n;//n是总数int m,x;//m是要填的数，x是填到的位置int hash[10]={false};int count=0;//符合条件的个数void gP(int x){ if(x==n+1){ count ++; return;//该函数结束，不是break哦 } for(int m=1;m&lt;=n;m++){ //记住是把m填到x位上，对应就是(m,x)坐标 if(hash[m]==false){ bool flag = true; for(int i=1;i&lt;=x-1;i++){ if(abs(i-x)==abs(P[i]-m)){ flag=false; break; } }if (flag){ P[x]=m; hash[m]=true; gP(x+1); hash[m]=false; }//else m就不能填在x位，那么进行下一个循环m+1，看是否可以 } }} 贪心 贪心法是求解一类最优化问题的方法 考虑当前状态下的局部最优，来使全局最优 证明一般采用反证法和数学归纳法 有简单贪心问题和区间贪心，即区间不相交问题和区间选点问题 💡注意这个不能左端点从小到大，只能右端点从小到大，左端点从大到小！！不需要代码额外减去更大包含别人了的区间，会自己很好排除掉 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;algorithm&gt;using namespace std;const int maxn =110;struct Inteval{ //interval是区间 int x,y;//开区间左右端点}I[maxn];bool cmp(Inteval a,Inteval b){ if(a.y=b.y) return a.x&gt;b.x; else return a.y&lt;b.y;}int main(){ int n; while(scanf(\"%d\",&amp;n),n!=0){ for(int i=0;i&lt;n;i++){ scanf(\"%d%d\",&amp;I[i].x,&amp;I[i].y); } }sort(I,(I+n),cmp); int step=1,Y=I[0].y;//计数,记到的位置，右边的坐标 for(int i=1;i&lt;n;i++){ if(I[i].x&gt;Y){ Y=I[i].y; step ++; } }printf(\"%d\",step); return 0; } 二分 二分查找 O ( lognlognlogn ) 12345678910111213#include &lt;stdio.h&gt;//A[]为严格递增序列，left为二分下界，right为二分上界，x为欲查询的数，二分区间为闭区间，传入的初值为[0,n-1]int binarySearch(int A[],int left,int right,int x){ int mid; while(left &lt;= right){ mid = (left + right)/2; if(A[mid]==x) return mid; if(A[mid]&gt;x) right=mid-1; else left=mid+1; }return -1;//查找失败，返回-1}//二分上届如果超过int数据类型的一半，查询元素靠后的时候right+left就有可能溢出，一般使用👇代替mid=left+(right-left)/2; “寻找有序序列第一个满足某条件的元素的位置”问题的固定模板 1234567891011int solve(int left,int right){ int mid; while(left&lt;right){ mid=(left+right)/2; if(条件成立){ right=mid; }else{ left=mid+1; } }} 二分法拓展 求近似值，方程的近似根 123456789101112131415const double eps = 1e-5;double f(double x){ return ...;}double solve(double L,double R){ double left = L,right = R; while(right-left &gt; eps){ mid = (rigth+left)/2; if(f(mid)&gt;0){ //递增 right = mid; }else{ left = mid; } }return mid;} 关于书上留的一个思考题，👇是别人的一些解答 https://blog.csdn.net/a845717607/article/details/79079862 https://blog.csdn.net/liuerin/article/details/98961797 最后一排表达式应该是等号，下面是关于圆心在外部的理解，也就是说，有外接圆存在的组合只有一种可能，R没有别的可能性，变大变小都不可能构成多边形（想想也知道R变小除最大边以外都不变的话，最大边必须要变小） 最后用二分法求解即可 快速幂 要求aba^bab%m，循环部分为ans = ans * a % m，注意每一次都要%m，a=a%m，但是可能还是很大，当b&lt;101810^{18}1018时，复杂度太高 m要是等于1直接就是0了 二分指数b，将时间复杂度变为logn，递归写法👇 12345678910typedef long long LL;LL binaryPow(LL a,LL b,LL m){ if(b==0) return 0; if(b%2==1) return a*binaryPow(a,b-1,m)%m; else{ LL mul = binary(a,b/2,m); return mul*mul%m; //要是两个binary(a,b/2,m)相乘，复杂度又变成b了 }}//(b%2==1)等价于(b&amp;1) 位与操作 迭代写法👇（二进制，aba^bab可以写成a2ka^{2^k}a2k,…,a8a^8a8,a4a^4a4,a2a^2a2,$a^1中若干项的乘积） 12345678LL binaryPow(LL a,LL b,LL m){ LL ans = 1; while(b&gt;0){ if(b&amp;1) ans = ans*a%m; a=a*a%m; b &gt;&gt;= 1; //将b的二进制右移一位，即b=b/2 }return ans;} two pointers two pointers and 序列合并 利用有序序列的枚举特性降低复杂度–编程计较 最原始就是指的下面第一个问题，广义就是利用问题本身与序列的特性，使用下标 i,j 对序列进行扫描 123456789//在递增序列中找和为定值的两个数while(i&lt;j){ if(a[i]+a[j]==m){ printf(\"%d %d\\n\",a[i],a[j]); i++;j--; }else if(a[i]+a[j]&lt;m){ i++; }else j--;} 1234567891011121314//序列合并问题,将递增序列A B合并到C里int merge(int A[],int B[],int C[],int n,int m){ int i=0,j=0,index=0; while(i&lt;n&amp;&amp;j&lt;m){ if(A[i]&lt;=B[j]){ C[index++]=A[i++];//这里就不要啰嗦了好不好 }else{ C[index++]=B[j++]; } } while(i&lt;n) C[index++]=A[i++]; while(j&lt;m) C[index++]=B[i++]; return index;//为什么要返回序列的长度？？} 归并排序 是一种基于归并思想的一种排序方法 最基本的2-路归并排序 归并排序 递归实现 123456789101112const int maxn = 100;void mergeSort(int A[],int left,int right){ if(left&lt;right){ int mid = (left+right)/2; mergeSort(A,left,mid); mergeSort(A,mid+1,right); //注意1和2的时候mid是1，这两个都是left=right //也就是排序(1,1)和(2,2) merge(A,left,mid,mid+1,right); //和two pointers类似 }} 非递归实现 1234567891011void mergeSort(int A[]){ for(int step=2;step/2&lt;=n;step*2){ for(int i=1;i&lt;=n;i+=step){ int mid =i+step/2-1; if(mid +1&lt;=n){//如果右子区间存在 merge(A,i,mid,mid+1,min(i+step-1,n)); //注意这里的min去更小的一个 } }//每循环排列step个，但step可能&gt;n,例如step16，n12 }}//可以说这种方法要考虑很多了 快速排序 quickSort 函数 Partition 函数，👇，返回相遇的下标，即原先最左边的函数 randPartition函数，在上面的函数基础上增加了随机数 选取最左边的元素，排成：比他小的在左边，比他大的在右边的顺序 对他左边和右边通过递归采取同样的操作 当序列中的元素排列随机是效率较高，元素接近时会达到最坏时间复杂度（因为主元没有将区间划分成两个长度接近的区间） 随机主元可以保证任意数据的期望时间复杂度是nlogn 1234567891011//产生随机数据#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;int main(){ srand((unsigned)time(NULL)); //在main函数的开头加，生成随机数的种子 for(int i=0;i&lt;10;i++){ printf(\"%d\",rand());//使用随机数 }return 0;} 12345//rand()范围[0,RAND_MAX]这是stdlib里的一个常数//给定范围[a,b]rand()%(b-a+1)+a;//更大范围的随机数b-a&gt;max(int)((double)rand()/32767*(b-a+1)+a); 其他高效技巧和算法 打表 将所有可能用到的结果事先计算出来，用的时候直接查表获得 适用于：需要大量查询某数据；没有想到好的算法超时；从大量数据中找规律 活用递推 过程中可能存在的递推关系 例如某值可以通过左右两侧的结果得到 随机选择算法 从无序数组中找到第K大的数 与随机快速排序算法类似 123456789101112//从A[left,right]中返回第K大的数int randSelect[int A[],int left,int right,int K]{ if(left==right) return A[left]; int p=randPartition[A,left,right]; //划分后主元的位置p。该函数详情见快速排序👆 //注意该函数对数组的修改就是对原数组的修改 int M = p-left+1;//A[p]是原A序列中的第M大 if(K==M) return A[p]; if(K&lt;M) return randSelect[A,left,p-1,K]; else return randSelect[A,p+1,right,K-M];} 完整的代码见4.7.3 OVER ! document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"算法","slug":"算法","permalink":"http://pluto-wei.github.io/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"关于全排序的一些理解","slug":"关于全排序的一些碎碎念","date":"2020-02-09T14:29:04.000Z","updated":"2020-02-12T05:43:56.989Z","comments":true,"path":"2020/02/09/关于全排序的一些碎碎念/","link":"","permalink":"http://pluto-wei.github.io/2020/02/09/%E5%85%B3%E4%BA%8E%E5%85%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"这个递归真的想了好久 就是觉得别扭，想bb几句🤐","text":"这个递归真的想了好久 就是觉得别扭，想bb几句🤐 来理解一下全排序(递归) 123456789101112131415161718192021//输出1~n的全排列#include &lt;cstdio&gt;const int maxn =11;int n,P[maxn],hashTable[maxn]={false};void generateP(int index){ if(index == n+1){ //递归边界 for(int i=1;i&lt;=n;i++){ printf(\"%d\",P[i]); }printf(\"\\n\"); return; } for(int x=1;x&lt;=n;x++){ if(hashTable[x]==false){ P[index]=x; hashTable[x]=true; generateP(index+1); //递归在这里！！！ hashTable[x]=false; } }}generateP(1);//从1开始的全排序 要写从1~3的全排序： 一共三位 第一位从1开始循环，每一轮回就是引用一次剩下2个数的全排列 每用一个数，就用hashTable标记该数已经使用，然后开始下一位的全排列，并在排列完并输出以后，恢复这个数没有使用的状态，并且这个数没到最大值的话，这一位上的这个数就要加一了，否则就会退出。（该前面的数恢复了） n个数排完后会执行generateP(n+1)，就会输出这n个数，然后返回继续后面的步骤，继续排列 比如generateP(2)，就是从第二位开始的全排列，不会给前面赋值，第一位每个数都会调用一次generateP(2)，当然前面用过的数会不再使用 直到最后一个数的全排序，就等于剩下的那个数 但是递归边界又不能写只剩最后一个数， 123456789101112131415161718192021222324#include &lt;cstdio&gt;int n,m,P[100];//n是总数，m是当前填的数，x是位数bool hT[100]={false};void g (int x){ if(x==n){ for(int i=1;i&lt;=n;i++){ if(hT[x]==false){ P[x]=i; } } for(int i=1;i&lt;=n;i++){ printf(\"%d\",P[i]); }printf(\"\\n\"); return; }for(int m=1;m&lt;n;m++){ if(hT[m]==false){ P[x]=m; hT[m]=true; g(x+1); hT[m]=false; } }} 为什么这样是不行的，因为g(n)运行完后跳到上一位变成false，m+1以后到了n没有循环了 也就是倒数第二位不会变成最大的数，就以为自己的全排列已经结束了 也就是最大的数永远不会出现在前面 所以递归边界不能写n，必须是n+1 1234567891011121314int main (){ n=4; g(1);}输出：123413242134231431243214n=3 时输出：123213 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"瞎想","slug":"瞎想","permalink":"http://pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"一些做题时遇到的问题","slug":"一些做题时遇到的问题","date":"2020-02-08T13:00:14.000Z","updated":"2020-02-12T05:43:16.459Z","comments":true,"path":"2020/02/08/一些做题时遇到的问题/","link":"","permalink":"http://pluto-wei.github.io/2020/02/08/%E4%B8%80%E4%BA%9B%E5%81%9A%E9%A2%98%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"有些问题发现之后就直接补充到笔记了 还有一些不直到归到哪里的问题👇","text":"有些问题发现之后就直接补充到笔记了 还有一些不直到归到哪里的问题👇 就直接写吧 结构和函数要事先声明（定义），在使用之前！或者写成 .h，否则报错 有时候数据只能读取一部分，不能继续读取并且终止了程序，很可能是循环条件写错了。逻辑问题而不是语法问题，debug啊！！ 13位的整数，写long long给我扣了几分，答案是char id[15]，不是很明白。改的时候别忘了比大小要改成strcmp document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"瞎想","slug":"瞎想","permalink":"http://pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"关于指针的初始化问题","slug":"关于指针的初始化问题","date":"2020-02-08T06:07:36.000Z","updated":"2020-02-12T05:43:49.826Z","comments":true,"path":"2020/02/08/关于指针的初始化问题/","link":"","permalink":"http://pluto-wei.github.io/2020/02/08/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/","excerpt":"不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 重要的事情说亿遍！！！！","text":"不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 重要的事情说亿遍！！！！ 老是忘掉！！！ 💡应该在给 *p赋值前要给 *p分配一个空间 💡scanf读入字符串一定要事先为它申请足够的空间 字符串 12#include &lt;stdlib.h&gt;char *str = (char*)malloc(20*sizeof(char)); 结构体指针 123456789101112#include&lt;stdio.h&gt;int main(){ struct studentInfo{ int id; char name[20]; char gender; studentInfo* next; }*p; scanf(\"%d %c\", &amp;p-&gt;id, &amp;p-&gt;gender); printf(\"%d %c\", p-&gt;id, p-&gt;gender); return 0;}//这样是无法输出的，因为对结构体指针没有进行初始化操作 12345678910111213#include&lt;stdio.h&gt;int main(){ struct studentInfo{ int id; char name[20]; char gender; studentInfo* next; }stu, *p; p = &amp;stu; scanf(\"%d %c\", &amp;p-&gt;id, &amp;p-&gt;gender); printf(\"%d %c\", p-&gt;id, p-&gt;gender); return 0;}//这样才可以！ 12345678//结构体数组指针也是一样struct student{ int id; char name;}stu[100],*p;p = stu;scanf(\"%d %s\",&amp;(p+i)-&gt;id,(p+i)-&gt;name);printf(\"%d %s\",(p+i)-&gt;id,(p+i)-&gt;name); 而那个结构体的构造函数，是用于给结构体赋值方便的一个函数，那个初始化跟这个初始化不一样 💡 其实不过就是你在给指针指向的地方赋值的时候，总得知道他指向哪里吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"瞎想","slug":"瞎想","permalink":"http://pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"}],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"Crash Course Computer Science（part 3）","slug":"Crash Course Computer science 3","date":"2020-02-06T05:19:55.000Z","updated":"2020-02-12T07:38:09.683Z","comments":true,"path":"2020/02/06/Crash Course Computer science 3/","link":"","permalink":"http://pluto-wei.github.io/2020/02/06/Crash%20Course%20Computer%20science%203/","excerpt":"本部分内容：计算机的现状和未来 完结撒花！！！！","text":"本部分内容：计算机的现状和未来 完结撒花！！！！ 今天是2020/02/06 Crash Course Computer science 计算机科学速成课 终于看完啦！！ 根据浏览器判断是2020/01/23开始的😏 除去没看的几天，一共看了13天😬还不错啦！ 强推！真的很棒！感谢款待！！ 小姐姐在此！超可爱哦！！ xjj 计算机的现状和未来 机器学习ML＆人工智能AI 机器学习算法可以让计算机从数据中学习，然后自行做出预测和决定 机器学习是为了实现人工智能这个更宏大的目标的技术之一 分类：用算法减小复杂性，把数据简化成特征，特征帮助分类 机器学习算法的目的是最大化正确分类&amp;最小化错误分类，找到最好的决策边界 源于统计学的技术：决策树，森林，支持向量机 人工神经网络，来源于大脑里的神经元。输入层，隐藏层，输出层。 算法调整偏差和权重来训练神经网络，用标记数据训练和测试，提高准确性。有激活函数，线性传递函数 加权，求和，偏置，激活函数应用于一层里的每一个神经元，并向前传播 弱人工智能：只能做特定任务，分类，找人脸，翻译，自动驾驶 强人工智能：真正通用，像人一样聪明 强化学习：学习什么管用，什么不管用 计算机视觉 颜色跟踪算法，一块块像素处理 核/过滤器，把核引用于像素块叫做卷积 核能做很多图像转换，例如锐化图像，模糊图像；可以匹配特定形状，例如边缘检测；可以描述简单的形状，例如找线段圆圈（眼睛鼻子） 多个核组合在一起，找到特征组合 卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像，本质上是被不同的核处理了，逐层深入，卷积，由小的特征组合成大的特征，直到一层把所有的特征集合到一起 生物识别 标志点 情感识别算法 自然语言处理 Natural Language Processing 把句子切成一块块，词性，短语结构规则，把语言结构化 用规则做出分析树 聊天机器人的最基本部件：处理，分析，生成文字。应用于客服 指定简单协议用于沟通–&gt;机器学习，从语言数据库中学习，深度学习网络 语音识别，波形转化成频率（快速傅里叶变换） 构成声音的不同片段：音素 语音合成 机器人 自动运行的机器，大规模生产，高效不知疲惫 可编程工业机器人，简单控制回路，负反馈回路 PID–有控制回路和反馈机制 “比例-积分-微分控制器” 机器人三定律 计算机心理学 社会心理学，认知心理学，行为心理学，感知心理学 易用读：人造物体达到目的的效率有多高 UI设计：视觉，认知系统 ，直观性 视频可以增强凝视 人机交互HRI 几乎像人类和真的人类之间的小曲线–恐怖谷 教育科技 智能辅导系统 判断规则+选择算法–域模型 贝叶斯知识追踪 自适应式程序 教育数据挖掘 虚拟现实和增强现实 奇点，天网，未来 奇点：智能科技的失控性发展 复杂度刹车：S性曲线，而非J型 手工型工作，思维型工作；重复性工作，非重复性工作 加密货币，无线通讯，3D打印，生物信息学，量子计算… 推荐： 哲学速成课，人工智能速成课， 西部世界 钻石时代 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"http://pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"C语言 快速入门！！","slug":"C语言-快速入门！！","date":"2020-02-05T04:25:10.000Z","updated":"2020-02-12T07:36:06.706Z","comments":true,"path":"2020/02/05/C语言-快速入门！！/","link":"","permalink":"http://pluto-wei.github.io/2020/02/05/C%E8%AF%AD%E8%A8%80-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%81%EF%BC%81/","excerpt":"233333 我终于快速入门了！！","text":"233333 我终于快速入门了！！ 2月2号开始看的《算法笔记》 今天终于把快速入门看完了== 4天嗷~ 突然想放一张散散~生日快乐 @7.png 下面进入正题~ 基本数据类型 变量类型： 整型：short， int ，long long 绝对值在**10910^9109**范围内（32位）都可以定义为int 101010^{10}1010-101810^{18}1018就得用long long（64位） （若赋大于int最大(231−12^{31}-1231−1)的值，则需要在初值后面加LL，才能编译成功） 浮点型：float，double 精度 float 6-7位，double15-16位 记住：遇到浮点用double 字符型： 标准ASCII范围是0-127，包含控制字符（转义字符\\n\\t\\0）和可显示字符 记住：小写字母比大写字母ASCII码大32， ‘字符’%c “字符串”%s 1234char c1 = 'z',c2 = 'j',c3 = 117;printf(\"%c%c%c\",c1,c2,c3);//字符常量（单个字符）用单引号标注//输出为 zju 布尔值： c语言中要stdbool.h true（非零）false（零） 强制类型转换 （新类型名）变量名 1printf(\"%.f\",(double)a/(double)b); 定义常量 符号常量-宏定义 define是原封不动直接替换，记得加（） 12#define 标识符 常量/任何语句或片段#define pi 3.14 const常量 12const 数据类型 变量名 = 常量；const double pi = 3.14； 运算符 算术运算符 / 取商，向下取整，舍去小数 %取余数 i++先用再加，++i先加再用 关系运算符 &lt; &gt; &lt;= &gt;= == != 逻辑运算符 &amp;&amp;与 ||或 ！非 条件运算符 唯一的三目运算符 1A ? B : C ; //A真则B，A假则C 位运算符 12const int INF = (1 &lt;&lt; 30)-1; //无穷大，上限，const int INF = 0x3fffffff;//避免两个数相加超过int最大值 按二进制进行: 左移&lt;&lt; 右移&gt;&gt; 位于&amp; 位或| 位异或^ 位取反~ 顺序结构 赋值表达式 注意 += -= /= *= %= 的运用 scanf和printf输入输出 1234567scanf(\"格式控制\"，变量地址)；scanf(\"%d\",&amp;n); //intscanf(\"%lld\",&amp;n); //long longscanf(\"%f\",&amp;fl); //floatscanf(\"%lf\",&amp;db); //doublescanf(\"%c\",&amp;c); //charscanf(\"%s\",str); //字符串char*，char str[] 除char数组整个输入 不加&amp;，其他变量类型都要加&amp; 除%c，scanf对其他格式符的输入（%d，%s）是以空白符为结束的 %c是可以读入空格跟换行的 1234567printf(\"格式控制\"，变量名称)；printf(\"%d\",n); //intprintf(\"%lld\",n); //long longprintf(\"%f\",fl); //floatprintf(\"%f\",db); //doubleprintf(\"%c\",c); //charprintf(\"%s\",str); //字符串char*，char str[] 唯一不同：double输出格式%f ，输入%lf 123printf(\"%%\");printf(\"\\\\\");printf(\"\\t \\n\"); 12345printf(\"%md\",a);//%md不足m位的int以m位进行右对齐输出，高位空格补齐printf(\"%-md\",a);//左对齐printf(\"%0md\",a); //高位补0而不是补空格printf(\"%.mf\",a); //保留m位小数printf(\"%n.mf\",a); //保留m位小数,宽度占n位 getchar与putchar输入输出 输入输出单个字符，可以识别存储换行符\\n 123456char c1,c2;c1 = getchar();getchar();c2 = getchar();putchar(c1);putchar(c2); typedef 给复杂的数据类型起别名 12typedef long long LL;LL a = 123456789012345,b = 34567890123456;//直接使用LL 常用math函数 1#include &lt;math.h&gt; 123456789fabs(double x); //对double型变量取绝对值floor(double x);//对double型变量向下取整，得到的值更小，无论正负ceil(double x); //对double型变量向上取整pow(double r,double p); //返回$r^p$sqrt(double x);//返回算术平方根log(double x);//取以e为底对数，任意底数要用换底公式sin(double x),cos(double x),tan(double x);//参数要求弧度制asin(double x),acos(double x),atan(double x);round(double x);//四舍五入到个位，返回类型double 但是这些函数直接以%f输出会都很多零 最好还是要控制位数%.0f %.mf 也可以 %d ，(int)db double x 只是说明这是一个double型变量，并不需要加上double pi精确定义为acos(-1.0) 选择结构 if 语句 1234567if (条件A) { ...} else if (条件B) { ...} else { ...} 技巧：if（n==0） 等价于if（!n），if（n!=0）等价于if（n） if语句的嵌套 switch 语句 用于分支条件比较多的情况 12345678910111213switch(表达式){ case 常量表达式1: ... break; case 常量表达式2: ... break; case 常量表达式n: ... break; default: ...} //break结束当前switch，表达式等于常量表达式n就执行第n条 循环结构 while 语句 123while(条件A){ ...} do while 语句 123do{ ...} while (条件A); for 语句 123for(表达式A;表达式B;表达式C){ ...} //先执行A，再判断B，每个循环后执行C break 和 continue 语句 break直接退出以上三种循环，switch语句 continue临时结束循环的当前轮回，进入下一轮回 数组 注意从a[0]开始 一维数组 12数据类型 数组名 [数组大小] = { , , };数组名称[下标]; //访问 二维数组 1数据类型 数组名 [第一维大小][第二维大小] = { { , , },{ }, }; 如果数组较大（10610^6106级别），需要将其定义在主函数之外 多维数组类似 memset 函数 对数组中的每一个元素赋相同的值 需要头文件string.h 建议只赋0/-1，其他数字（会出错）使用fill函数 因为memset使用的是按字节赋值 1memset(数组名,值,sizeof(数组名)); 字符数组 12char str[15] = \"Good Story!\"; //直接赋值仅限于初始化char str[15] = {'G','o',...}; //记得长度要多一个存\\0 gets和puts 输入输出 scanf 输入 printf 输出（见上文） getchar 输入 putchar 输出 （见上文） 二维数组时 用 getchar ( ) 吸收掉每行末尾的换行符 gets 输入 puts 输出 gets 识别换行符\\n作为输入结束，可以读入空格 puts 输出后会紧跟一个换行 puts 和 printf 通过识别 \\0作为字符串的结尾 如果不是 scanf的%s 或gets输入（例如getchar），要在字符串末尾加\\0 只有char型数组需要\\0，int型数组不需要 string.h 头文件 1234strlen(字符数组);//得到第一个\\0前的字符的个数strcmp(字符数组1,字符数组2);//按字典序比较两个字符串大小strcpy(字符数组1,字符数组2);//把字符数组2复制给字符数组1，包括\\0strcat(字符数组1,字符数组2);//把字符数组2接到字符数组1后面 strcmp： 从前往后比，a小于b，aaaa小于aab， 字符数组1&lt;字符数组2,则返回一个负整数； 字符数组1==字符数组2,则返回0； 字符数组1&gt;字符数组2,则返回一个正整数； sscanf 与 sprintf 第一个s理解为string，均在stdio头文件下 scanf 和 printf 只是把下面的str 换成screen 12sscanf(str,\"%d\",&amp;n);//把字符数组str中的内容以%d的格式写入nsprintf(str,\"%d\",n);//把n以%d的格式写到str字符数组中 1234567char str[100]=\"2048:3.14,hello\";sscanf (str,\"%d:%lf,%s\",&amp;n,&amp;db,&amp;str2) ;//从左边读到右边int n=32;double db = 3.1415;char str[100],str2[100]=\"good\";sprintf(str,\"%d:%.2f,str\",n,db,str2); //从右边读到左边 sscanf 还支持 正则表达式（匹配） 函数 123返回类型 函数名称(参数类型 参数){ 函数主体} 注意全局变量和局部变量，形参和实参 以数组作为函数参数时，对数组元素的修改就是对原数组的修改（与普通的局部变量不同） 但不可以返回数组 函数的嵌套调用，例如max三个数可以用到max两个数 函数的递归调用，自己调用自己，例如算n的阶乘 指针 ❗ 不要给任何没有初始化的指针的赋值！ ❗ 应该在给p赋值前要给p分配一个空间 123int *p1,*p2;double *p；char *p; 1234int a,b;int *p = &amp;a,*p2;p2 = &amp;b; //取地址*p = 233; //取址 int *是指针变量的类型，p才是变量名 因此地址&amp;a是赋给p而不是*p 指针变量支持自增自减操作 a=&amp;a[0] a+i = &amp;a[i+1] 两个int型指针相加减，等价于之间相差了几个int 指针变量作为函数参数，只有在获取地址的情况下才能真正修改变量 1234//?? scanf能赋值给字符数组，不能赋值给指针的问题//scanf读入字符串一定要事先为它申请足够的空间#include &lt;stdlib.h&gt;char *str = (char*)malloc(15*sizeof(char)); 引用 c++语法，产生变量的别名 &amp;加在，会对原变量进行修改 就是说x是对原来a取的一个别名，改变x就是改变a，当然这里的x用a也可以 1234void change(int &amp;x){ ...}change(a); 结构体的使用 结构体的定义 123struct Name{ //一些基本的数据结构或者自定义的数据类型} 结构体能定义除了自己本身的任何数据类型 不能定义自身，但可以定义自身类型的指针变量 1234struct node{ node n; //不能定义node型变量 node* next; //可以定义node*型指针变量} 访问结构体内的元素 1234567struct studentInfo{ int id; char name[20]; studentInfo* next;}stu,*p;//访问变量：stu.id stu.name stu.next//访问指针变量p中的元素：(*p).id p-&gt;id p-&gt;name p-&gt;next 结构体的初始化 构造函数：用以初始化 结构体内有默认构造函数，函数名和结构体名相同 只要参数个数和类型不完全相同，就可以定义任意多个构造函数，适应不同场合 好处：在结构体元素交多时显得代码精炼，不需要临时变量就可以初始化一个结构体 123456789101112131415161718struct studentInfo{ int id; chat gender; //用以不初始化就定义结构体变量 studentInfo(){} //只初始化gender studentInfo(char _gender){ gender = _gender } //同时初始化id和gender studentInfo(int _id,char _gender){ id = _id; gender = _gender; }//可以简化为 studentInfo(int _id,char _gender):id(_id),gender(_gender){}}stu[10];//初始化的时候就可以直接使用构造函数stu[i]=studentInfo(2019,0);//类似这样子 补充 cin 与 cout 添加头文件 #include 和 using namespace std;才能使用 不需要指定输入输出格式，不需要取地址符&amp; 12345678cin &gt;&gt; n; //输入一个整数ncin &gt;&gt; db; //double型浮点数cin &gt;&gt; c;//char型数组cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str; //同时读入多个变量char str[100];cin.getline(str,100); //读入一整行到char型数组str[]中string str;getline(cin,str); //string容器输入 12cout &lt;&lt; n &lt;&lt; \" \"&lt;&lt; db &lt;&lt; \" \" &lt;&lt; c &lt;&lt; str; //输出时不会加空格cout &lt;&lt; n &lt;&lt; \"haha\" &lt;&lt; \"\\n\" &lt;&lt; db &lt;&lt; endl; //endl也会换行 123//控制double的型的精度#include &lt;iomanip&gt;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; 1.2345 只有在十分必要的时才使用cin和cout，例如 string 浮点数的比较 浮点数在经过运算后可能会变成3.14000001，3.1399999，就不会判为== 引入极小数eps来对误差进行修正 成立返回true，想要使用不等于!Equ(a,b),可直接对浮点数进行比较 加括号防止宏定义可能带来的错误 1234567const double eps = 1e-8;const double pi = acos(-1.0)#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps)) //等于运算符==#define More(a,b) (((a)-(b))&gt;(eps)) //大于运算符&gt;#define Less(a,b) (((a)-(b))&lt;(-eps)) //小于运算符&lt;#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) //大于等于运算符&gt;=#define LessEqu(a,b) (((a)-(b))&lt;(eps)) //小于等于运算符&lt;= 类似的还有开根号,asin,acos，需要eps保证变量在定义域内的问题 0.00还会变成-0.00，则要与-0.00进行比较，若比对成功则加上eps来修正 复杂度 时间复杂度O(n)，基本运算次数 一般的OJ系统，一秒能承受的运算次数10710^7107 ~ 10810^8108 空间复杂度，消耗的数据空间 空间一般够用，常常以空间换时间 编码复杂度，定性的概念 黑盒测试 单点测试 判断每组数据是否正确 多点测试 一次性运行所有数据 while… EOF型，默认读到文件末尾，EOF=-1状态 无法读取时，scanf会返回-1（关于scanf的返回值，还需要多测试） 手动触发EOF：&lt;Ctrl+Z&gt; ^z 再按回车就可结束 123while(scanf(\"%d\",&amp;n) != EOF){ ...} while…break型 1234567while(scanf(\"%d%d\"),&amp;a,&amp;b != EOF){ if(a==0 &amp;&amp; b==0) break; ...}while(scanf(\"%d%d\",&amp;a，&amp;b),a||b){ //简洁版，ab有一个不为0就循环 ...} while(T–)型，给出测试数据的组数 12345678//三种输出类型1.正常输出2.每组数据输出出后额外加一个空格3.最后一组数据后面没有空行while(T--){ ... if(T &gt; 0) printf(\"\\n\");} 注意每次循环都要重置变量和数组 重置数组一般使用memset函数或fill函数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"算法笔记","slug":"算法笔记","permalink":"http://pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Crash Course Computer Science（part 2）","slug":"Crash Course Computer science 2","date":"2020-02-02T05:17:44.000Z","updated":"2020-02-12T07:37:58.951Z","comments":true,"path":"2020/02/02/Crash Course Computer science 2/","link":"","permalink":"http://pluto-wei.github.io/2020/02/02/Crash%20Course%20Computer%20science%202/","excerpt":"人机交互 计算机网络","text":"人机交互 计算机网络 人机交互 命令行 历史 机械输入，齿轮 旋钮 开关 等机械结构 ，一大堆机械面板和线， –&gt;打孔纸卡和磁带，输入依然是打印纸ang实时指示灯 –&gt;键盘 打字机 –&gt;电传打字机：可用电话线发送和接收文本（蒸汽朋克版聊天室） –&gt;电传交互（来回对话）–命令行界面 cmd –&gt;屏幕代替电传打字机：虚拟电传打印机/玻璃电传打印机 --叫做终端 terminal –&gt; 文字游戏，互动式小说–&gt; MUD 多人地牢游戏（MMORPG的前辈–大型多人在线角色扮演） 命令行指令 ls (list) 列出当前目录里的所有文件 cat (concatenate 连接)（unix）显示文件内容 finger 找朋友 屏幕 and 2D图形显示 早期屏幕的用途：跟踪程序的运行情况，结果打印在纸上，或是保存更永久的地方 （屏幕更新快，对临时值简直完美） 阴极射线管CRT：把电子发射到有磷光体图层的屏幕上，路径由磁场控制 1.矢量扫描，用电子束描述出形状 2.光栅扫描，一行行，从上自下，从左往右，只在特定地方打开电子束 早期不存像素（占用内存过多），存符号 字符生成器–第一代显卡 只读存储器 ROM，存每个字符的图形（点阵图案） 访问内存中的屏幕缓冲区（专为图形保留） 用字符模仿图形界面：_ + 画盒子和线 字符集： 用额外的bit定义字体颜色和背景颜色 用CRT上的矢量模式，所有的东西都用线组成 （海龟作图）–&gt;动画 位图显示–内存中的位对应屏幕上的像素 Sketchpad （几何画板）一个交互式图形界面–计算机辅助设计 CAD 输入设备–光笔 图形界面 直接显示了你可以做什么，直接在屏幕上找选项即可，\"选择并点击界面” 图形用户界面–GUI 鼠标–用户和屏幕上的信息互动（光标） 桌面–模拟实际桌面，有窗口，时钟等小组件 用户触发事件–如点击按钮，选一个菜单项，滚动窗口–有对应的执行函数 3D图形 有图型算法负责把3D坐标拍平显示到2D屏幕上–3D投影 线框渲染：正交投影，透视投影 扫描线渲染（填充图形）：抗锯齿 遮挡：排序算法，画家算法–由远到近 深度缓冲 明暗处理：平面着色–最基本的照明算法，高洛德着色，冯氏着色 纹理：纹理映射 加速渲染： 并行渲染 GPU–图形处理单元（在显卡上，周围有专用的RAM） 计算机网络 👉开放式系统互联通信参考模型 OSI 物理层：线路里的电信号，无线网络里的无线信号 数据链路层：负责管理物理层 有媒体访问控制地址MAC，冲突检测，指数退避和其他的一些底层协议 网络层：负责各种报文交换和路由 IP 传输层：UDP TCP这些协议，负责在计算机之间进行点到点的传输，检修和修复错误 会话层：使用UDO TCP创建连接，传递信息，然后关掉连接 表示层和应用程序层：浏览器，HTML解码，在线看电影 详情：&lt;https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B&gt; OSI.png 互联网 早期 需要分享数据和资源–&gt;公司或研究室内部使用 球鞋网络，共享物理资源–大家共享一台联网的打印机 早期网络也共享存储空间，不是每台电脑都有存储器 局域网 计算机近距离构成的小型网络LAN 最著名最成功的：以太网 载波侦听多路访问 CSMA（属于链路层②） 使用共享载体 以一台以太电线连接所有计算机，以电信号的形式将数据传入电缆 每台机器需要有唯一的媒体访问控制地址（MAC地址） 数据的接受方的地址放在数据的头部，作为数据的前缀发送到网络中 计算机看到自己的MAC才处理数据 这种 多台电脑共享一个传输媒介 的方法 叫–CSMA 载波侦听多路访问 含义：载体，运输数据的共享媒体，以太网的载体是铜线，wifi的载体是传播无线电波的空气。很多计算机同时侦听载体，侦听，多路。 带宽：载体传播数据的速度 冲突（属于链路层②） 多个计算机想同时传入数据时就会冲突。 如果冲突，会等一小段随机时间，指数退避–指数级增长等待时间（以太网） 载体和其中的设备–冲突域 可以用交换机把其分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络间传数据（属于链路层） 大的计算机网络也是如此，包括最大的网络–互联网，也是多个连在一起的小一点的网络，是不同网络之间可以传递信息 路由（属于网络层③） 路由—通过互联的网络把信息从源地址传输到目的地址的活动 专用的通信线路（电路交换，电话占线）—&gt;报文交换（如同邮件系统，有几个站点）（分布式网络） 报文交换的好处：可以用不同路由使通信更可靠更能容错 消息沿路由跳转的次数，跳数限制–解决路由问题 协议（属于传输层④） 报文交换的缺点是某个文件太大堵塞网络 解决方法：把大报文分成很多小块–数据包–分组交换 报文具体格式由互联网协议定义–IP（网络层？） **IP是一个非常底层的协议 Internet Protocol** IP之上还有其他协议：用户数据报协议 UDP IP负责把数据包送到正确的电脑IP header **UDP负责把数据包送到正确的程序 （UDP中的端口port）** UDP头部还有校验和–checksum，但不提供数据修复和数据重发，并无法得知数据包是否到达（应用于直播，视频通话，对时间要求很高：射击游戏，“丢包”） UDP.png **传输控制协议 TCP（所有数据必须到达）：** TCP头部也有端口号和校验和 TCP IP.png 👇 这个组合被称为TCP/IP TCP数据包有序号，使得接收方可以把数据包正确排序 接收方校验无误后会给发送方发送一个确认码ACK 能删掉重复数据包 可以同时发多个数据包，接收多个确认码 可以调整同时发包数量，解决拥堵问题（确认码的成功率和来回时间可以推断网络的拥堵程度） 缺点：确认码数据包把数量翻了一倍但并没有传播更多的信息 TCP.png 每台联网的计算机都需要一个IP地址，以点分隔的四组数据172.217.7.238 阻塞控制–路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠 当计算机访问一个网站时，需要两个东西：IP地址，端口号 互联网负责把域名和IP地址一一对应，就像电话簿–域名系统 DNS DNS服务器由互联网供应商ISP提供 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求**（会话层④）** 为了更好的管理上亿个域名，DNS存成树状结构（有3千万个二级域名） 顶级域名，二级域名，子域名 DNS.png 这些数据散布在很多DNS服务器上 WIFI 路由器连接的所有设备组成了局域网LAN，局域网再连接到广域网WAN，广域网的路由器属于你的互联网提供商ISP 广域网先连接到一个区域性路由器（覆盖一个街区），然后连接到一个更大的WAN（覆盖整个城市），最终到达互联网主干（由一群超大型，带宽超高路由器组成） 网.jpg 万维网 world wide web 互联网是传递数据的管道，传播最多数据的程序是万维网 万维网的基本单位是页面 页面有内容，有去往其他页面的链接–超链接，这些超链接形成巨大的互联网络 文字超链接–超文本（关联式索引） 为了使网页相互连接，每个网页需要一个唯一的地址–统一资源定位器 URL 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求，连接到这个IP，这个地址运行着“网络服务器”，网络服务器的标准端口是80端口，下一步是向服务器请求更进一步的页面（这里会用超文本传输协议HTTP：例如GET，还有状态码），例如向服务器发送指令“GET/courses”，服务器收到后会返回该地址对应的网页，然后浏览器会渲染到屏幕上。 👇超文本标记语言 HTML HTML.png 网页浏览器可以和网页服务器沟通 浏览器获取网页和媒体，并负责显示 人工编辑目录–&gt;搜索引擎–&gt;搜索算法 网络中立性：所有的数据包平等，优先级相同 计算机安全 Secrety,Integrity,Availability 保密性，完整性，可用性 威胁模型分析：以能力水平区分 💡身份认证： 你知道什么：用户名/密码–复杂组合（暴力攻击） 你有什么：用户有特定物品，如钥匙🔑和锁🔒 你是谁：生物识别–但有概率性，不能重设 建议“双因素”，“多因素”认证 💡访问控制：通过权限或访问控制列表ACL来实现 权限有：Read，Write，Execute 有很多种访问控制模型，例如：Chinese wall model，Biba model 例如美国的模型： 不能“读上”，读更高等级的内容 不能“写下”，改更低等级的文件（确保顶级机密不外泄） 其他措施：安全大会，安全行业的来审计代码,安全型代码一般开源 黑客与攻击 社会工程学：欺骗别人让别人泄露信息 配置别人的系统 网络钓鱼：邮件发送连接 假托：（电信诈骗） 邮件里带木马：恶意软件伪装成照片等 NAND镜像：暴力攻击被罚时时，增加几根线复制内存，罚时时覆盖内存继续尝试 漏洞利用：远程攻击需要攻击者利用系统漏洞来获得某些能力或访问权限 例如：缓冲区溢出：溢出部分改掉重要值，例如修改权限admin（应对方法：边界检查，随机存放变量在内存中的位置，金丝雀：缓冲区后面跟踪变化） 代码注入：攻击用数据库的网站 结构化查询语言SQL，一种流行的数据库API DROP TABLE users，删掉用户这张表。凉凉 应对：检测特殊字符… 蠕虫：恶意程序在电脑间互相传播，这些电脑组成僵尸网络 DDoS：僵尸网络里的所有电脑发一大堆垃圾信息，堵塞网络 密码学 明文和密文的转化叫加密和解密 对称加密 （密钥一样） 双方都知道密钥： 替换加密（字母出现的频率相同，例如凯撒加密）和移位加密（列移位加密） 加密机器：英格玛（转子，一种映射，映射随着每次按键而改变） 硬件加密-&gt;软件加密 数据加密标准DES，二进制密钥，56bits，暴力破解 高级加密标准AES，更长的密钥，128,192,256bits 密钥交换： 不发送密钥，“单向函数-模幂运算”，如同颜色混合，自己算出密钥 非对称加密 有两个不同的密钥：一个公开一个私有 知道公钥只能加密不能解密，公钥加密后只能用私钥解密 私钥加密也可以用公钥解密，只有有私钥的人能加密，防伪造 非对称加密RSA，公钥密码学 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"http://pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Crash Course Computer Science（part 1）","slug":"Crash-Course-Computer-science-笔记 1","date":"2020-01-31T03:53:23.000Z","updated":"2020-02-12T07:38:20.448Z","comments":true,"path":"2020/01/31/Crash-Course-Computer-science-笔记 1/","link":"","permalink":"http://pluto-wei.github.io/2020/01/31/Crash-Course-Computer-science-%E7%AC%94%E8%AE%B0%201/","excerpt":"硬件Hardware 软件Software","text":"硬件Hardware 软件Software 硬件Hardware 继电器，真空管，晶体管 二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门） 算术存储单元ALU（算术单元和逻辑单元） 集成电路（都是晶体管组成的） 锁存器 （存储一个位）0 1 寄存器 （一组锁存器） 8位寄存器 16 32 64 写入寄存器前要先启用里面所有的锁存器（允许写入线） 存大量寄存器：矩阵排列 例如16×16网格的锁存器 通过行列的某根线还可以确定到某个确定的锁存器来启动 emm.png 允许写入线，允许读取线，数据线 连接所有的锁存器 多路复用器.png again 把256位内存作为一个整体 （通过8位地址能储存256个数据？错，每一个位置上是一个0或者1，整体表示一个数据，有256个二进制数（也不是256种可能性，而是22562^{256}2256）） 8位就是一个字节（这里都是单位，八位的字节包含8个二进制数） 一个字节有22562^{256}2256种0和1的可能性 把8个256位内存排一排 存储8个数，给他们相同的地址 于是一个8位的地址可以存取一个8位数， （这里好奇怪 无法理解：） 又把这个256位内存叫一位（可能是一位数字的意思？），把8个这样的内存排一排叫1字节？ 为了存储这样的一个8位数，我们同时给8个256位内存一样的地址（如图） 嗷，懂了，这样就能存储一个8位数了！地址是8位 Think about it :一位数相当于有256种可能性，$2{2568}=2{2{64}} $ 整体的可寻址内存 RAM–随机存取存储器 8位的地址 256个地址 每个地址可以读或写一个8位值（8 bits=282^828种） RAM.png 前四位是操作码（OPCODE：LOAD ADD） 后四位是内存地址（if is LOAD） CPU–中央处理器（指令和程序） 中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元 组成 ALU 控制单元 RAM 时钟 CPU.png 取址–&gt;解码–&gt;执行 可操作的指令有 LOAD ADD SUB JUMP HALT 英特尔集成4004，第一个集成CPU 有46条指令 现代CPU有上千个指令和指令变种，有各种巧妙复杂的电路 一秒十亿条指令 高级CPU设计 缓存 在RAM中取一整块存在CPU内部，方便数据的存取。 CPU与RAM中间只有一根数据线，效率较低 当数据有改变时，通过检测脏位，将数据同步给RAM 提高效率 并行处理，同时用上CPU中的取址，解码，执行 高端处理器 会猜测JUMP的下一步，进行推测执行 超标量处理器 一个时间周期完成多条指令 优化**一个指令流**的吞吐量 一个CPU中有多个ALU CPU2.png 多核处理器 同时运行多个指令流 一个CPU芯片中，有多个独立处理单元 CPU3 2个/4个CPU 多核不够时可以用多个CPU 超级计算机 神威太湖之光有40960个CPU，每个CPU有256个核心，每个核心的频率是1.56GHz，每秒钟可以进行9.3亿亿次浮点运算 集成电路 锗-&gt;硅 早期 IC 几个晶体管：把简单电路（逻辑门）封装成单独组件 印刷电路板PCB：通过蚀刻金属线把零件连接在一起 光刻：用光把复杂图案印在材料上，如半导体 用晶圆做基础，把复杂的金属电路放在上面集成所有东西–氧化层–光 刻胶–光掩膜，金属化 光刻还可以制作电阻 电容 一片晶圆可以做很多 IC，整块做完后切割包进微型芯片 芯片的核心是 IC 摩尔定律：每两年左右，材料和制造技术的发展，同样的空间大小，能塞进两倍数量的晶体管 超大规模集成 VLSI 软件：用来自动生成芯片设计 软件Software 早期编程方式 程序怎么进入内存？？ 一.纸卡 最早的编程雅卡尔织布机 早期汇总机–不算计算机，只汇总数据（穿孔纸卡），不能编程 二.插线板 Control panel 控制面板–插线板–&gt;可拔插 有很多小插孔，可以插电线，让机器的不同部分可以相互传数据和信号 世界上第一台通用电子计算机ENIAC–用插线板编程 存取程序计算机 程序和数据都存在–冯诺伊曼结构 一个处理器（有算术逻辑单元），数据寄存器，指令寄存器，指令，内存（负责存数据和指令） 三.面板编程 大量使用开关 编程语言(Software) 二进制是处理器的母语（机器语言，机器码） 对程序的高层次描述–伪代码 汇编器 读取汇编语言的写的程序。然后转成机器码 自己搞定跳转地址（插入可跳转标签） 一般一条机器指令对应一条机器指令 编译器 专门把高级语言转成低级语言(汇编或机器码) 一行高级编程语言，可能转成几十条二进制指令 程序员只需要创建变量–代表内存地址的抽象 解释器 运行时进行转换，而编译器是运行前转换 编程基础（语句和函数） 语法–规定句子结构的一系列规则 赋值语句，if语句，循环语句，把代码打包成函数（子程序） 算法–解决问题的具体步骤 排序：选择排序n2n^2n2，归并排序nlognnlognnlogn 图搜索（找最佳路线）：Dijkstra算法 算法的复杂度–算法的输入大小和运行步骤 数据结构 数组（列表，也叫向量） 字符串（数组的亲戚）：字母 数字 标点符号 矩阵（二维数组，数组的数组） 结构体（多个变量打包，多个不同类型数据放在一起） 链表（一个灵活的数据结构，能存很多个节点）：容易重新排序，插入，两端缩减，倒序 很多复杂的数据结构也用链表：队列和栈 队列：先进先出 栈：后进先出 树（把一个节点的指针变成多个指针）：根节点，子节点，母/父节点（直属上层节点），叶节点（树结束的地方） 二叉树：节点最多只有两个子节点 甚至节点可以用链表来存储你所有的子节点 树的特点：根到叶是单向的 图：数据随意连接，包括循环。用有多个节点的指针表示，可随意指向 红黑树和堆？ 计算机科学之父–图灵 图灵机：规则，状态和纸带 停机问题 无法解决 提出智能，图灵测试（验证码） 软件工程 把函数打包成层级，把相关代码都放在一起，打包成对象 对象.png 对象可以包含其他对象，函数 和变量 对象2.png 把函数打包成对象的思想叫面向对象编程 Object Oriented Programming 文档 （帮助理解代码都做了什么）以及定义好的程序编程接口API API 控制哪些函数和数据让外部访问，哪些仅供内部 面向对象的编程语言可以指定函数是private/public，隐藏复杂度，选择性的公布 集成开发环境 IDE debug 调试 写文档 README 源代码管理（版本控制） 把代码放在一个中心服务器上，叫做代码仓库 Code repository check out，commit（提交） master（代码的总版本） 质量保证测试 QA β版本软件（快完成时向公众发布）免费的QA团队 alpha版本（只在公司内部测试） 操作系统OS 操作硬件的特殊权限，可以运行和管理其他程序 （1950年代） 操作系统充当硬件和软件之间的媒介 操作系统提供API来抽象硬件，叫设备驱动程序 批处理（连续进行多个程序，自动加载程序）–&gt;在单个CPU上同时运行几个程序–&gt;多任务处理（给每个程序分配专属内存块，内存地址的虚拟化，内存保护）–&gt;分时操作系统（处理多个用户） Multics（功能太多）–&gt;Unix（把操作系统分为两个部分：内核（内存管理，多任务输入输出处理）和一堆有用的工具（例如程序和运行库），功能并不是很全面，内存崩溃时“恐慌”）–&gt;Windows（早期经常蓝屏）–&gt;Mac OS X,Linux,iOS,Android 多任务，虚拟内存，内存保护 内存&amp;储存介质 存储介质 打孔纸卡，打孔纸带–&gt;延迟线存储器（扬声器压力波/金属线的震动，顺序存储器/循环存储器）–&gt;磁芯存储器（可访问某一特定位置）–&gt;磁带–&gt;磁鼓储存器–&gt;硬盘（机械硬盘，固态硬盘SSD）–&gt;软盘–&gt;密度更高的软盘（Zip Disks）–&gt;光学存储器（光盘CD，DVD）光盘表面有很多小坑，造成光的不同反射，光学传感器捕获并解码为1和0 文件与文件系统 文件格式： TXT（文本）WAVE（音频，振幅） Bitmap.bmp（图片，像素块：红绿蓝） 元数据（类型，图片宽度，图片高度，深度）+Date 怎么储存文件 为了存多个文件，需要一个特殊文件记录文件的位置（文件目录，通常在最开头） 文件目录.png 文件系统专门负责管理文件 平面文件系统： （文件都在同一个目录里） 分配块–增大或减小 碎片处理–把数据来回移动，排列成正确的数据 分层文件系统 目录文件不仅要指向文件，还要指向目录 根目录.png 压缩 Compression 把数据占用的空间压到更小 作用：高效储存图片，音乐，视频 无损压缩 消除冗余 游程编码适合经常出现相同值的文件 用更紧凑的表示方法 字典编码 GIF,PNG,PDF,ZIP 有损压缩 感知编码 用不同的精度编码不同的频段 例如声音，超声波/低音 FLAC / WAV --&gt; MP3 有损压缩文件格式 JPEG 视频，每一帧，时间冗余，只存变化的部分，补丁的移动和转换 MPEG-4 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[{"name":"计算机科学速成课","slug":"计算机科学速成课","permalink":"http://pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-17T16:28:39.391Z","updated":"2020-02-01T17:00:58.231Z","comments":true,"path":"2019/11/18/hello-world/","link":"","permalink":"http://pluto-wei.github.io/2019/11/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}