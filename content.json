{"meta":{"title":"Pluto-wei","subtitle":"Hello,nice to meet you!","description":"你好\\(@^0^@)/","author":"Pluto-wei","url":"http://Pluto-wei.github.io","root":"/blog/"},"pages":[],"posts":[{"title":"关于全排序的一些理解","slug":"关于全排序的一些碎碎念","date":"2020-02-09T14:29:04.000Z","updated":"2020-02-09T14:39:31.340Z","comments":true,"path":"2020/02/09/关于全排序的一些碎碎念/","link":"","permalink":"http://pluto-wei.github.io/2020/02/09/%E5%85%B3%E4%BA%8E%E5%85%A8%E6%8E%92%E5%BA%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E7%A2%8E%E7%A2%8E%E5%BF%B5/","excerpt":"这个递归真的想了好久 就是觉得别扭，想bb几句🤐","text":"这个递归真的想了好久 就是觉得别扭，想bb几句🤐 来理解一下全排序(递归) 123456789101112131415161718192021//输出1~n的全排列#include &lt;cstdio&gt;const int maxn =11;int n,P[maxn],hashTable[maxn]={false};void generateP(int index){ if(index == n+1){ //递归边界 for(int i=1;i&lt;=n;i++){ printf(\"%d\",P[i]); }printf(\"\\n\"); return; } for(int x=1;x&lt;=n;x++){ if(hashTable[x]==false){ P[index]=x; hashTable[x]=true; generateP(index+1); //递归在这里！！！ hashTable[x]=false; } }}generateP(1);//从1开始的全排序 要写从1~3的全排序： 一共三位 第一位从1开始循环，每一轮回就是引用一次剩下2个数的全排列 每用一个数，就用hashTable标记该数已经使用，然后开始下一位的全排列，并在排列完并输出以后，恢复这个数没有使用的状态，并且这个数没到最大值的话，这一位上的这个数就要加一了，否则就会退出。（该前面的数恢复了） n个数排完后会执行generateP(n+1)，就会输出这n个数，然后返回继续后面的步骤，继续排列 比如generateP(2)，就是从第二位开始的全排列，不会给前面赋值，第一位每个数都会调用一次generateP(2)，当然前面用过的数会不再使用 直到最后一个数的全排序，就等于剩下的那个数 但是递归边界又不能写只剩最后一个数， 123456789101112131415161718192021222324#include &lt;cstdio&gt;int n,m,P[100];//n是总数，m是当前填的数，x是位数bool hT[100]={false};void g (int x){ if(x==n){ for(int i=1;i&lt;=n;i++){ if(hT[x]==false){ P[x]=i; } } for(int i=1;i&lt;=n;i++){ printf(\"%d\",P[i]); }printf(\"\\n\"); return; }for(int m=1;m&lt;n;m++){ if(hT[m]==false){ P[x]=m; hT[m]=true; g(x+1); hT[m]=false; } }} 为什么这样是不行的，因为g(n)运行完后跳到上一位变成false，m+1以后到了n没有循环了 也就是倒数第二位不会变成最大的数，就以为自己的全排列已经结束了 也就是最大的数永远不会出现在前面 所以递归边界不能写n，必须是n+1 1234567891011121314int main (){ n=4; g(1);}输出：123413242134231431243214n=3 时输出：123213 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"一些做题时遇到的问题","slug":"一些做题时遇到的问题","date":"2020-02-08T13:00:14.000Z","updated":"2020-02-09T14:30:53.366Z","comments":true,"path":"2020/02/08/一些做题时遇到的问题/","link":"","permalink":"http://pluto-wei.github.io/2020/02/08/%E4%B8%80%E4%BA%9B%E5%81%9A%E9%A2%98%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"有些问题发现之后就直接补充到笔记了 还有一些不直到归到哪里的问题👇 就直接写吧 结构和函数要事先声明（定义），在使用之前！或者写成 .h，否则报错 有时候数据只能读取一部分，不能继续读取并且终止了程序，很可能是循环条件写错了。逻辑问题而不是语法问题，debug啊！！ 13位的整数，写long long给我扣了几分，答案是char id[15]，不是很明白。改的时候别忘了比大小要改成strcmp document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"关于指针的初始化问题","slug":"关于指针的初始化问题","date":"2020-02-08T06:07:36.000Z","updated":"2020-02-09T14:33:33.174Z","comments":true,"path":"2020/02/08/关于指针的初始化问题/","link":"","permalink":"http://pluto-wei.github.io/2020/02/08/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/","excerpt":"不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 重要的事情说亿遍！！！！","text":"不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 不要给任何没有初始化的指针赋值！ 重要的事情说亿遍！！！！ 老是忘掉！！！ 💡应该在给 *p赋值前要给 *p分配一个空间 💡scanf读入字符串一定要事先为它申请足够的空间 字符串 12#include &lt;stdlib.h&gt;char *str = (char*)malloc(20*sizeof(char)); 结构体指针 123456789101112#include&lt;stdio.h&gt;int main(){ struct studentInfo{ int id; char name[20]; char gender; studentInfo* next; }*p; scanf(\"%d %c\", &amp;p-&gt;id, &amp;p-&gt;gender); printf(\"%d %c\", p-&gt;id, p-&gt;gender); return 0;}//这样是无法输出的，因为对结构体指针没有进行初始化操作 12345678910111213#include&lt;stdio.h&gt;int main(){ struct studentInfo{ int id; char name[20]; char gender; studentInfo* next; }stu, *p; p = &amp;stu; scanf(\"%d %c\", &amp;p-&gt;id, &amp;p-&gt;gender); printf(\"%d %c\", p-&gt;id, p-&gt;gender); return 0;}//这样才可以！ 12345678//结构体数组指针也是一样struct student{ int id; char name;}stu[100],*p;p = stu;scanf(\"%d %s\",&amp;(p+i)-&gt;id,(p+i)-&gt;name);printf(\"%d %s\",(p+i)-&gt;id,(p+i)-&gt;name); 而那个结构体的构造函数，是用于给结构体赋值方便的一个函数，那个初始化跟这个初始化不一样 💡 其实不过就是你在给指针指向的地方赋值的时候，总得知道他指向哪里吧 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"碎碎念","slug":"碎碎念","permalink":"http://pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"}]},{"title":"Crash Course Computer Science（part 3）","slug":"Crash Course Computer science 3","date":"2020-02-06T05:19:55.000Z","updated":"2020-02-06T13:37:27.839Z","comments":true,"path":"2020/02/06/Crash Course Computer science 3/","link":"","permalink":"http://pluto-wei.github.io/2020/02/06/Crash%20Course%20Computer%20science%203/","excerpt":"本部分内容：计算机的现状和未来 完结撒花！！！！","text":"本部分内容：计算机的现状和未来 完结撒花！！！！ 今天是2020/02/06 Crash Course Computer science 计算机科学速成课 终于看完啦！！ 根据浏览器判断是2020/01/23开始的😏 除去没看的几天，一共看了13天😬还不错啦！ 强推！真的很棒！感谢款待！！ 小姐姐在此！超可爱哦！！ xjj 计算机的现状和未来 机器学习ML＆人工智能AI 机器学习算法可以让计算机从数据中学习，然后自行做出预测和决定 机器学习是为了实现人工智能这个更宏大的目标的技术之一 分类：用算法减小复杂性，把数据简化成特征，特征帮助分类 机器学习算法的目的是最大化正确分类&amp;最小化错误分类，找到最好的决策边界 源于统计学的技术：决策树，森林，支持向量机 人工神经网络，来源于大脑里的神经元。输入层，隐藏层，输出层。 算法调整偏差和权重来训练神经网络，用标记数据训练和测试，提高准确性。有激活函数，线性传递函数 加权，求和，偏置，激活函数应用于一层里的每一个神经元，并向前传播 弱人工智能：只能做特定任务，分类，找人脸，翻译，自动驾驶 强人工智能：真正通用，像人一样聪明 强化学习：学习什么管用，什么不管用 计算机视觉 颜色跟踪算法，一块块像素处理 核/过滤器，把核引用于像素块叫做卷积 核能做很多图像转换，例如锐化图像，模糊图像；可以匹配特定形状，例如边缘检测；可以描述简单的形状，例如找线段圆圈（眼睛鼻子） 多个核组合在一起，找到特征组合 卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像，本质上是被不同的核处理了，逐层深入，卷积，由小的特征组合成大的特征，直到一层把所有的特征集合到一起 生物识别 标志点 情感识别算法 自然语言处理 Natural Language Processing 把句子切成一块块，词性，短语结构规则，把语言结构化 用规则做出分析树 聊天机器人的最基本部件：处理，分析，生成文字。应用于客服 指定简单协议用于沟通–&gt;机器学习，从语言数据库中学习，深度学习网络 语音识别，波形转化成频率（快速傅里叶变换） 构成声音的不同片段：音素 语音合成 机器人 自动运行的机器，大规模生产，高效不知疲惫 可编程工业机器人，简单控制回路，负反馈回路 PID–有控制回路和反馈机制 “比例-积分-微分控制器” 机器人三定律 计算机心理学 社会心理学，认知心理学，行为心理学，感知心理学 易用读：人造物体达到目的的效率有多高 UI设计：视觉，认知系统 ，直观性 视频可以增强凝视 人机交互HRI 几乎像人类和真的人类之间的小曲线–恐怖谷 教育科技 智能辅导系统 判断规则+选择算法–域模型 贝叶斯知识追踪 自适应式程序 教育数据挖掘 虚拟现实和增强现实 奇点，天网，未来 奇点：智能科技的失控性发展 复杂度刹车：S性曲线，而非J型 手工型工作，思维型工作；重复性工作，非重复性工作 加密货币，无线通讯，3D打印，生物信息学，量子计算… 推荐： 哲学速成课，人工智能速成课， 西部世界 钻石时代 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"C语言 快速入门！！","slug":"C语言-快速入门！！","date":"2020-02-05T04:25:10.000Z","updated":"2020-02-05T04:37:05.497Z","comments":true,"path":"2020/02/05/C语言-快速入门！！/","link":"","permalink":"http://pluto-wei.github.io/2020/02/05/C%E8%AF%AD%E8%A8%80-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%81%EF%BC%81/","excerpt":"233333 我终于快速入门了！！","text":"233333 我终于快速入门了！！ 2月2号开始看的《算法笔记》 今天终于把快速入门看完了== 4天嗷~ 突然想放一张散散~生日快乐 @7.png 下面进入正题~ 基本数据类型 变量类型： 整型：short， int ，long long 绝对值在**10910^9109**范围内（32位）都可以定义为int 101010^{10}1010-101810^{18}1018就得用long long（64位） （若赋大于int最大(231−12^{31}-1231−1)的值，则需要在初值后面加LL，才能编译成功） 浮点型：float，double 精度 float 6-7位，double15-16位 记住：遇到浮点用double 字符型： 标准ASCII范围是0-127，包含控制字符（转义字符\\n\\t\\0）和可显示字符 记住：小写字母比大写字母ASCII码大32， ‘字符’%c “字符串”%s 1234char c1 = 'z',c2 = 'j',c3 = 117;printf(\"%c%c%c\",c1,c2,c3);//字符常量（单个字符）用单引号标注//输出为 zju 布尔值： c语言中要stdbool.h true（非零）false（零） 强制类型转换 （新类型名）变量名 1printf(\"%.f\",(double)a/(double)b); 定义常量 符号常量-宏定义 define是原封不动直接替换，记得加（） 12#define 标识符 常量/任何语句或片段#define pi 3.14 const常量 12const 数据类型 变量名 = 常量；const double pi = 3.14； 运算符 算术运算符 / 取商，向下取整，舍去小数 %取余数 i++先用再加，++i先加再用 关系运算符 &lt; &gt; &lt;= &gt;= == != 逻辑运算符 &amp;&amp;与 ||或 ！非 条件运算符 唯一的三目运算符 1A ? B : C ; //A真则B，A假则C 位运算符 12const int INF = (1 &lt;&lt; 30)-1; //无穷大，上限，const int INF = 0x3fffffff;//避免两个数相加超过int最大值 按二进制进行: 左移&lt;&lt; 右移&gt;&gt; 位于&amp; 位或| 位异或^ 位取反~ 顺序结构 赋值表达式 注意 += -= /= *= %= 的运用 scanf和printf输入输出 1234567scanf(\"格式控制\"，变量地址)；scanf(\"%d\",&amp;n); //intscanf(\"%lld\",&amp;n); //long longscanf(\"%f\",&amp;fl); //floatscanf(\"%lf\",&amp;db); //doublescanf(\"%c\",&amp;c); //charscanf(\"%s\",str); //字符串char*，char str[] 除char数组整个输入 不加&amp;，其他变量类型都要加&amp; 除%c，scanf对其他格式符的输入（%d，%s）是以空白符为结束的 %c是可以读入空格跟换行的 1234567printf(\"格式控制\"，变量名称)；printf(\"%d\",n); //intprintf(\"%lld\",n); //long longprintf(\"%f\",fl); //floatprintf(\"%f\",db); //doubleprintf(\"%c\",c); //charprintf(\"%s\",str); //字符串char*，char str[] 唯一不同：double输出格式%f ，输入%lf 123printf(\"%%\");printf(\"\\\\\");printf(\"\\t \\n\"); 12345printf(\"%md\",a);//%md不足m位的int以m位进行右对齐输出，高位空格补齐printf(\"%-md\",a);//左对齐printf(\"%0md\",a); //高位补0而不是补空格printf(\"%.mf\",a); //保留m位小数printf(\"%n.mf\",a); //保留m位小数,宽度占n位 getchar与putchar输入输出 输入输出单个字符，可以识别存储换行符\\n 123456char c1,c2;c1 = getchar();getchar();c2 = getchar();putchar(c1);putchar(c2); typedef 给复杂的数据类型起别名 12typedef long long LL;LL a = 123456789012345,b = 34567890123456;//直接使用LL 常用math函数 1#include &lt;math.h&gt; 123456789fabs(double x); //对double型变量取绝对值floor(double x);//对double型变量向下取整，得到的值更小，无论正负ceil(double x); //对double型变量向上取整pow(double r,double p); //返回$r^p$sqrt(double x);//返回算术平方根log(double x);//取以e为底对数，任意底数要用换底公式sin(double x),cos(double x),tan(double x);//参数要求弧度制asin(double x),acos(double x),atan(double x);round(double x);//四舍五入到个位，返回类型double 但是这些函数直接以%f输出会都很多零 最好还是要控制位数%.0f %.mf 也可以 %d ，(int)db double x 只是说明这是一个double型变量，并不需要加上double pi精确定义为acos(-1.0) 选择结构 if 语句 1234567if (条件A) { ...} else if (条件B) { ...} else { ...} 技巧：if（n==0） 等价于if（!n），if（n!=0）等价于if（n） if语句的嵌套 switch 语句 用于分支条件比较多的情况 12345678910111213switch(表达式){ case 常量表达式1: ... break; case 常量表达式2: ... break; case 常量表达式n: ... break; default: ...} //break结束当前switch，表达式等于常量表达式n就执行第n条 循环结构 while 语句 123while(条件A){ ...} do while 语句 123do{ ...} while (条件A); for 语句 123for(表达式A;表达式B;表达式C){ ...} //先执行A，再判断B，每个循环后执行C break 和 continue 语句 break直接退出以上三种循环，switch语句 continue临时结束循环的当前轮回，进入下一轮回 数组 注意从a[0]开始 一维数组 12数据类型 数组名 [数组大小] = { , , };数组名称[下标]; //访问 二维数组 1数据类型 数组名 [第一维大小][第二维大小] = { { , , },{ }, }; 如果数组较大（10610^6106级别），需要将其定义在主函数之外 多维数组类似 memset 函数 对数组中的每一个元素赋相同的值 需要头文件string.h 建议只赋0/-1，其他数字（会出错）使用fill函数 因为memset使用的是按字节赋值 1memset(数组名,值,sizeof(数组名)); 字符数组 12char str[15] = \"Good Story!\"; //直接赋值仅限于初始化char str[15] = {'G','o',...}; //记得长度要多一个存\\0 gets和puts 输入输出 scanf 输入 printf 输出（见上文） getchar 输入 putchar 输出 （见上文） 二维数组时 用 getchar ( ) 吸收掉每行末尾的换行符 gets 输入 puts 输出 gets 识别换行符\\n作为输入结束，可以读入空格 puts 输出后会紧跟一个换行 puts 和 printf 通过识别 \\0作为字符串的结尾 如果不是 scanf的%s 或gets输入（例如getchar），要在字符串末尾加\\0 只有char型数组需要\\0，int型数组不需要 string.h 头文件 1234strlen(字符数组);//得到第一个\\0前的字符的个数strcmp(字符数组1,字符数组2);//按字典序比较两个字符串大小strcpy(字符数组1,字符数组2);//把字符数组2复制给字符数组1，包括\\0strcat(字符数组1,字符数组2);//把字符数组2接到字符数组1后面 strcmp： 从前往后比，a小于b，aaaa小于aab， 字符数组1&lt;字符数组2,则返回一个负整数； 字符数组1==字符数组2,则返回0； 字符数组1&gt;字符数组2,则返回一个正整数； sscanf 与 sprintf 第一个s理解为string，均在stdio头文件下 scanf 和 printf 只是把下面的str 换成screen 12sscanf(str,\"%d\",&amp;n);//把字符数组str中的内容以%d的格式写入nsprintf(str,\"%d\",n);//把n以%d的格式写到str字符数组中 1234567char str[100]=\"2048:3.14,hello\";sscanf (str,\"%d:%lf,%s\",&amp;n,&amp;db,&amp;str2) ;//从左边读到右边int n=32;double db = 3.1415;char str[100],str2[100]=\"good\";sprintf(str,\"%d:%.2f,str\",n,db,str2); //从右边读到左边 sscanf 还支持 正则表达式（匹配） 函数 123返回类型 函数名称(参数类型 参数){ 函数主体} 注意全局变量和局部变量，形参和实参 以数组作为函数参数时，对数组元素的修改就是对原数组的修改（与普通的局部变量不同） 但不可以返回数组 函数的嵌套调用，例如max三个数可以用到max两个数 函数的递归调用，自己调用自己，例如算n的阶乘 指针 ❗ 不要给任何没有初始化的指针的赋值！ ❗ 应该在给p赋值前要给p分配一个空间 123int *p1,*p2;double *p；char *p; 1234int a,b;int *p = &amp;a,*p2;p2 = &amp;b; //取地址*p = 233; //取址 int *是指针变量的类型，p才是变量名 因此地址&amp;a是赋给p而不是*p 指针变量支持自增自减操作 a=&amp;a[0] a+i = &amp;a[i+1] 两个int型指针相加减，等价于之间相差了几个int 指针变量作为函数参数，只有在获取地址的情况下才能真正修改变量 1234//?? scanf能赋值给字符数组，不能赋值给指针的问题//scanf读入字符串一定要事先为它申请足够的空间#include &lt;stdlib.h&gt;char *str = (char*)malloc(15*sizeof(char)); 引用 c++语法，产生变量的别名 &amp;加在，会对原变量进行修改 就是说x是对原来a取的一个别名，改变x就是改变a，当然这里的x用a也可以 1234void change(int &amp;x){ ...}change(a); 结构体的使用 结构体的定义 123struct Name{ //一些基本的数据结构或者自定义的数据类型} 结构体能定义除了自己本身的任何数据类型 不能定义自身，但可以定义自身类型的指针变量 1234struct node{ node n; //不能定义node型变量 node* next; //可以定义node*型指针变量} 访问结构体内的元素 1234567struct studentInfo{ int id; char name[20]; studentInfo* next;}stu,*p;//访问变量：stu.id stu.name stu.next//访问指针变量p中的元素：(*p).id p-&gt;id p-&gt;name p-&gt;next 结构体的初始化 构造函数：用以初始化 结构体内有默认构造函数，函数名和结构体名相同 只要参数个数和类型不完全相同，就可以定义任意多个构造函数，适应不同场合 好处：在结构体元素交多时显得代码精炼，不需要临时变量就可以初始化一个结构体 123456789101112131415161718struct studentInfo{ int id; chat gender; //用以不初始化就定义结构体变量 studentInfo(){} //只初始化gender studentInfo(char _gender){ gender = _gender } //同时初始化id和gender studentInfo(int _id,char _gender){ id = _id; gender = _gender; }//可以简化为 studentInfo(int _id,char _gender):id(_id),gender(_gender){}}stu[10];//初始化的时候就可以直接使用构造函数stu[i]=studentInfo(2019,0);//类似这样子 补充 cin 与 cout 添加头文件 #include 和 using namespace std;才能使用 不需要指定输入输出格式，不需要取地址符&amp; 12345678cin &gt;&gt; n; //输入一个整数ncin &gt;&gt; db; //double型浮点数cin &gt;&gt; c;//char型数组cin &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str; //同时读入多个变量char str[100];cin.getline(str,100); //读入一整行到char型数组str[]中string str;getline(cin,str); //string容器输入 12cout &lt;&lt; n &lt;&lt; \" \"&lt;&lt; db &lt;&lt; \" \" &lt;&lt; c &lt;&lt; str; //输出时不会加空格cout &lt;&lt; n &lt;&lt; \"haha\" &lt;&lt; \"\\n\" &lt;&lt; db &lt;&lt; endl; //endl也会换行 123//控制double的型的精度#include &lt;iomanip&gt;cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(2) &lt;&lt; 1.2345 只有在十分必要的时才使用cin和cout，例如 string 浮点数的比较 浮点数在经过运算后可能会变成3.14000001，3.1399999，就不会判为== 引入极小数eps来对误差进行修正 成立返回true，想要使用不等于!Equ(a,b),可直接对浮点数进行比较 加括号防止宏定义可能带来的错误 1234567const double eps = 1e-8;const double pi = acos(-1.0)#define Equ(a,b) ((fabs((a)-(b)))&lt;(eps)) //等于运算符==#define More(a,b) (((a)-(b))&gt;(eps)) //大于运算符&gt;#define Less(a,b) (((a)-(b))&lt;(-eps)) //小于运算符&lt;#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) //大于等于运算符&gt;=#define LessEqu(a,b) (((a)-(b))&lt;(eps)) //小于等于运算符&lt;= 类似的还有开根号,asin,acos，需要eps保证变量在定义域内的问题 0.00还会变成-0.00，则要与-0.00进行比较，若比对成功则加上eps来修正 复杂度 时间复杂度O(n)，基本运算次数 一般的OJ系统，一秒能承受的运算次数10710^7107 ~ 10810^8108 空间复杂度，消耗的数据空间 空间一般够用，常常以空间换时间 编码复杂度，定性的概念 黑盒测试 单点测试 判断每组数据是否正确 多点测试 一次性运行所有数据 while… EOF型，默认读到文件末尾，EOF=-1状态 无法读取时，scanf会返回-1（关于scanf的返回值，还需要多测试） 手动触发EOF：&lt;Ctrl+Z&gt; ^z 再按回车就可结束 123while(scanf(\"%d\",&amp;n) != EOF){ ...} while…break型 1234567while(scanf(\"%d%d\"),&amp;a,&amp;b != EOF){ if(a==0 &amp;&amp; b==0) break; ...}while(scanf(\"%d%d\",&amp;a，&amp;b),a||b){ //简洁版，ab有一个不为0就循环 ...} while(T–)型，给出测试数据的组数 12345678//三种输出类型1.正常输出2.每组数据输出出后额外加一个空格3.最后一组数据后面没有空行while(T--){ ... if(T &gt; 0) printf(\"\\n\");} 注意每次循环都要重置变量和数组 重置数组一般使用memset函数或fill函数 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"C语言","slug":"C语言","permalink":"http://pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"Crash Course Computer Science（part 2）","slug":"Crash Course Computer science 2","date":"2020-02-02T05:17:44.000Z","updated":"2020-02-05T08:02:23.946Z","comments":true,"path":"2020/02/02/Crash Course Computer science 2/","link":"","permalink":"http://pluto-wei.github.io/2020/02/02/Crash%20Course%20Computer%20science%202/","excerpt":"人机交互 计算机网络","text":"人机交互 计算机网络 人机交互 命令行 历史 机械输入，齿轮 旋钮 开关 等机械结构 ，一大堆机械面板和线， –&gt;打孔纸卡和磁带，输入依然是打印纸ang实时指示灯 –&gt;键盘 打字机 –&gt;电传打字机：可用电话线发送和接收文本（蒸汽朋克版聊天室） –&gt;电传交互（来回对话）–命令行界面 cmd –&gt;屏幕代替电传打字机：虚拟电传打印机/玻璃电传打印机 --叫做终端 terminal –&gt; 文字游戏，互动式小说–&gt; MUD 多人地牢游戏（MMORPG的前辈–大型多人在线角色扮演） 命令行指令 ls (list) 列出当前目录里的所有文件 cat (concatenate 连接)（unix）显示文件内容 finger 找朋友 屏幕 and 2D图形显示 早期屏幕的用途：跟踪程序的运行情况，结果打印在纸上，或是保存更永久的地方 （屏幕更新快，对临时值简直完美） 阴极射线管CRT：把电子发射到有磷光体图层的屏幕上，路径由磁场控制 1.矢量扫描，用电子束描述出形状 2.光栅扫描，一行行，从上自下，从左往右，只在特定地方打开电子束 早期不存像素（占用内存过多），存符号 字符生成器–第一代显卡 只读存储器 ROM，存每个字符的图形（点阵图案） 访问内存中的屏幕缓冲区（专为图形保留） 用字符模仿图形界面：_ + 画盒子和线 字符集： 用额外的bit定义字体颜色和背景颜色 用CRT上的矢量模式，所有的东西都用线组成 （海龟作图）–&gt;动画 位图显示–内存中的位对应屏幕上的像素 Sketchpad （几何画板）一个交互式图形界面–计算机辅助设计 CAD 输入设备–光笔 图形界面 直接显示了你可以做什么，直接在屏幕上找选项即可，\"选择并点击界面” 图形用户界面–GUI 鼠标–用户和屏幕上的信息互动（光标） 桌面–模拟实际桌面，有窗口，时钟等小组件 用户触发事件–如点击按钮，选一个菜单项，滚动窗口–有对应的执行函数 3D图形 有图型算法负责把3D坐标拍平显示到2D屏幕上–3D投影 线框渲染：正交投影，透视投影 扫描线渲染（填充图形）：抗锯齿 遮挡：排序算法，画家算法–由远到近 深度缓冲 明暗处理：平面着色–最基本的照明算法，高洛德着色，冯氏着色 纹理：纹理映射 加速渲染： 并行渲染 GPU–图形处理单元（在显卡上，周围有专用的RAM） 计算机网络 👉开放式系统互联通信参考模型 OSI 物理层：线路里的电信号，无线网络里的无线信号 数据链路层：负责管理物理层 有媒体访问控制地址MAC，冲突检测，指数退避和其他的一些底层协议 网络层：负责各种报文交换和路由 IP 传输层：UDP TCP这些协议，负责在计算机之间进行点到点的传输，检修和修复错误 会话层：使用UDO TCP创建连接，传递信息，然后关掉连接 表示层和应用程序层：浏览器，HTML解码，在线看电影 详情：&lt;https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B&gt; OSI.png 互联网 早期 需要分享数据和资源–&gt;公司或研究室内部使用 球鞋网络，共享物理资源–大家共享一台联网的打印机 早期网络也共享存储空间，不是每台电脑都有存储器 局域网 计算机近距离构成的小型网络LAN 最著名最成功的：以太网 载波侦听多路访问 CSMA（属于链路层②） 使用共享载体 以一台以太电线连接所有计算机，以电信号的形式将数据传入电缆 每台机器需要有唯一的媒体访问控制地址（MAC地址） 数据的接受方的地址放在数据的头部，作为数据的前缀发送到网络中 计算机看到自己的MAC才处理数据 这种 多台电脑共享一个传输媒介 的方法 叫–CSMA 载波侦听多路访问 含义：载体，运输数据的共享媒体，以太网的载体是铜线，wifi的载体是传播无线电波的空气。很多计算机同时侦听载体，侦听，多路。 带宽：载体传播数据的速度 冲突（属于链路层②） 多个计算机想同时传入数据时就会冲突。 如果冲突，会等一小段随机时间，指数退避–指数级增长等待时间（以太网） 载体和其中的设备–冲突域 可以用交换机把其分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络间传数据（属于链路层） 大的计算机网络也是如此，包括最大的网络–互联网，也是多个连在一起的小一点的网络，是不同网络之间可以传递信息 路由（属于网络层③） 路由—通过互联的网络把信息从源地址传输到目的地址的活动 专用的通信线路（电路交换，电话占线）—&gt;报文交换（如同邮件系统，有几个站点）（分布式网络） 报文交换的好处：可以用不同路由使通信更可靠更能容错 消息沿路由跳转的次数，跳数限制–解决路由问题 协议（属于传输层④） 报文交换的缺点是某个文件太大堵塞网络 解决方法：把大报文分成很多小块–数据包–分组交换 报文具体格式由互联网协议定义–IP（网络层？） **IP是一个非常底层的协议 Internet Protocol** IP之上还有其他协议：用户数据报协议 UDP IP负责把数据包送到正确的电脑IP header **UDP负责把数据包送到正确的程序 （UDP中的端口port）** UDP头部还有校验和–checksum，但不提供数据修复和数据重发，并无法得知数据包是否到达（应用于直播，视频通话，对时间要求很高：射击游戏，“丢包”） UDP.png **传输控制协议 TCP（所有数据必须到达）：** TCP头部也有端口号和校验和 TCP IP.png 👇 这个组合被称为TCP/IP TCP数据包有序号，使得接收方可以把数据包正确排序 接收方校验无误后会给发送方发送一个确认码ACK 能删掉重复数据包 可以同时发多个数据包，接收多个确认码 可以调整同时发包数量，解决拥堵问题（确认码的成功率和来回时间可以推断网络的拥堵程度） 缺点：确认码数据包把数量翻了一倍但并没有传播更多的信息 TCP.png 每台联网的计算机都需要一个IP地址，以点分隔的四组数据172.217.7.238 阻塞控制–路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠 当计算机访问一个网站时，需要两个东西：IP地址，端口号 互联网负责把域名和IP地址一一对应，就像电话簿–域名系统 DNS DNS服务器由互联网供应商ISP提供 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求**（会话层④）** 为了更好的管理上亿个域名，DNS存成树状结构（有3千万个二级域名） 顶级域名，二级域名，子域名 DNS.png 这些数据散布在很多DNS服务器上 WIFI 路由器连接的所有设备组成了局域网LAN，局域网再连接到广域网WAN，广域网的路由器属于你的互联网提供商ISP 广域网先连接到一个区域性路由器（覆盖一个街区），然后连接到一个更大的WAN（覆盖整个城市），最终到达互联网主干（由一群超大型，带宽超高路由器组成） 网.jpg 万维网 world wide web 互联网是传递数据的管道，传播最多数据的程序是万维网 万维网的基本单位是页面 页面有内容，有去往其他页面的链接–超链接，这些超链接形成巨大的互联网络 文字超链接–超文本（关联式索引） 为了使网页相互连接，每个网页需要一个唯一的地址–统一资源定位器 URL 👉在浏览器里输入youtube.com，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求，连接到这个IP，这个地址运行着“网络服务器”，网络服务器的标准端口是80端口，下一步是向服务器请求更进一步的页面（这里会用超文本传输协议HTTP：例如GET，还有状态码），例如向服务器发送指令“GET/courses”，服务器收到后会返回该地址对应的网页，然后浏览器会渲染到屏幕上。 👇超文本标记语言 HTML HTML.png 网页浏览器可以和网页服务器沟通 浏览器获取网页和媒体，并负责显示 人工编辑目录–&gt;搜索引擎–&gt;搜索算法 网络中立性：所有的数据包平等，优先级相同 计算机安全 Secrety,Integrity,Availability 保密性，完整性，可用性 威胁模型分析：以能力水平区分 💡身份认证： 你知道什么：用户名/密码–复杂组合（暴力攻击） 你有什么：用户有特定物品，如钥匙🔑和锁🔒 你是谁：生物识别–但有概率性，不能重设 建议“双因素”，“多因素”认证 💡访问控制：通过权限或访问控制列表ACL来实现 权限有：Read，Write，Execute 有很多种访问控制模型，例如：Chinese wall model，Biba model 例如美国的模型： 不能“读上”，读更高等级的内容 不能“写下”，改更低等级的文件（确保顶级机密不外泄） 其他措施：安全大会，安全行业的来审计代码,安全型代码一般开源 黑客与攻击 社会工程学：欺骗别人让别人泄露信息 配置别人的系统 网络钓鱼：邮件发送连接 假托：（电信诈骗） 邮件里带木马：恶意软件伪装成照片等 NAND镜像：暴力攻击被罚时时，增加几根线复制内存，罚时时覆盖内存继续尝试 漏洞利用：远程攻击需要攻击者利用系统漏洞来获得某些能力或访问权限 例如：缓冲区溢出：溢出部分改掉重要值，例如修改权限admin（应对方法：边界检查，随机存放变量在内存中的位置，金丝雀：缓冲区后面跟踪变化） 代码注入：攻击用数据库的网站 结构化查询语言SQL，一种流行的数据库API DROP TABLE users，删掉用户这张表。凉凉 应对：检测特殊字符… 蠕虫：恶意程序在电脑间互相传播，这些电脑组成僵尸网络 DDoS：僵尸网络里的所有电脑发一大堆垃圾信息，堵塞网络 密码学 明文和密文的转化叫加密和解密 对称加密 （密钥一样） 双方都知道密钥： 替换加密（字母出现的频率相同，例如凯撒加密）和移位加密（列移位加密） 加密机器：英格玛（转子，一种映射，映射随着每次按键而改变） 硬件加密-&gt;软件加密 数据加密标准DES，二进制密钥，56bits，暴力破解 高级加密标准AES，更长的密钥，128,192,256bits 密钥交换： 不发送密钥，“单向函数-模幂运算”，如同颜色混合，自己算出密钥 非对称加密 有两个不同的密钥：一个公开一个私有 知道公钥只能加密不能解密，公钥加密后只能用私钥解密 私钥加密也可以用公钥解密，只有有私钥的人能加密，防伪造 非对称加密RSA，公钥密码学 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Crash Course Computer Science（part 1）","slug":"Crash-Course-Computer-science-笔记 1","date":"2020-01-31T03:53:23.000Z","updated":"2020-02-02T05:47:00.413Z","comments":true,"path":"2020/01/31/Crash-Course-Computer-science-笔记 1/","link":"","permalink":"http://pluto-wei.github.io/2020/01/31/Crash-Course-Computer-science-%E7%AC%94%E8%AE%B0%201/","excerpt":"硬件Hardware 软件Software","text":"硬件Hardware 软件Software 硬件Hardware 继电器，真空管，晶体管 二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门） 算术存储单元ALU（算术单元和逻辑单元） 集成电路（都是晶体管组成的） 锁存器 （存储一个位）0 1 寄存器 （一组锁存器） 8位寄存器 16 32 64 写入寄存器前要先启用里面所有的锁存器（允许写入线） 存大量寄存器：矩阵排列 例如16×16网格的锁存器 通过行列的某根线还可以确定到某个确定的锁存器来启动 emm.png 允许写入线，允许读取线，数据线 连接所有的锁存器 多路复用器.png again 把256位内存作为一个整体 （通过8位地址能储存256个数据？错，每一个位置上是一个0或者1，整体表示一个数据，有256个二进制数（也不是256种可能性，而是22562^{256}2256）） 8位就是一个字节（这里都是单位，八位的字节包含8个二进制数） 一个字节有22562^{256}2256种0和1的可能性 把8个256位内存排一排 存储8个数，给他们相同的地址 于是一个8位的地址可以存取一个8位数， （这里好奇怪 无法理解：） 又把这个256位内存叫一位（可能是一位数字的意思？），把8个这样的内存排一排叫1字节？ 为了存储这样的一个8位数，我们同时给8个256位内存一样的地址（如图） 嗷，懂了，这样就能存储一个8位数了！地址是8位 Think about it :一位数相当于有256种可能性，$2{2568}=2{2{64}} $ 整体的可寻址内存 RAM–随机存取存储器 8位的地址 256个地址 每个地址可以读或写一个8位值（8 bits=282^828种） RAM.png 前四位是操作码（OPCODE：LOAD ADD） 后四位是内存地址（if is LOAD） CPU–中央处理器（指令和程序） 中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元 组成 ALU 控制单元 RAM 时钟 CPU.png 取址–&gt;解码–&gt;执行 可操作的指令有 LOAD ADD SUB JUMP HALT 英特尔集成4004，第一个集成CPU 有46条指令 现代CPU有上千个指令和指令变种，有各种巧妙复杂的电路 一秒十亿条指令 高级CPU设计 缓存 在RAM中取一整块存在CPU内部，方便数据的存取。 CPU与RAM中间只有一根数据线，效率较低 当数据有改变时，通过检测脏位，将数据同步给RAM 提高效率 并行处理，同时用上CPU中的取址，解码，执行 高端处理器 会猜测JUMP的下一步，进行推测执行 超标量处理器 一个时间周期完成多条指令 优化**一个指令流**的吞吐量 一个CPU中有多个ALU CPU2.png 多核处理器 同时运行多个指令流 一个CPU芯片中，有多个独立处理单元 CPU3 2个/4个CPU 多核不够时可以用多个CPU 超级计算机 神威太湖之光有40960个CPU，每个CPU有256个核心，每个核心的频率是1.56GHz，每秒钟可以进行9.3亿亿次浮点运算 集成电路 锗-&gt;硅 早期 IC 几个晶体管：把简单电路（逻辑门）封装成单独组件 印刷电路板PCB：通过蚀刻金属线把零件连接在一起 光刻：用光把复杂图案印在材料上，如半导体 用晶圆做基础，把复杂的金属电路放在上面集成所有东西–氧化层–光 刻胶–光掩膜，金属化 光刻还可以制作电阻 电容 一片晶圆可以做很多 IC，整块做完后切割包进微型芯片 芯片的核心是 IC 摩尔定律：每两年左右，材料和制造技术的发展，同样的空间大小，能塞进两倍数量的晶体管 超大规模集成 VLSI 软件：用来自动生成芯片设计 软件Software 早期编程方式 程序怎么进入内存？？ 一.纸卡 最早的编程雅卡尔织布机 早期汇总机–不算计算机，只汇总数据（穿孔纸卡），不能编程 二.插线板 Control panel 控制面板–插线板–&gt;可拔插 有很多小插孔，可以插电线，让机器的不同部分可以相互传数据和信号 世界上第一台通用电子计算机ENIAC–用插线板编程 存取程序计算机 程序和数据都存在–冯诺伊曼结构 一个处理器（有算术逻辑单元），数据寄存器，指令寄存器，指令，内存（负责存数据和指令） 三.面板编程 大量使用开关 编程语言(Software) 二进制是处理器的母语（机器语言，机器码） 对程序的高层次描述–伪代码 汇编器 读取汇编语言的写的程序。然后转成机器码 自己搞定跳转地址（插入可跳转标签） 一般一条机器指令对应一条机器指令 编译器 专门把高级语言转成低级语言(汇编或机器码) 一行高级编程语言，可能转成几十条二进制指令 程序员只需要创建变量–代表内存地址的抽象 解释器 运行时进行转换，而编译器是运行前转换 编程基础（语句和函数） 语法–规定句子结构的一系列规则 赋值语句，if语句，循环语句，把代码打包成函数（子程序） 算法–解决问题的具体步骤 排序：选择排序n2n^2n2，归并排序nlognnlognnlogn 图搜索（找最佳路线）：Dijkstra算法 算法的复杂度–算法的输入大小和运行步骤 数据结构 数组（列表，也叫向量） 字符串（数组的亲戚）：字母 数字 标点符号 矩阵（二维数组，数组的数组） 结构体（多个变量打包，多个不同类型数据放在一起） 链表（一个灵活的数据结构，能存很多个节点）：容易重新排序，插入，两端缩减，倒序 很多复杂的数据结构也用链表：队列和栈 队列：先进先出 栈：后进先出 树（把一个节点的指针变成多个指针）：根节点，子节点，母/父节点（直属上层节点），叶节点（树结束的地方） 二叉树：节点最多只有两个子节点 甚至节点可以用链表来存储你所有的子节点 树的特点：根到叶是单向的 图：数据随意连接，包括循环。用有多个节点的指针表示，可随意指向 红黑树和堆？ 计算机科学之父–图灵 图灵机：规则，状态和纸带 停机问题 无法解决 提出智能，图灵测试（验证码） 软件工程 把函数打包成层级，把相关代码都放在一起，打包成对象 对象.png 对象可以包含其他对象，函数 和变量 对象2.png 把函数打包成对象的思想叫面向对象编程 Object Oriented Programming 文档 （帮助理解代码都做了什么）以及定义好的程序编程接口API API 控制哪些函数和数据让外部访问，哪些仅供内部 面向对象的编程语言可以指定函数是private/public，隐藏复杂度，选择性的公布 集成开发环境 IDE debug 调试 写文档 README 源代码管理（版本控制） 把代码放在一个中心服务器上，叫做代码仓库 Code repository check out，commit（提交） master（代码的总版本） 质量保证测试 QA β版本软件（快完成时向公众发布）免费的QA团队 alpha版本（只在公司内部测试） 操作系统OS 操作硬件的特殊权限，可以运行和管理其他程序 （1950年代） 操作系统充当硬件和软件之间的媒介 操作系统提供API来抽象硬件，叫设备驱动程序 批处理（连续进行多个程序，自动加载程序）–&gt;在单个CPU上同时运行几个程序–&gt;多任务处理（给每个程序分配专属内存块，内存地址的虚拟化，内存保护）–&gt;分时操作系统（处理多个用户） Multics（功能太多）–&gt;Unix（把操作系统分为两个部分：内核（内存管理，多任务输入输出处理）和一堆有用的工具（例如程序和运行库），功能并不是很全面，内存崩溃时“恐慌”）–&gt;Windows（早期经常蓝屏）–&gt;Mac OS X,Linux,iOS,Android 多任务，虚拟内存，内存保护 内存&amp;储存介质 存储介质 打孔纸卡，打孔纸带–&gt;延迟线存储器（扬声器压力波/金属线的震动，顺序存储器/循环存储器）–&gt;磁芯存储器（可访问某一特定位置）–&gt;磁带–&gt;磁鼓储存器–&gt;硬盘（机械硬盘，固态硬盘SSD）–&gt;软盘–&gt;密度更高的软盘（Zip Disks）–&gt;光学存储器（光盘CD，DVD）光盘表面有很多小坑，造成光的不同反射，光学传感器捕获并解码为1和0 文件与文件系统 文件格式： TXT（文本）WAVE（音频，振幅） Bitmap.bmp（图片，像素块：红绿蓝） 元数据（类型，图片宽度，图片高度，深度）+Date 怎么储存文件 为了存多个文件，需要一个特殊文件记录文件的位置（文件目录，通常在最开头） 文件目录.png 文件系统专门负责管理文件 平面文件系统： （文件都在同一个目录里） 分配块–增大或减小 碎片处理–把数据来回移动，排列成正确的数据 分层文件系统 目录文件不仅要指向文件，还要指向目录 根目录.png 压缩 Compression 把数据占用的空间压到更小 作用：高效储存图片，音乐，视频 无损压缩 消除冗余 游程编码适合经常出现相同值的文件 用更紧凑的表示方法 字典编码 GIF,PNG,PDF,ZIP 有损压缩 感知编码 用不同的精度编码不同的频段 例如声音，超声波/低音 FLAC / WAV --&gt; MP3 有损压缩文件格式 JPEG 视频，每一帧，时间冗余，只存变化的部分，补丁的移动和转换 MPEG-4 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"http://pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-11-17T16:28:39.391Z","updated":"2020-02-01T17:00:58.231Z","comments":true,"path":"2019/11/18/hello-world/","link":"","permalink":"http://pluto-wei.github.io/2019/11/18/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start Create a new post 1$ hexo new \"My New Post\" More info: Writing Run server 1$ hexo server More info: Server Generate static files 1$ hexo generate More info: Generating Deploy to remote sites 1$ hexo deploy More info: Deployment document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","categories":[],"tags":[]}]}