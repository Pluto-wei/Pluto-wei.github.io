<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pluto-wei</title>
  
  <subtitle>Hello,nice to meet you!</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://pluto-wei.github.io/"/>
  <updated>2020-02-08T07:48:21.234Z</updated>
  <id>http://pluto-wei.github.io/</id>
  
  <author>
    <name>Pluto-wei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于指针的初始化问题</title>
    <link href="http://pluto-wei.github.io/2020/02/08/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>http://pluto-wei.github.io/2020/02/08/%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-08T06:07:36.000Z</published>
    <updated>2020-02-08T07:48:21.234Z</updated>
    
    <content type="html"><![CDATA[<p>不要给任何没有初始化的指针赋值！<br>不要给任何没有初始化的指针赋值！<br>不要给任何没有初始化的指针赋值！<br>重要的事情说亿遍！！！！</p><a id="more"></a><p>老是忘掉！！！</p><p>💡应该在给 *p赋值前要给 *p分配一个空间</p><p>💡scanf读入字符串一定要事先为它申请足够的空间</p><ul><li>字符串</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></tbody></table></figure><ul><li>结构体指针</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> gender;</span><br><span class="line">        studentInfo* next;</span><br><span class="line">    }*p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;p-&gt;id, &amp;p-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c"</span>, p-&gt;id, p-&gt;gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="comment">//这样是无法输出的，因为对结构体指针没有进行初始化操作</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> gender;</span><br><span class="line">        studentInfo* next;</span><br><span class="line">    }stu, *p;</span><br><span class="line">    p = &amp;stu;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;p-&gt;id, &amp;p-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c"</span>, p-&gt;id, p-&gt;gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="comment">//这样才可以！</span></span><br></pre></td></tr></tbody></table></figure><p>💡 其实不过就是你在给指针指向的地方赋值的时候，总得知道他指向哪里吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要给任何没有初始化的指针赋值！&lt;br&gt;
不要给任何没有初始化的指针赋值！&lt;br&gt;
不要给任何没有初始化的指针赋值！&lt;br&gt;
重要的事情说亿遍！！！！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://Pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 3）</title>
    <link href="http://pluto-wei.github.io/2020/02/06/Crash%20Course%20Computer%20science%203/"/>
    <id>http://pluto-wei.github.io/2020/02/06/Crash%20Course%20Computer%20science%203/</id>
    <published>2020-02-06T05:19:55.000Z</published>
    <updated>2020-02-06T13:37:27.839Z</updated>
    
    <content type="html"><![CDATA[<p>本部分内容：<strong>计算机的现状和未来</strong><br>完结撒花！！！！<br><em><a id="more"></a></em><br>今天是2020/02/06<br>Crash Course Computer science 计算机科学速成课 终于看完啦！！<br>根据浏览器判断是2020/01/23开始的😏<br>除去没看的几天，一共看了13天😬还不错啦！<br>强推！真的很棒！感谢款待！！<br>小姐姐在此！超可爱哦！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-5b63cc139a5449fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xjj" title="">                </div>                <div class="image-caption">xjj</div>            </figure><h1>计算机的现状和未来</h1><h2 id="机器学习ML＆人工智能AI">机器学习ML＆人工智能AI</h2><ul><li>机器学习算法可以让计算机从数据中学习，然后自行做出预测和决定</li><li>机器学习是为了实现人工智能这个更宏大的目标的技术之一</li><li><strong>分类</strong>：用算法减小复杂性，把数据简化成特征，特征帮助分类</li><li>机器学习算法的目的是最大化正确分类&amp;最小化错误分类，找到最好的决策边界</li><li>源于统计学的技术：<strong>决策树，森林，支持向量机</strong></li><li><strong>人工神经网络</strong>，来源于大脑里的神经元。输入层，隐藏层，输出层。</li><li>算法调整偏差和权重来训练神经网络，用标记数据训练和测试，提高准确性。有激活函数，线性传递函数</li><li>加权，求和，偏置，激活函数应用于一层里的每一个神经元，并向前传播</li><li>弱人工智能：只能做特定任务，分类，找人脸，翻译，自动驾驶</li><li>强人工智能：真正通用，像人一样聪明</li><li>强化学习：学习什么管用，什么不管用</li></ul><h2 id="计算机视觉">计算机视觉</h2><ul><li>颜色跟踪算法，一块块像素处理</li><li>核/过滤器，把核引用于像素块叫做卷积</li><li>核能做很多图像转换，例如锐化图像，模糊图像；可以匹配特定形状，例如边缘检测；可以描述简单的形状，例如找线段圆圈（眼睛鼻子）</li><li>多个核组合在一起，找到特征组合</li><li>卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像，本质上是被不同的核处理了，逐层深入，卷积，由小的特征组合成大的特征，直到一层把所有的特征集合到一起</li><li>生物识别 标志点 情感识别算法</li></ul><h2 id="自然语言处理">自然语言处理</h2><ul><li>Natural Language Processing</li><li>把句子切成一块块，词性，短语结构规则，把语言结构化</li><li>用规则做出分析树</li><li>聊天机器人的最基本部件：处理，分析，生成文字。应用于客服</li><li>指定简单协议用于沟通–&gt;机器学习，从语言数据库中学习，深度学习网络</li><li>语音识别，波形转化成频率（快速傅里叶变换）</li><li>构成声音的不同片段：音素</li><li>语音合成</li></ul><h2 id="机器人">机器人</h2><ul><li>自动运行的机器，大规模生产，高效不知疲惫</li><li>可编程工业机器人，简单控制回路，负反馈回路</li><li>PID–有控制回路和反馈机制 “比例-积分-微分控制器”</li><li>机器人三定律</li></ul><h2 id="计算机心理学">计算机心理学</h2><ul><li>社会心理学，认知心理学，行为心理学，感知心理学</li><li>易用读：人造物体达到目的的效率有多高</li><li>UI设计：视觉，认知系统 ，直观性</li><li>视频可以增强凝视</li><li>人机交互HRI</li><li>几乎像人类和真的人类之间的小曲线–恐怖谷</li></ul><h2 id="教育科技">教育科技</h2><ul><li>智能辅导系统</li><li>判断规则+选择算法–域模型</li><li>贝叶斯知识追踪</li><li>自适应式程序</li><li>教育数据挖掘</li><li>虚拟现实和增强现实</li></ul><h2 id="奇点，天网，未来">奇点，天网，未来</h2><ul><li>奇点：智能科技的失控性发展</li><li>复杂度刹车：S性曲线，而非J型</li><li>手工型工作，思维型工作；重复性工作，非重复性工作</li><li>加密货币，无线通讯，3D打印，生物信息学，量子计算…</li></ul><p>推荐：<br>哲学速成课，人工智能速成课，<br>西部世界<br>钻石时代</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分内容：&lt;strong&gt;计算机的现状和未来&lt;/strong&gt;&lt;br&gt;
完结撒花！！！！&lt;br&gt;
&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C语言 快速入门！！</title>
    <link href="http://pluto-wei.github.io/2020/02/05/C%E8%AF%AD%E8%A8%80-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%81%EF%BC%81/"/>
    <id>http://pluto-wei.github.io/2020/02/05/C%E8%AF%AD%E8%A8%80-%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%EF%BC%81%EF%BC%81/</id>
    <published>2020-02-05T04:25:10.000Z</published>
    <updated>2020-02-05T04:37:05.497Z</updated>
    
    <content type="html"><![CDATA[<p>233333<br>我终于快速入门了！！</p><a id="more"></a><p>2月2号开始看的《算法笔记》<br>今天终于把快速入门看完了==<br>4天嗷~</p><p>突然想放一张散散~生日快乐</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-6f36adacb730b7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@7.png" title="">                </div>                <div class="image-caption">@7.png</div>            </figure><p>下面进入正题~</p><h1>基本数据类型</h1><h2 id="变量类型：">变量类型：</h2><ul><li><p>整型：short， int ，long long</p><p>绝对值在**$10^9$**范围内（32位）都可以定义为int</p><p>$10^{10}$-$10^{18}$就得用long long（64位）</p><p>（若赋大于int最大($2^{31}-1$)的值，则需要在初值后面加LL，才能编译成功）</p></li><li><p>浮点型：float，double</p><p>精度 float 6-7位，double15-16位</p><p>记住：遇到浮点用double</p></li><li><p>字符型：</p><p>标准ASCII范围是0-127，包含控制字符（转义字符\n\t\0）和可显示字符</p><p>记住：<strong>小写字母比大写字母ASCII码大32，</strong></p><p>‘字符’%c “字符串”%s</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'z'</span>,c2 = <span class="string">'j'</span>,c3 = <span class="number">117</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c"</span>,c1,c2,c3);</span><br><span class="line"><span class="comment">//字符常量（单个字符）用单引号标注</span></span><br><span class="line"><span class="comment">//输出为 zju</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>布尔值：</p><p>c语言中要<strong>stdbool.h</strong></p><p>true（非零）false（零）</p></li></ul><h2 id="强制类型转换">强制类型转换</h2><p>（新类型名）变量名</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.f"</span>,(<span class="keyword">double</span>)a/(<span class="keyword">double</span>)b);</span><br></pre></td></tr></tbody></table></figure><h2 id="定义常量">定义常量</h2><ul><li><p>符号常量-宏定义</p><p>define是原封不动直接替换，记得加（）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量/任何语句或片段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>const常量</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型 变量名 = 常量；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>；</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="运算符">运算符</h2><ul><li><p>算术运算符</p><p>/ 取商，向下取整，舍去小数  %取余数</p><p>i++先用再加，++i先加再用</p></li><li><p>关系运算符</p><p>&lt; &gt; &lt;= &gt;= == !=</p></li><li><p>逻辑运算符</p><p>&amp;&amp;与    ||或    ！非</p></li><li><p>条件运算符</p><p>唯一的三目运算符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A ? B : C ; <span class="comment">//A真则B，A假则C</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>位运算符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)<span class="number">-1</span>; <span class="comment">//无穷大，上限，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;<span class="comment">//避免两个数相加超过int最大值</span></span><br></pre></td></tr></tbody></table></figure><p>按二进制进行:  左移&lt;&lt;  右移&gt;&gt;  位于&amp;  位或|  位异或^  位取反~</p></li></ul><h1>顺序结构</h1><h2 id="赋值表达式">赋值表达式</h2><ul><li>注意 +=   -=   /=    *=   %=  的运用</li></ul><h2 id="scanf和printf输入输出">scanf和printf输入输出</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"格式控制"</span>，变量地址)；</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  <span class="comment">//int</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n); <span class="comment">//long long</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;fl); <span class="comment">//float</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;db); <span class="comment">//double</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);  <span class="comment">//char</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); <span class="comment">//字符串char*，char str[]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>除char数组整个输入 不加&amp;，其他变量类型都要加&amp;</li><li>除%c，scanf对其他格式符的输入（%d，%s）是以空白符为结束的</li><li>%c是可以读入空格跟换行的</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"格式控制"</span>，变量名称)；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n);  <span class="comment">//int</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,n); <span class="comment">//long long</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,fl); <span class="comment">//float</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,db); <span class="comment">//double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,c);  <span class="comment">//char</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str); <span class="comment">//字符串char*，char str[]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>唯一不同：double输出格式%f ，输入%lf</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\\"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t \n"</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%md"</span>,a);<span class="comment">//%md不足m位的int以m位进行右对齐输出，高位空格补齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-md"</span>,a);<span class="comment">//左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0md"</span>,a); <span class="comment">//高位补0而不是补空格</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.mf"</span>,a); <span class="comment">//保留m位小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%n.mf"</span>,a); <span class="comment">//保留m位小数,宽度占n位</span></span><br></pre></td></tr></tbody></table></figure><h2 id="getchar与putchar输入输出">getchar与putchar输入输出</h2><ul><li>输入输出单个字符，可以识别存储换行符\n</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1,c2;</span><br><span class="line">c1 = getchar();</span><br><span class="line">getchar();</span><br><span class="line">c2 = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(c1);</span><br><span class="line"><span class="built_in">putchar</span>(c2);</span><br></pre></td></tr></tbody></table></figure><h2 id="typedef">typedef</h2><ul><li>给复杂的数据类型起别名</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL a = <span class="number">123456789012345</span>,b = <span class="number">34567890123456</span>;<span class="comment">//直接使用LL</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常用math函数">常用math函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="keyword">double</span> x); <span class="comment">//对double型变量取绝对值</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="keyword">double</span> x);<span class="comment">//对double型变量向下取整，得到的值更小，无论正负</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="keyword">double</span> x); <span class="comment">//对double型变量向上取整</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> p); <span class="comment">//返回$r^p$</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="keyword">double</span> x);<span class="comment">//返回算术平方根</span></span><br><span class="line"><span class="built_in">log</span>(<span class="keyword">double</span> x);<span class="comment">//取以e为底对数，任意底数要用换底公式</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="keyword">double</span> x),<span class="built_in">cos</span>(<span class="keyword">double</span> x),<span class="built_in">tan</span>(<span class="keyword">double</span> x);<span class="comment">//参数要求弧度制</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="keyword">double</span> x),<span class="built_in">acos</span>(<span class="keyword">double</span> x),<span class="built_in">atan</span>(<span class="keyword">double</span> x);</span><br><span class="line">round(<span class="keyword">double</span> x);<span class="comment">//四舍五入到个位，返回类型double</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>但是这些函数直接以%f输出会都很多零</p><p>最好还是要控制位数%.0f   %.mf</p><p>也可以 %d ，(int)db</p></li><li><p>double x 只是说明这是一个double型变量，并不需要加上double</p></li><li><p>pi精确定义为acos(-1.0)</p></li></ul><h1>选择结构</h1><h2 id="if-语句">if 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件A) {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (条件B) {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>技巧：if（n==0） 等价于if（!n），if（n!=0）等价于if（n）</li><li>if语句的嵌套</li></ul><h2 id="switch-语句">switch 语句</h2><ul><li>用于分支条件比较多的情况</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式){</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">}   <span class="comment">//break结束当前switch，表达式等于常量表达式n就执行第n条</span></span><br></pre></td></tr></tbody></table></figure><h1>循环结构</h1><h2 id="while-语句">while 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件A){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="do-while-语句">do while 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>{</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">while</span> (条件A);</span><br></pre></td></tr></tbody></table></figure><h2 id="for-语句">for 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式A;表达式B;表达式C){</span><br><span class="line">    ...</span><br><span class="line">} <span class="comment">//先执行A，再判断B，每个循环后执行C</span></span><br></pre></td></tr></tbody></table></figure><h2 id="break-和-continue-语句">break 和 continue 语句</h2><ul><li>break直接退出以上三种循环，switch语句</li><li>continue临时结束循环的当前轮回，进入下一轮回</li></ul><h1>数组</h1><ul><li>注意从a[0]开始</li></ul><h2 id="一维数组">一维数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名 [数组大小] = { , , };</span><br><span class="line">数组名称[下标]; <span class="comment">//访问</span></span><br></pre></td></tr></tbody></table></figure><h2 id="二维数组">二维数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名 [第一维大小][第二维大小] = { { , , },{ },      };</span><br></pre></td></tr></tbody></table></figure><ul><li>如果数组较大（$10^6$级别），需要将其定义在主函数之外</li><li>多维数组类似</li></ul><h2 id="memset-函数">memset 函数</h2><ul><li>对数组中的每一个元素赋相同的值</li><li>需要头文件string.h</li><li>建议只赋0/-1，其他数字（会出错）使用fill函数</li><li>因为memset使用的是按字节赋值</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,值,<span class="keyword">sizeof</span>(数组名));</span><br></pre></td></tr></tbody></table></figure><h2 id="字符数组">字符数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"Good Story!"</span>; <span class="comment">//直接赋值仅限于初始化</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = {<span class="string">'G'</span>,<span class="string">'o'</span>,...}; <span class="comment">//记得长度要多一个存\0</span></span><br></pre></td></tr></tbody></table></figure><h2 id="gets和puts-输入输出">gets和puts 输入输出</h2><ul><li><p><strong>scanf 输入 printf 输出</strong>（见上文）</p></li><li><p><strong>getchar 输入 putchar 输出</strong> （见上文）</p><p>二维数组时 用 getchar ( ) 吸收掉每行末尾的换行符</p></li><li><p><strong>gets 输入 puts 输出</strong></p><p>gets 识别换行符\n作为输入结束，可以读入空格</p><p>puts 输出后会紧跟一个换行</p></li><li><p>puts 和 printf 通过识别 \0作为字符串的结尾</p></li><li><p>如果不是 scanf的%s 或gets输入（例如getchar），要在字符串末尾加\0</p></li><li><p>只有char型数组需要\0，int型数组不需要</p></li></ul><h2 id="string-h-头文件">string.h 头文件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符数组);<span class="comment">//得到第一个\0前的字符的个数</span></span><br><span class="line"><span class="built_in">strcmp</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//按字典序比较两个字符串大小</span></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//把字符数组2复制给字符数组1，包括\0</span></span><br><span class="line"><span class="built_in">strcat</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//把字符数组2接到字符数组1后面</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>strcmp：</p><p>从前往后比，a小于b，aaaa小于aab，</p><p>字符数组1&lt;字符数组2,则返回一个负整数；</p><p>字符数组1==字符数组2,则返回0；</p><p>字符数组1&gt;字符数组2,则返回一个正整数；</p></li></ul><h2 id="sscanf-与-sprintf">sscanf 与 sprintf</h2><ul><li>第一个s理解为string，均在stdio头文件下</li><li>scanf 和 printf 只是把下面的str 换成screen</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">"%d"</span>,&amp;n);<span class="comment">//把字符数组str中的内容以%d的格式写入n</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,n);<span class="comment">//把n以%d的格式写到str字符数组中</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>]=<span class="string">"2048:3.14,hello"</span>;</span><br><span class="line"><span class="built_in">sscanf</span> (str,<span class="string">"%d:%lf,%s"</span>,&amp;n,&amp;db,&amp;str2) ;<span class="comment">//从左边读到右边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">32</span>;</span><br><span class="line"><span class="keyword">double</span> db = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>],str2[<span class="number">100</span>]=<span class="string">"good"</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d:%.2f,str"</span>,n,db,str2); <span class="comment">//从右边读到左边</span></span><br></pre></td></tr></tbody></table></figure><ul><li>sscanf 还支持 <a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式</a>（匹配）</li></ul><h1>函数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名称(参数类型 参数){</span><br><span class="line">    函数主体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意全局变量和局部变量，形参和实参</li><li>以<strong>数组作为函数参数</strong>时，对数组元素的修改就是对原数组的修改（与普通的局部变量不同）</li><li>但不可以返回数组</li><li>函数的嵌套调用，例如max三个数可以用到max两个数</li><li>函数的递归调用，自己调用自己，例如算n的阶乘</li></ul><h1>指针</h1><ul><li>❗ 不要给任何没有初始化的指针的赋值！</li><li>❗ 应该在给<em>p赋值前要给</em>p分配一个空间</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1,*p2;</span><br><span class="line"><span class="keyword">double</span> *p；</span><br><span class="line"><span class="keyword">char</span> *p;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a,*p2;</span><br><span class="line">p2 = &amp;b; <span class="comment">//取地址</span></span><br><span class="line">*p = <span class="number">233</span>; <span class="comment">//取址</span></span><br></pre></td></tr></tbody></table></figure><ul><li>int *是指针变量的类型，p才是变量名</li><li>因此地址&amp;a是赋给p而不是*p</li><li>指针变量支持自增自减操作</li><li>a=&amp;a[0]</li><li>a+i = &amp;a[i+1]</li><li>两个int型指针相加减，等价于之间相差了几个int</li><li>指针变量作为函数参数，只有在获取地址的情况下才能真正修改变量</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//?? scanf能赋值给字符数组，不能赋值给指针的问题</span></span><br><span class="line"><span class="comment">//scanf读入字符串一定要事先为它申请足够的空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="引用">引用</h2><ul><li>c++语法，产生变量的别名</li><li>&amp;加在，会对原变量进行修改</li><li>就是说x是对原来a取的一个别名，改变x就是改变a，当然这里的x用a也可以</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line">change(a);</span><br></pre></td></tr></tbody></table></figure><h1>结构体的使用</h1><h2 id="结构体的定义">结构体的定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span>{</span></span><br><span class="line">    <span class="comment">//一些基本的数据结构或者自定义的数据类型</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>结构体能定义除了自己本身的任何数据类型</li><li>不能定义自身，但可以定义自身类型的指针变量</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    node n; <span class="comment">//不能定义node型变量</span></span><br><span class="line">    node* next; <span class="comment">//可以定义node*型指针变量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="访问结构体内的元素">访问结构体内的元素</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    studentInfo* next;</span><br><span class="line">}stu,*p;</span><br><span class="line"><span class="comment">//访问变量：stu.id stu.name stu.next</span></span><br><span class="line"><span class="comment">//访问指针变量p中的元素：(*p).id  p-&gt;id p-&gt;name p-&gt;next</span></span><br></pre></td></tr></tbody></table></figure><h2 id="结构体的初始化">结构体的初始化</h2><ul><li>构造函数：用以初始化</li><li>结构体内有默认构造函数，函数名和结构体名相同</li><li>只要参数个数和类型不完全相同，就可以定义任意多个构造函数，适应不同场合</li><li>好处：在结构体元素交多时显得代码精炼，不需要临时变量就可以初始化一个结构体</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    chat gender;   </span><br><span class="line">    <span class="comment">//用以不初始化就定义结构体变量</span></span><br><span class="line">    studentInfo(){}</span><br><span class="line">    <span class="comment">//只初始化gender</span></span><br><span class="line">    studentInfo(<span class="keyword">char</span> _gender){</span><br><span class="line">        gender = _gender</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//同时初始化id和gender</span></span><br><span class="line">    studentInfo(<span class="keyword">int</span> _id,<span class="keyword">char</span> _gender){</span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    }<span class="comment">//可以简化为</span></span><br><span class="line">    studentInfo(<span class="keyword">int</span> _id,<span class="keyword">char</span> _gender):id(_id),gender(_gender){}</span><br><span class="line">}stu[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//初始化的时候就可以直接使用构造函数</span></span><br><span class="line">stu[i]=studentInfo(<span class="number">2019</span>,<span class="number">0</span>);<span class="comment">//类似这样子</span></span><br></pre></td></tr></tbody></table></figure><h1>补充</h1><h2 id="cin-与-cout">cin 与 cout</h2><ul><li>添加头文件 #include <iostream> 和 using namespace std;才能使用</iostream></li><li>不需要指定输入输出格式，不需要取地址符&amp;</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">//输入一个整数n</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; db; <span class="comment">//double型浮点数</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;<span class="comment">//char型数组</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str; <span class="comment">//同时读入多个变量</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str,<span class="number">100</span>); <span class="comment">//读入一整行到char型数组str[]中</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>,str); <span class="comment">//string容器输入</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>&lt;&lt; db &lt;&lt; <span class="string">" "</span> &lt;&lt; c &lt;&lt; str; <span class="comment">//输出时不会加空格</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">"haha"</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//endl也会换行</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制double的型的精度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="number">1.2345</span></span><br></pre></td></tr></tbody></table></figure><ul><li>只有在十分必要的时才使用cin和cout，例如 string</li></ul><h2 id="浮点数的比较">浮点数的比较</h2><ul><li>浮点数在经过运算后可能会变成3.14000001，3.1399999，就不会判为==</li><li>引入极小数eps来对误差进行修正</li><li>成立返回true，想要使用不等于!Equ(a,b),可直接对浮点数进行比较</li><li>加括号防止宏定义可能带来的错误</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>)</span><br><span class="line">#define Equ(a,b) ((<span class="built_in">fabs</span>((a)-(b)))&lt;(eps)) <span class="comment">//等于运算符==</span></span><br><span class="line">#define More(a,b) (((a)-(b))&gt;(eps)) <span class="comment">//大于运算符&gt;</span></span><br><span class="line">#define Less(a,b) (((a)-(b))&lt;(-eps)) <span class="comment">//小于运算符&lt;</span></span><br><span class="line">#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) <span class="comment">//大于等于运算符&gt;=</span></span><br><span class="line">#define LessEqu(a,b) (((a)-(b))&lt;(eps)) <span class="comment">//小于等于运算符&lt;=</span></span><br></pre></td></tr></tbody></table></figure><ul><li>类似的还有开根号,asin,acos，需要eps保证变量在定义域内的问题</li><li>0.00还会变成-0.00，则要与-0.00进行比较，若比对成功则加上eps来修正</li></ul><h2 id="复杂度">复杂度</h2><ul><li><p><strong>时间复杂度</strong>O(n)，基本运算次数</p><p>一般的OJ系统，一秒能承受的运算次数$10^7$ ~ $10^8$</p></li><li><p><strong>空间复杂度</strong>，消耗的数据空间</p><p>空间一般够用，常常以空间换时间</p></li><li><p><strong>编码复杂度</strong>，定性的概念</p></li></ul><h1>黑盒测试</h1><h2 id="单点测试">单点测试</h2><p>判断每组数据是否正确</p><h2 id="多点测试">多点测试</h2><p>一次性运行所有数据</p><ul><li><p>while… EOF型，默认读到文件末尾，EOF=-1状态</p><p>无法读取时，scanf会返回-1（关于scanf的返回值，还需要多测试）</p><p>手动触发EOF：&lt;Ctrl+Z&gt; ^z 再按回车就可结束</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) != EOF){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while…break型</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>),&amp;a,&amp;b != EOF){</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a，&amp;b),a||b){ <span class="comment">//简洁版，ab有一个不为0就循环</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while(T–)型，给出测试数据的组数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种输出类型</span></span><br><span class="line"><span class="number">1.</span>正常输出</span><br><span class="line"><span class="number">2.</span>每组数据输出出后额外加一个空格</span><br><span class="line"><span class="number">3.</span>最后一组数据后面没有空行</span><br><span class="line"><span class="keyword">while</span>(T--){</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(T &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意每次循环都要重置变量和数组</li><li>重置数组一般使用memset函数或fill函数</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;233333&lt;br&gt;
我终于快速入门了！！&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="C语言" scheme="http://Pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 2）</title>
    <link href="http://pluto-wei.github.io/2020/02/02/Crash%20Course%20Computer%20science%202/"/>
    <id>http://pluto-wei.github.io/2020/02/02/Crash%20Course%20Computer%20science%202/</id>
    <published>2020-02-02T05:17:44.000Z</published>
    <updated>2020-02-05T08:02:23.946Z</updated>
    
    <content type="html"><![CDATA[<p><strong>人机交互</strong><br><strong>计算机网络</strong></p><p><em><a id="more"></a></em></p><h1>人机交互</h1><h2 id="命令行">命令行</h2><ul><li><p>历史</p><p><strong>机械输入</strong>，齿轮 旋钮 开关 等机械结构 ，一大堆机械面板和线，<br>–&gt;<strong>打孔纸卡和磁带</strong>，输入依然是打印纸ang实时指示灯<br>–&gt;<strong>键盘 打字机</strong><br>–&gt;电传打字机：可用电话线发送和接收文本（蒸汽朋克版聊天室）<br>–&gt;<strong>电传</strong>交互（来回对话）–命令行界面 cmd<br>–&gt;<strong>屏幕</strong>代替电传打字机：虚拟电传打印机/玻璃电传打印机 --叫做终端 terminal<br>–&gt; 文字游戏，互动式小说–&gt; MUD 多人地牢游戏（MMORPG的前辈–大型多人在线角色扮演）</p></li></ul><h2 id="命令行指令">命令行指令</h2><p>ls (list) 列出当前目录里的所有文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-025053e99b6ad400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>cat (concatenate 连接)（unix）显示文件内容</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-18f8e9994a107312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>finger  找朋友</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-78dea6ed56276912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="屏幕-and-2D图形显示">屏幕 and 2D图形显示</h2><ul><li><p>早期屏幕的用途：跟踪程序的运行情况，结果打印在纸上，或是保存更永久的地方<br>（屏幕更新快，对临时值简直完美）</p></li><li><p>阴极射线管CRT：把电子发射到有磷光体图层的屏幕上，路径由磁场控制<br>1.矢量扫描，用电子束描述出形状<br>2.光栅扫描，一行行，从上自下，从左往右，只在特定地方打开电子束</p></li><li><p>早期不存像素（占用内存过多），存符号<br>字符生成器–第一代显卡<br>只读存储器 ROM，存每个字符的图形（点阵图案）<br>访问内存中的屏幕缓冲区（专为图形保留）<br><img src="https://upload-images.jianshu.io/upload_images/20644861-d8ba76044a699ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>用字符模仿图形界面：_ + 画盒子和线<br>字符集：<br><img src="https://upload-images.jianshu.io/upload_images/20644861-ccaa11179970cbdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>用额外的bit定义字体颜色和背景颜色</p></li><li><p>用CRT上的矢量模式，所有的东西都用线组成 （海龟作图）–&gt;动画</p></li><li><p><strong>位图显示</strong>–内存中的位对应屏幕上的像素</p></li><li><p>Sketchpad （几何画板）一个<strong>交互式</strong>图形界面–计算机辅助设计 CAD<br>输入设备–光笔</p></li></ul><h2 id="图形界面">图形界面</h2><ul><li>直接显示了你可以做什么，直接在屏幕上找选项即可，"选择并点击界面”<br>图形用户界面–GUI</li><li>鼠标–用户和屏幕上的信息互动（光标）</li><li>桌面–模拟实际桌面，有窗口，时钟等小组件</li><li>用户触发事件–如点击按钮，选一个菜单项，滚动窗口–有对应的执行函数</li></ul><h2 id="3D图形">3D图形</h2><p>有图型算法负责把3D坐标拍平显示到2D屏幕上–3D投影</p><ul><li>线框渲染：正交投影，透视投影</li><li><strong>扫描线渲染</strong>（填充图形）：<strong>抗锯齿</strong><br><img src="https://upload-images.jianshu.io/upload_images/20644861-b1118218da0afb51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抗锯齿.png"></li><li>遮挡：排序算法，画家算法–由远到近</li><li>深度缓冲</li><li><strong>明暗处理</strong>：平面着色–最基本的照明算法，高洛德着色，冯氏着色<br><img src="https://upload-images.jianshu.io/upload_images/20644861-bab45421c4564a82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="明暗处理.png"></li><li><strong>纹理</strong>：纹理映射</li><li>加速渲染：<br>并行渲染</li><li>GPU–图形处理单元（在显卡上，周围有专用的RAM）</li></ul><h1>计算机网络</h1><h2 id="👉开放式系统互联通信参考模型-OSI">👉开放式系统互联通信参考模型 OSI</h2><p><strong>物理层</strong>：线路里的电信号，无线网络里的无线信号<br><strong>数据链路层</strong>：负责管理物理层<br>有媒体访问控制地址MAC，冲突检测，指数退避和其他的一些底层协议<br><strong>网络层</strong>：负责各种报文交换和路由 IP<br><strong>传输层</strong>：UDP TCP这些协议，负责在计算机之间进行点到点的传输，检修和修复错误<br><strong>会话层</strong>：使用UDO TCP创建连接，传递信息，然后关掉连接<br><strong>表示层和应用程序层</strong>：浏览器，HTML解码，在线看电影</p><p>详情：&lt;<a href="https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B</a>&gt;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-a0ab560094b00893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI.png" title="">                </div>                <div class="image-caption">OSI.png</div>            </figure><h2 id="互联网">互联网</h2><ul><li><p>早期</p><p>需要分享数据和资源–&gt;公司或研究室内部使用<br>球鞋网络，共享物理资源–大家共享一台联网的打印机<br>早期网络也共享存储空间，不是每台电脑都有存储器</p></li><li><p>局域网</p><p>计算机近距离构成的小型网络LAN<br>最著名最成功的：<strong>以太网</strong></p></li><li><p>载波侦听多路访问 CSMA（属于链路层②）<br><img src="https://upload-images.jianshu.io/upload_images/20644861-0a58f3fc52194c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CSMA.png"></p><p><strong>使用共享载体</strong><br>以一台以太电线连接所有计算机，以电信号的形式将数据传入电缆<br>每台机器需要有唯一的媒体访问控制地址（MAC地址）<br>数据的接受方的地址放在数据的头部，作为数据的前缀发送到网络中<br>计算机看到自己的MAC才处理数据<br>这种 <strong>多台电脑共享一个传输媒介</strong> 的方法 叫–CSMA <strong>载波侦听多路访问</strong><br>含义：载体，运输数据的共享媒体，以太网的载体是铜线，wifi的载体是传播无线电波的空气。很多计算机同时侦听载体，侦听，多路。<br>带宽：载体传播数据的速度</p></li><li><p>冲突（属于<strong>链路层②</strong>）</p><p>多个计算机想同时传入数据时就会冲突。<br>如果冲突，会等一小段随机时间，指数退避–指数级增长等待时间（以太网）<br>载体和其中的设备–冲突域<br>可以用交换机把其分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络间传数据（属于链路层）</p><p><img src="https://upload-images.jianshu.io/upload_images/20644861-fa77e1182cbfd9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络.png"></p><p>大的计算机网络也是如此，包括最大的网络–互联网，也是多个连在一起的小一点的网络，是不同网络之间可以传递信息</p></li><li><p>路由（属于<strong>网络层③</strong>）</p><p>路由—通过互联的网络把信息从源地址传输到目的地址的活动<br>专用的通信线路（电路交换，电话占线）—&gt;报文交换（如同邮件系统，有几个站点）（分布式网络）<br>报文交换的好处：可以用不同路由使通信更可靠更能容错</p><p>消息沿路由跳转的次数，跳数限制–解决路由问题</p></li><li><p>协议（属于<strong>传输层④</strong>）</p><p>报文交换的缺点是某个文件太大堵塞网络<br>解决方法：把大报文分成很多小块–<strong>数据包</strong>–分组交换</p><p>报文具体格式由互联网协议定义–IP（网络层？）</p></li></ul><p><code>**IP是一个非常底层的协议 Internet Protocol**</code><br>IP之上还有其他协议：用户数据报协议 UDP<br>IP负责把数据包送到正确的电脑IP header</p><p><code>**UDP负责把数据包送到正确的程序 （UDP中的端口port）**</code><br>UDP头部还有校验和–checksum，但不提供数据修复和数据重发，并无法得知数据包是否到达（应用于直播，视频通话，对时间要求很高：射击游戏，“丢包”）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-9c6ca36ff8ff0e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP.png" title="">                </div>                <div class="image-caption">UDP.png</div>            </figure><p><code>**传输控制协议 TCP（所有数据必须到达）：**</code><br>TCP头部也有端口号和校验和</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-8de54ef4d7929c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP IP.png" title="">                </div>                <div class="image-caption">TCP IP.png</div>            </figure><p>👇 这个组合被称为TCP/IP</p><ul><li>TCP数据包有序号，使得接收方可以把数据包正确排序</li><li>接收方校验无误后会给发送方发送一个确认码ACK</li><li>能删掉重复数据包</li><li>可以同时发多个数据包，接收多个确认码</li><li>可以调整同时发包数量，解决拥堵问题（确认码的成功率和来回时间可以推断网络的拥堵程度）</li><li>缺点：确认码数据包把数量翻了一倍但并没有传播更多的信息</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-ac678397b2bd5a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP.png" title="">                </div>                <div class="image-caption">TCP.png</div>            </figure><hr><ul><li><p>每台联网的计算机都需要一个IP地址，以点分隔的四组数据172.217.7.238</p></li><li><p>阻塞控制–路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠</p></li><li><p>当计算机访问一个网站时，需要两个东西：IP地址，端口号<br>互联网负责把域名和IP地址一一对应，就像电话簿–<strong><code>域名系统 DNS</code></strong></p><p>DNS服务器由互联网供应商ISP提供</p></li></ul><hr><p><a href="http://xn--youtube-ri9ko68a3zbl11jdo3d4zpukhkm45l.com" target="_blank" rel="noopener">👉在浏览器里输入youtube.com</a>，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求**（会话层④）**</p><ul><li>为了更好的管理上亿个域名，DNS存成树状结构（有3千万个二级域名）</li><li>顶级域名，二级域名，子域名</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-ddfb9f76a8f76fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS.png" title="">                </div>                <div class="image-caption">DNS.png</div>            </figure><p>这些数据散布在很多DNS服务器上</p><p>WIFI 路由器连接的所有设备组成了局域网LAN，局域网再连接到广域网WAN，广域网的路由器属于你的互联网提供商ISP<br>广域网先连接到一个区域性路由器（覆盖一个街区），然后连接到一个更大的WAN（覆盖整个城市），最终到达<strong>互联网主干</strong>（由一群超大型，带宽超高路由器组成）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-3f8be06893441231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网.jpg" title="">                </div>                <div class="image-caption">网.jpg</div>            </figure><h2 id="万维网-world-wide-web">万维网 world wide web</h2><ul><li><p>互联网是传递数据的管道，传播最多数据的程序是万维网<br><strong>万维网的基本单位是页面</strong></p></li><li><p>页面有内容，有去往其他页面的链接–<strong>超链接</strong>，这些超链接形成巨大的互联网络<br>文字超链接–超文本（关联式索引）</p></li><li><p>为了使网页相互连接，每个网页需要一个唯一的地址–统一资源定位器 URL</p></li></ul><p><a href="http://xn--youtube-ri9ko68a3zbl11jdo3d4zpukhkm45l.com" target="_blank" rel="noopener">👉在浏览器里输入youtube.com</a>，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求，连接到这个IP，这个地址运行着“网络服务器”，网络服务器的标准端口是80端口，下一步是向服务器请求更进一步的页面（这里会用超文本传输协议HTTP：例如GET，还有状态码），例如向服务器发送指令“GET/courses”，服务器收到后会返回该地址对应的网页，然后浏览器会渲染到屏幕上。</p><p>👇超文本标记语言 HTML</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-3e6be56d854e7453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTML.png" title="">                </div>                <div class="image-caption">HTML.png</div>            </figure><p>网页浏览器可以和网页服务器沟通<br>浏览器获取网页和媒体，并负责显示<br>人工编辑目录–&gt;搜索引擎–&gt;搜索算法<br>网络中立性：所有的数据包平等，优先级相同</p><h2 id="计算机安全">计算机安全</h2><p>Secrety,Integrity,Availability<br>保密性，完整性，可用性</p><p>威胁模型分析：以能力水平区分</p><p>💡身份认证：</p><ul><li>你知道什么：用户名/密码–复杂组合（暴力攻击）</li><li>你有什么：用户有特定物品，如钥匙🔑和锁🔒</li><li>你是谁：生物识别–但有概率性，不能重设<br>建议“双因素”，“多因素”认证</li></ul><p>💡访问控制：通过权限或访问控制列表ACL来实现</p><ul><li>权限有：Read，Write，Execute</li><li>有很多种访问控制模型，例如：Chinese wall model，Biba model</li></ul><p>例如美国的模型：</p><ul><li>不能“读上”，读更高等级的内容</li><li>不能“写下”，改更低等级的文件（确保顶级机密不外泄）</li></ul><p>其他措施：安全大会，安全行业的来审计代码,安全型代码一般开源</p><h2 id="黑客与攻击">黑客与攻击</h2><ul><li><p>社会工程学：欺骗别人让别人泄露信息</p></li><li><p>配置别人的系统</p></li><li><p>网络钓鱼：邮件发送连接</p></li><li><p>假托：（电信诈骗）</p></li><li><p>邮件里带木马：恶意软件伪装成照片等</p></li><li><p>NAND镜像：暴力攻击被罚时时，增加几根线复制内存，罚时时覆盖内存继续尝试</p></li><li><p>漏洞利用：远程攻击需要攻击者利用系统漏洞来获得某些能力或访问权限</p><p>例如：缓冲区溢出：溢出部分改掉重要值，例如修改权限admin（应对方法：边界检查，随机存放变量在内存中的位置，金丝雀：缓冲区后面跟踪变化）</p></li><li><p>代码注入：攻击用数据库的网站</p><p>结构化查询语言SQL，一种流行的数据库API<br><img src="https://upload-images.jianshu.io/upload_images/20644861-d24ec3c699bedb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SQL.png"></p><p>DROP TABLE users，删掉用户这张表。凉凉</p><p>应对：检测特殊字符…</p></li><li><p>蠕虫：恶意程序在电脑间互相传播，这些电脑组成僵尸网络</p></li><li><p>DDoS：僵尸网络里的所有电脑发一大堆垃圾信息，堵塞网络</p></li></ul><h2 id="密码学">密码学</h2><ul><li>明文和密文的转化叫加密和解密</li></ul><h3 id="对称加密">对称加密</h3><p>（密钥一样）</p><p>双方都知道密钥：</p><ul><li>替换加密（字母出现的频率相同，例如<strong>凯撒加密</strong>）和移位加密（列移位加密）</li><li>加密机器：<strong>英格玛</strong>（转子，一种映射，映射随着每次按键而改变）</li><li>硬件加密-&gt;软件加密</li><li>数据加密标准DES，二进制密钥，56bits，暴力破解</li><li>高级加密标准<strong>AES</strong>，更长的密钥，128,192,256bits</li></ul><p>密钥交换：</p><ul><li>不发送密钥，“单向函数-模幂运算”，如同颜色混合，自己算出密钥</li></ul><h3 id="非对称加密">非对称加密</h3><ul><li>有两个不同的密钥：一个公开一个私有</li><li>知道公钥只能加密不能解密，公钥加密后只能用私钥解密</li><li>私钥加密也可以用公钥解密，只有有私钥的人能加密，防伪造</li><li>非对称加密RSA，公钥密码学</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;人机交互&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;计算机网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 1）</title>
    <link href="http://pluto-wei.github.io/2020/01/31/Crash-Course-Computer-science-%E7%AC%94%E8%AE%B0%201/"/>
    <id>http://pluto-wei.github.io/2020/01/31/Crash-Course-Computer-science-%E7%AC%94%E8%AE%B0%201/</id>
    <published>2020-01-31T03:53:23.000Z</published>
    <updated>2020-02-02T05:47:00.413Z</updated>
    
    <content type="html"><![CDATA[<p><strong>硬件Hardware</strong><br><strong>软件Software</strong></p><p><em><a id="more"></a></em></p><h1>硬件Hardware</h1><p>继电器，真空管，晶体管<br>二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门）<br>算术存储单元ALU（算术单元和逻辑单元）<br>集成电路（都是晶体管组成的）</p><h2 id="锁存器">锁存器</h2><p>（存储一个位）0 1</p><h2 id="寄存器">寄存器</h2><ul><li>（一组锁存器） 8位寄存器 16 32 64<br>写入寄存器前要先启用里面所有的锁存器（允许写入线）</li><li>存大量寄存器：矩阵排列<br><strong>例如16×16网格的锁存器</strong><br>通过行列的某根线还可以确定到某个确定的锁存器来启动</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-c933cad517e63957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="emm.png" title="">                </div>                <div class="image-caption">emm.png</div>            </figure><p>允许写入线，允许读取线，数据线 连接所有的锁存器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-599ac4cb2325c885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多路复用器.png" title="">                </div>                <div class="image-caption">多路复用器.png</div>            </figure><ul><li><p><strong>again 把256位内存作为一个整体</strong><br>（通过8位地址能储存256个数据？错，每一个位置上是一个0或者1，整体表示一个数据，有256个二进制数（也不是256种可能性，而是$2^{256}$））</p><p><img src="https://upload-images.jianshu.io/upload_images/20644861-09608d5675fc2437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="256位内存.png"></p></li><li><p>8位就是一个字节（这里都是单位，八位的字节包含8个二进制数）<br>一个字节有$2^{256}$种0和1的可能性</p></li><li><p><strong>把8个256位内存排一排</strong><br>存储8个数，给他们相同的地址<br>于是一个8位的地址可以存取一个8位数，<br>（这里好奇怪 无法理解：）</p></li></ul><blockquote><p>又把这个256位内存叫一位（可能是一位数字的意思？），把8个这样的内存排一排叫1字节？<br>为了存储这样的一个8位数，我们同时给8个256位内存一样的地址（如图）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/20644861-7e1efc4a48e425f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8位数字.png"></p><p>嗷，懂了，这样就能存储一个8位数了！地址是8位<br>Think about it :一位数相当于有256种可能性，$2^{256^8}=2^{2^{64}} $</p><h2 id="整体的可寻址内存">整体的可寻址内存</h2><ul><li><strong>RAM–随机存取存储器</strong><br>8位的地址<br>256个地址 每个地址可以读或写一个8位值（8 bits=$2^8$种）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-b9d7795a2b02153d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RAM.png" title="">                </div>                <div class="image-caption">RAM.png</div>            </figure><ul><li>前四位是操作码（OPCODE：LOAD ADD）<br>后四位是内存地址（if is LOAD）</li></ul><h2 id="CPU–中央处理器（指令和程序）">CPU–中央处理器（指令和程序）</h2><ul><li>中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</li><li>组成 <strong>ALU  控制单元  RAM  时钟</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-e145987f4f2f5bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU.png" title="">                </div>                <div class="image-caption">CPU.png</div>            </figure><ul><li><strong>取址–&gt;解码–&gt;执行</strong></li><li>可操作的指令有 LOAD ADD SUB JUMP HALT</li><li>英特尔集成4004，第一个集成CPU 有46条指令<br>现代CPU有上千个指令和指令变种，有各种巧妙复杂的电路<br>一秒十亿条指令</li></ul><h2 id="高级CPU设计">高级CPU设计</h2><ul><li><p>缓存</p><p>在RAM中取一整块存在CPU内部，方便数据的存取。<br>CPU与RAM中间只有一根数据线，效率较低<br>当数据有改变时，通过检测<strong>脏位</strong>，将数据同步给RAM</p></li><li><p>提高效率</p><p>并行处理，同时用上CPU中的取址，解码，执行</p></li><li><p><strong>高端处理器</strong></p><p>会猜测JUMP的下一步，进行推测执行</p></li><li><p><strong>超标量处理器</strong></p><p>一个时间周期完成多条指令</p><p><code>优化**一个指令流**的吞吐量</code><br>一个CPU中有多个ALU</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-eae2e80b8ab973f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU2.png" title="">                </div>                <div class="image-caption">CPU2.png</div>            </figure><ul><li><p><strong>多核处理器</strong></p><p>同时运行<strong>多个指令流</strong><br>一个CPU芯片中，有多个独立处理单元</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-854b2e98e87de910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU3" title="">                </div>                <div class="image-caption">CPU3</div>            </figure><ul><li><p><strong>2个/4个CPU</strong><br>多核不够时可以用多个CPU</p></li><li><p><strong>超级计算机</strong><br>神威太湖之光有40960个CPU，每个CPU有256个核心，每个核心的频率是1.56GHz，每秒钟可以进行9.3亿亿次浮点运算</p></li></ul><h2 id="集成电路">集成电路</h2><p>锗-&gt;硅</p><ul><li><strong>早期 IC 几个晶体管</strong>：把简单电路（逻辑门）封装成单独组件<br><strong>印刷电路板PCB</strong>：通过蚀刻金属线把零件连接在一起</li><li><strong>光刻</strong>：用光把复杂图案印在材料上，如半导体<br>用晶圆做基础，把复杂的金属电路放在上面集成所有东西–氧化层–光</li><li><strong>刻胶</strong>–光掩膜，金属化</li><li>光刻还可以制作电阻 电容<br>一片晶圆可以做很多 IC，整块做完后切割包进微型芯片<br>芯片的核心是 IC</li><li><strong>摩尔定律</strong>：每两年左右，材料和制造技术的发展，同样的空间大小，能塞进两倍数量的晶体管<br><strong>超大规模集成 VLSI 软件</strong>：用来自动生成芯片设计</li></ul><h1>软件Software</h1><h2 id="早期编程方式">早期编程方式</h2><p>程序怎么进入内存？？</p><ul><li><p>一.纸卡</p><p><strong>最早的编程</strong>雅卡尔织布机<br>早期汇总机–不算计算机，只汇总数据（穿孔纸卡），不能编程</p></li><li><p>二.插线板</p><p><strong>Control panel 控制面板–插线板–&gt;可拔插</strong><br>有很多小插孔，可以插电线，让机器的不同部分可以相互传数据和信号<br>世界上第一台通用电子计算机ENIAC–用插线板编程</p><p><strong>存取程序计算机</strong><br>程序和数据都存在–冯诺伊曼结构<br>一个处理器（有算术逻辑单元），数据寄存器，指令寄存器，指令，内存（负责存数据和指令）</p></li><li><p>三.面板编程<br>大量使用开关</p></li></ul><h2 id="编程语言-Software">编程语言(Software)</h2><p>二进制是处理器的母语（机器语言，机器码）<br>对程序的高层次描述–<strong>伪代码</strong></p><ul><li><strong>汇编器</strong><br>读取汇编语言的写的程序。然后转成机器码<br>自己搞定跳转地址（插入可跳转标签）<br>一般一条机器指令对应一条机器指令</li><li><strong>编译器</strong><br>专门把高级语言转成低级语言(汇编或机器码)<br>一行高级编程语言，可能转成几十条二进制指令<br>程序员只需要创建变量–代表内存地址的抽象</li><li><strong>解释器</strong><br>运行时进行转换，而编译器是运行前转换</li></ul><h2 id="编程基础（语句和函数）">编程基础（语句和函数）</h2><ul><li>语法–规定句子结构的一系列规则<br>赋值语句，if语句，循环语句，把代码打包成函数（子程序）</li><li><strong>算法</strong>–解决问题的具体步骤<br>排序：选择排序$n^2$，归并排序$nlogn$<br>图搜索（找最佳路线）：Dijkstra算法</li><li><strong>算法的复杂度</strong>–算法的输入大小和运行步骤</li></ul><h2 id="数据结构">数据结构</h2><ul><li><code>数组</code>（列表，也叫向量）</li><li><code>字符串</code>（数组的亲戚）：字母 数字 标点符号</li><li><code>矩阵</code>（二维数组，数组的数组）</li><li><code>结构体</code>（多个变量打包，多个不同类型数据放在一起）</li><li><code>链表</code>（一个灵活的数据结构，能存很多个节点）：容易重新排序，插入，两端缩减，倒序<br>很多复杂的数据结构也用链表：队列和栈</li><li><code>队列</code>：先进先出</li><li><code>栈</code>：后进先出</li><li><code>树</code>（把一个节点的指针变成多个指针）：根节点，子节点，母/父节点（直属上层节点），叶节点（树结束的地方）<br>二叉树：节点最多只有两个子节点<br>甚至节点可以用链表来存储你所有的子节点<br>树的特点：根到叶是单向的</li><li><code>图</code>：数据随意连接，包括循环。用有多个节点的指针表示，可随意指向</li><li><code>红黑树和堆</code>？</li></ul><h2 id="计算机科学之父–图灵">计算机科学之父–图灵</h2><ul><li><code>图灵机</code>：规则，状态和纸带<br>停机问题 无法解决<br>提出智能，图灵测试（验证码）</li></ul><hr><h2 id="软件工程">软件工程</h2><ul><li>把函数打包成层级，把相关代码都放在一起，打包成对象</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-1415b9e1715a2dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象.png" title="">                </div>                <div class="image-caption">对象.png</div>            </figure><ul><li>对象可以包含其他对象，函数 和变量</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-fc0f7bef9c874a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象2.png" title="">                </div>                <div class="image-caption">对象2.png</div>            </figure><ul><li><p>把函数打包成对象的思想叫面向对象编程 Object Oriented Programming</p></li><li><p>文档 （帮助理解代码都做了什么）以及定义好的程序编程接口API<br>API 控制哪些函数和数据让外部访问，哪些仅供内部</p></li><li><p>面向对象的编程语言可以指定函数是private/public，隐藏复杂度，选择性的公布</p><hr></li><li><p>集成开发环境 IDE</p><p>debug 调试<br>写文档 README</p></li><li><p>源代码管理（版本控制）</p><p>把代码放在一个中心服务器上，叫做代码仓库<br><strong>Code repository</strong><br>check out，commit（提交）<br>master（代码的总版本）<br>质量保证测试 QA<br>β版本软件（快完成时向公众发布）免费的QA团队<br>alpha版本（只在公司内部测试）</p></li></ul><h2 id="操作系统OS"><strong>操作系统OS</strong></h2><ul><li>操作硬件的特殊权限，可以运行和管理其他程序 （1950年代）<br>操作系统充当硬件和软件之间的媒介<br>操作系统提供API来抽象硬件，叫设备驱动程序</li><li><strong>批处理</strong>（连续进行多个程序，自动加载程序）–&gt;在单个CPU上同时运行几个程序–&gt;<strong>多任务处理</strong>（给每个程序分配专属内存块，内存地址的虚拟化，内存保护）–&gt;分时操作系统（处理多个用户）</li><li><strong>Multics</strong>（功能太多）–&gt;<strong>Unix</strong>（把操作系统分为两个部分：内核（内存管理，多任务输入输出处理）和一堆有用的工具（例如程序和运行库），功能并不是很全面，内存崩溃时“恐慌”）–&gt;<strong>Windows</strong>（早期经常蓝屏）–&gt;<strong>Mac OS X,Linux,iOS,Android</strong></li><li>多任务，虚拟内存，内存保护</li></ul><h2 id="内存-储存介质">内存&amp;储存介质</h2><ul><li><p>存储介质</p><p><strong>打孔纸卡，打孔纸带</strong>–&gt;<strong>延迟线存储器</strong>（扬声器压力波/金属线的震动，顺序存储器/循环存储器）–&gt;<strong>磁芯存储器</strong>（可访问某一特定位置）–&gt;<strong>磁带</strong>–&gt;<strong>磁鼓</strong>储存器–&gt;<strong>硬盘</strong>（机械硬盘，固态硬盘SSD）–&gt;<strong>软盘</strong>–&gt;密度更高的软盘（Zip Disks）–&gt;<strong>光学存储器</strong>（光盘CD，DVD）光盘表面有很多小坑，造成光的不同反射，光学传感器捕获并解码为1和0</p></li></ul><h2 id="文件与文件系统">文件与文件系统</h2><ul><li><p>文件格式：</p><p>TXT（文本）WAVE（音频，振幅） Bitmap.bmp（图片，像素块：红绿蓝）<br>元数据（类型，图片宽度，图片高度，深度）+Date</p></li><li><p>怎么储存文件</p><p>为了存多个文件，需要一个特殊文件记录文件的位置（文件目录，通常在最开头）</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-b49c23d7d7f7a0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件目录.png" title="">                </div>                <div class="image-caption">文件目录.png</div>            </figure><ul><li><p>文件系统专门负责管理文件</p></li><li><p>平面文件系统：</p><p>（文件都在同一个目录里）<br>分配块–增大或减小<br>碎片处理–把数据来回移动，排列成正确的数据</p></li><li><p>分层文件系统</p><p>目录文件不仅要指向文件，还要指向目录</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-2ef3de91bab67389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根目录.png" title="">                </div>                <div class="image-caption">根目录.png</div>            </figure><h2 id="压缩-Compression">压缩 Compression</h2><p>把数据占用的空间压到更小<br>作用：高效储存图片，音乐，视频</p><ul><li><p>无损压缩</p><p><strong>消除冗余</strong> <strong>游程编码</strong>适合经常出现相同值的文件<br><strong>用更紧凑的表示方法</strong> <strong>字典编码</strong><br>GIF,PNG,PDF,ZIP</p></li><li><p>有损压缩</p><p><strong>感知编码</strong><br>用不同的精度编码不同的频段<br>例如<strong>声音</strong>，超声波/低音<br>FLAC / WAV --&gt; MP3<br>有损压缩文件格式<br>JPEG<br><strong>视频</strong>，每一帧，时间冗余，只存变化的部分，补丁的移动和转换<br>MPEG-4</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;硬件Hardware&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;软件Software&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://pluto-wei.github.io/2019/11/18/hello-world/"/>
    <id>http://pluto-wei.github.io/2019/11/18/hello-world/</id>
    <published>2019-11-17T16:28:39.391Z</published>
    <updated>2020-02-01T17:00:58.231Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start">Quick Start</h2><h3 id="Create-a-new-post">Create a new post</h3><p><em><a id="more"></a></em></p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server">Run server</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;Quick-Start&quot;&gt;Quick Start&lt;/h2&gt;
&lt;h3 id=&quot;Create-a-new-post&quot;&gt;Create a new post&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
