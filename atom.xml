<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pluto-wei</title>
  
  <subtitle>Hello,nice to meet you!</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="http://pluto-wei.github.io/"/>
  <updated>2020-06-27T16:44:33.122Z</updated>
  <id>http://pluto-wei.github.io/</id>
  
  <author>
    <name>Pluto-wei</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux2</title>
    <link href="http://pluto-wei.github.io/2020/06/27/Linux2/"/>
    <id>http://pluto-wei.github.io/2020/06/27/Linux2/</id>
    <published>2020-06-27T15:52:43.000Z</published>
    <updated>2020-06-27T16:44:33.122Z</updated>
    
    <content type="html"><![CDATA[<p>Vim，Shell，正则 …</p><a id="more"></a><p>后面好多都不想看了，先跳了…明天开始肝别的。最近玩的时间太多了。。。</p><h1>文本编辑器 Vim</h1><ul><li>vim常用操作</li></ul><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vi 进入命令模式  插入模式  编辑模式</span><br><span class="line">esc 从INSERT模式退出</span><br><span class="line">插入命令  aio</span><br><span class="line">定位  :  set nu  :n  $  0  G  g</span><br><span class="line">删除  x  nx  dd  ndd</span><br><span class="line">复制和剪切  yy-p  dd-p</span><br><span class="line">替换和恢复  r/R  u</span><br><span class="line">搜素和替换 /+关键词 n下一个 :指定范围/要替换的关键词和字符串/替换为/g</span><br><span class="line">保存退出  :wq  ZZ  :q!  :wq!</span><br><span class="line"></span><br><span class="line">:set ic 忽略大小写</span><br><span class="line"><span class="meta">%</span><span class="bash">s 全文(搜素)</span></span><br><span class="line">:w [new_filename] 另存为</span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NruWYn.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NrMugx.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1>软件包管理</h1><h2 id="软件包分类">软件包分类</h2><ul><li>源码包 （脚本安装包 .c文件）</li><li>二进制包（别名RPM包，系统默认包）（相当于.exe文件）（写有安装界面）</li></ul><h2 id="rpm">rpm</h2><ul><li><p>命名</p><p>全名=包名-版本-发布次数.适合的Linux平台.适合的硬件平台.扩展名rpm</p></li><li><p>RPM包依耐性：树形依赖，环形依赖，模块依赖</p></li></ul><h2 id="sudo">sudo</h2><figure class="highlight actionscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="keyword">get</span> install &lt;name&gt; </span><br><span class="line"><span class="comment">//安装某一命令</span></span><br></pre></td></tr></tbody></table></figure><p>（6.9-9.3跳过）</p><h1>Shell基础</h1><h2 id="shell概述">shell概述</h2><ul><li><p>编程语言</p></li><li><p>分为Bourne（bash，sh）和C</p></li></ul><figure class="highlight dockerfile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/shells可以看有哪些<span class="keyword">shell</span></span><br></pre></td></tr></tbody></table></figure><h2 id="shell脚本的执行方式">shell脚本的执行方式</h2><figure class="highlight taggerscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo "Hello world!!"</span><br><span class="line">echo -e "a<span class="symbol">\t</span>b<span class="symbol">\b</span>c<span class="symbol">\t</span><span class="symbol">\n</span><span class="symbol">\a</span><span class="symbol">\x</span>64"</span><br><span class="line">echo -e "<span class="symbol">\e</span>[1;31m abcd <span class="symbol">\e</span>[0m"</span><br><span class="line"></span><br><span class="line">-e 支持反斜线控制的字符转换</span><br></pre></td></tr></tbody></table></figure><figure class="highlight d"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi hello.sh</span><br><span class="line"><span class="meta">#!/bin/bash  注意是小写是小写</span></span><br><span class="line">...</span><br><span class="line">chmod <span class="number">755</span> hello.sh</span><br><span class="line">./hello.sh <span class="comment">//直接运行,(不能直接文件名哦)</span></span><br><span class="line">bash hello.sh <span class="comment">//通过Bash调用执行脚本</span></span><br><span class="line">(命令都是小写)</span><br></pre></td></tr></tbody></table></figure><figure class="highlight makefile"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">不能识别wins的文件:</span></span><br><span class="line">dos2unix</span><br></pre></td></tr></tbody></table></figure><h2 id="Bash的基本功能">Bash的基本功能</h2><ul><li><p>历史命令 history  [-c清空 -w保存入文件]</p><p>!字串 重复执行最后一条以该字串开头的命令</p></li><li><p>命令补全 Tab</p></li><li><p>命令别名</p><p>alias 别名=‘原命令’</p><p>alias   //查询别名</p></li><li><p>别名永久生效  vi /root/.bashrc</p></li><li><p>常用快捷键</p><p>Ctrl+C 终止</p><p>Ctrl+L 清屏</p><p>Ctrl+U 删除或剪切</p><p>Ctrl+Y 粘贴</p><p>Ctrl+R 搜素</p><p>Ctrl+D 退出终端</p></li><li><p>输入输出重定向（命令行与文件）</p><p>命令 &amp;&gt;&gt;文件  追加，正确错误一个文件</p><p>命令 &gt;&gt;[文件1]  2&gt;&gt;[文件2]</p><p>命令 &amp;&gt;&gt;/dev/null   //垃圾箱</p><p>输出重定向 wc &gt; 文件  // 统计行数，字节数，单词数</p></li><li><p>多命令顺序执行</p><p>;  &amp;&amp;  ||</p><p>命令 &amp;&amp; echo yes || echo no</p></li><li><p>管道符</p><p>命令1 | 命令2   命令1的正确输出作为命令2的输入</p><p>grep [选项] 搜索内容</p></li><li><p>通配符–匹配文件名</p><p>?  匹配一个任意字符*  匹配0个或任意多个字符</p><p>[]  匹配中括号中任意一个字符</p><p>[-] 匹配括号中任意一个字符 -代表范围  [a-z]</p><p>[^] 不是括号内的一个字符  [ ^0-9]</p><figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ls</span> [^<span class="number">0</span>-<span class="number">9</span>]<span class="keyword">abc</span></span><br><span class="line"><span class="keyword">ls</span> *<span class="keyword">abc</span></span><br><span class="line"><span class="keyword">ls</span> *<span class="keyword">abc</span>*</span><br><span class="line"><span class="keyword">ls</span> ?<span class="keyword">abc</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>其他特殊符号</p><p>#注释</p><p>’ ’ 单引号 中没有特殊字符</p><p>" " 双引号  $调用变量的值 `引用命令  \转义符  有特殊含义</p><p>` = $( ) 反引号 调用系统命令</p></li></ul><hr><p>（10.4-10.6跳过）</p><p>Bash的变量 Bash的运算符 环境变量配置文件</p><h1>Shell编程</h1><h2 id="正则表达式">正则表达式</h2><ul><li>正则在文件中匹配，通配符匹配符合条件的文件名</li><li>正则包含匹配 通配符完全匹配</li><li>ls，find，cp等不支持正则，只能使用shell自己的通配符</li><li>grep，awk，sed等支持正则</li></ul><figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>前一个字符匹配0/n次</span><br><span class="line">. 除了换行以外任意字符(相当于?)</span><br><span class="line">^ 匹配行首 ^hello(以hello开头)</span><br><span class="line">$ 匹配行尾</span><br><span class="line">[] 匹配指定的任意一个字符，一个</span><br><span class="line">[^] 以外的任意一个，一个</span><br><span class="line">\ 转义符</span><br><span class="line">\{n\} 表示其前面的字符恰好出现n次 [<span class="string">0-9</span>]\{4\}  [<span class="string">1</span>][<span class="symbol">3-8</span>][<span class="string">0-9</span>]\{9\}</span><br><span class="line">\{n,\} 表示前面的字符出现不小于n次</span><br><span class="line">\{n,m\} 表示前面的字符出现[n,m]次</span><br></pre></td></tr></tbody></table></figure><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> -n 匹配一行 标号</span><br><span class="line"><span class="keyword">grep</span> <span class="string">"a*"</span>  xx.txt  <span class="comment">//全文(感觉没什么意义)</span></span><br><span class="line"><span class="keyword">grep</span> <span class="string">"s..d"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> <span class="string">"s.*d"</span> xx.txt <span class="comment">//.*就是任意，什么都可以，没有也可以</span></span><br><span class="line"><span class="keyword">grep</span> <span class="string">"^M"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> <span class="string">"n$"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">"^$"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">"[0-9]"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">"^[a-z]"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">"^[^a-zA-Z]"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">"\.$"</span> xx.txt</span><br><span class="line"><span class="keyword">grep</span> -n <span class="string">".$"</span> xx.txt <span class="regexp">/非空白行</span></span><br></pre></td></tr></tbody></table></figure><h2 id="字符截取命令">字符截取命令</h2><figure class="highlight coq"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cut</span> [选项] 文件名 //提取指定列</span><br><span class="line">-f列号  -d分隔符(按照指定分隔符分割列) (\t)</span><br><span class="line"></span><br><span class="line"><span class="built_in">cut</span> -f <span class="number">2</span>,<span class="number">4</span> student.txt</span><br><span class="line"><span class="built_in">cut</span> -d <span class="string">":"</span> -f <span class="number">1</span>,<span class="number">3</span> /etc/passwd</span><br><span class="line">cat /etc/passwd | <span class="type">grep</span> /bin/bash | <span class="type">grep</span> -v root | <span class="type">cut</span> -d <span class="string">":"</span> -f <span class="number">1</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span> '输出类型输出格式' 输出内容</span><br><span class="line"><span class="built_in">printf</span> '<span class="built_in">%s</span> <span class="built_in">%s</span> <span class="built_in">%s</span>\n'</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk命令</span><br></pre></td></tr></tbody></table></figure><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed命令</span><br></pre></td></tr></tbody></table></figure><h2 id="字符处理命令">字符处理命令</h2><h2 id="条件判断">条件判断</h2><h2 id="流程控制">流程控制</h2><ul><li>if</li><li>case</li><li>for</li><li>while</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Vim，Shell，正则 …&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://Pluto-wei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux 常用命令操作</title>
    <link href="http://pluto-wei.github.io/2020/06/26/Linux/"/>
    <id>http://pluto-wei.github.io/2020/06/26/Linux/</id>
    <published>2020-06-25T16:41:58.000Z</published>
    <updated>2020-06-27T04:21:49.957Z</updated>
    
    <content type="html"><![CDATA[<p>一点点Linux的命令，待续…</p><a id="more"></a><p>6.22-6.25</p><p><a href="https://www.bilibili.com/video/BV1mW411i7Qf" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1mW411i7Qf</a></p><h2 id="基础知识">基础知识</h2><h3 id="Linux系统的文件结构">Linux系统的文件结构</h3><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/bin        二进制文件，系统常规命令,最经常使用的命令</span><br><span class="line">/boot       系统启动分区，系统启动时读取的文件，包括一连接文件以及镜像文件</span><br><span class="line">/dev        设备文件，Linux的外部设备</span><br><span class="line">/etc        所有的系统管理所需要的配置文件和子目录</span><br><span class="line">/home       普通用户的家目录</span><br><span class="line">/lib        存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。</span><br><span class="line">/lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</span><br><span class="line">/media      linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</span><br><span class="line"></span><br><span class="line">/lib64      64位库</span><br><span class="line"></span><br><span class="line">/mnt        系统提供这个目录是让用户临时挂载其他的文件系统，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了。</span><br><span class="line">/opt        第三方软件安装位置，比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</span><br><span class="line"></span><br><span class="line">/proc       进程信息及硬件信息,虚拟的目录,是系统内存的映射,可直接访问这个目录来获取系统信息。</span><br><span class="line">/root       临时设备的默认挂载点，系统管理员的主目录</span><br><span class="line">/sbin       系统管理命令，这里存放的是系统管理员使用的管理程序</span><br><span class="line">/srv        存放一些服务启动之后需要提取的数据</span><br><span class="line">/var        数据,某些大文件的溢出区，比方说各种服务的日志文件</span><br><span class="line">/sys        内核相关信息</span><br><span class="line">/tmp        临时文件</span><br><span class="line">/usr        用户相关设定，类似program files</span><br></pre></td></tr></tbody></table></figure><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/usr</span> 最庞大的目录，要用到的应用程序和文件几乎都在这个目录。其中包含：</span><br><span class="line"><span class="string">/usr/x11r6</span> 存放x window的目录</span><br><span class="line"><span class="string">/usr/bin</span> 众多的应用程序</span><br><span class="line"><span class="string">/usr/sbin</span> 超级用户的一些管理程序</span><br><span class="line"><span class="string">/usr/doc</span> linux文档</span><br><span class="line"><span class="string">/usr/include</span> linux下开发和编译应用程序所需要的头文件</span><br><span class="line"><span class="string">/usr/lib</span> 常用的动态链接库和软件包的配置文件</span><br><span class="line"><span class="string">/usr/man</span> 帮助文档</span><br><span class="line"><span class="string">/usr/src</span> 源代码，linux内核的源代码就放在<span class="string">/usr/src/linux</span>里</span><br><span class="line"><span class="string">/usr/local/bin</span> 本地增加的命令</span><br><span class="line"><span class="string">/usr/local/lib</span> 本地增加的库</span><br></pre></td></tr></tbody></table></figure><h3 id="Linux系统命令行的含义">Linux系统命令行的含义</h3><figure class="highlight clean"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：root@app00:~# </span><br><span class="line">root    <span class="comment">//用户名，root为超级用户</span></span><br><span class="line">@       <span class="comment">//分隔符</span></span><br><span class="line">app00   <span class="comment">//主机名称</span></span><br><span class="line">~       <span class="comment">//当前所在目录，默认用户目录为~，会随着目录切换而变化</span></span><br><span class="line">#       <span class="comment">//表示当前用户是超级用户，普通用户为$</span></span><br></pre></td></tr></tbody></table></figure><h3 id="命令的组成">命令的组成</h3><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">示例：命令 参数名 参数值</span><br></pre></td></tr></tbody></table></figure><h2 id="目录操作">目录操作</h2><figure class="highlight jboss-cli"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> <span class="string">//change</span> directory 切换目录</span><br><span class="line"><span class="keyword">cd</span> [目录]</span><br><span class="line"></span><br><span class="line">/根目录  .该文件夹  <span class="string">..</span>上一级目录  ~home目录  -上次访问的目录</span><br><span class="line">xx<span class="params">(文件夹名)</span> 本目录下的文件夹</span><br><span class="line"><span class="string">/xxx/xx/x</span> 输入完整的路径，直接切换到目标目录，输入过程中可以使用tab键快速补全<span class="params">(从根目录开始)</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ls</span> <span class="selector-attr">[-aldi]</span> <span class="selector-attr">[文件或目录]</span> <span class="comment">//查看目录</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>所有文件 <span class="selector-tag">l</span>详细信息显示 <span class="selector-tag">d</span>目录属性 <span class="selector-tag">i</span><span class="selector-pseudo">:id</span></span><br><span class="line"><span class="selector-tag">u</span>所有者 <span class="selector-tag">g</span>所属组 <span class="selector-tag">o</span>其他人</span><br><span class="line"><span class="selector-tag">r</span>读 <span class="selector-tag">w</span>写 <span class="selector-tag">x</span>执行</span><br></pre></td></tr></tbody></table></figure><figure class="highlight arduino"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> <span class="comment">//make directories 创建新目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p [目录名] [目录名] <span class="comment">//-p 递归创建（否则只有一层）</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span>  //<span class="built_in">print</span> working directory 查看当前目录</span><br></pre></td></tr></tbody></table></figure><figure class="highlight maxima"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> //<span class="built_in">remove</span> empty <span class="built_in">directory</span> 删除空目录</span><br><span class="line"><span class="built_in">rmdir</span> [目录名]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">cp</span>  <span class="comment">//copy 复制文件或目录（目录加-r,可以是非空文件夹）</span></span><br><span class="line"><span class="selector-tag">cp</span> <span class="selector-tag">-r</span> <span class="selector-tag">-p</span> <span class="selector-attr">[源文件或目录]</span> <span class="selector-attr">[目标目录]</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">r</span>复制目录 <span class="selector-tag">p</span>保留文件属性</span><br></pre></td></tr></tbody></table></figure><figure class="highlight cos"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mv</span>  <span class="comment">//move 剪切文件、改名（可以是非空文件夹）修改目录</span></span><br><span class="line"><span class="keyword">mv</span> [原文件或目录] [目标目录]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">rm</span> <span class="comment">//remove 删除文件（目录-r）</span></span><br><span class="line"><span class="keyword">rm</span> -rf [文件或目录]</span><br><span class="line"></span><br><span class="line">r删除目录 f强制执行</span><br></pre></td></tr></tbody></table></figure><h2 id="文件操作">文件操作</h2><figure class="highlight irpf90"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">touch</span> //新增文件</span><br><span class="line"><span class="keyword">touch</span> [文件名]</span><br></pre></td></tr></tbody></table></figure><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cat</span> <span class="comment">//显示文件内容</span></span><br><span class="line"><span class="keyword">cat</span> [文件名]</span><br><span class="line">-<span class="keyword">n</span>标记行号 </span><br><span class="line">tac <span class="comment">//反向列示，不支持-n</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">more</span> <span class="comment">//分页显示文件内容</span></span><br><span class="line"><span class="selector-tag">more</span> <span class="selector-attr">[文件名]</span></span><br><span class="line">(空格)/<span class="selector-tag">f</span>:翻页  (Enter):换行  <span class="selector-tag">q</span>或<span class="selector-tag">Q</span>:退出</span><br><span class="line"><span class="selector-tag">-----------</span> <span class="selector-tag">-------------------------------------------------</span></span><br><span class="line"><span class="selector-tag">less</span> <span class="comment">//分页显示文件内容</span></span><br><span class="line"><span class="selector-tag">less</span> <span class="selector-attr">[文件名]</span></span><br><span class="line">可向上翻页：<span class="selector-tag">page</span> <span class="selector-tag">up</span>,↑</span><br><span class="line">查找 /关键词 <span class="selector-tag">n</span>下一个</span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">head</span> <span class="comment">//显示前几行</span></span><br><span class="line"><span class="selector-tag">head</span> <span class="selector-attr">[-n 20]</span> <span class="selector-attr">[文件名]</span> <span class="comment">//指定行数</span></span><br><span class="line"><span class="selector-tag">tail</span> <span class="selector-attr">[-n 20 -f]</span> <span class="selector-attr">[文件名]</span> </span><br><span class="line"><span class="selector-tag">-f</span> 动态显示文件末尾内容</span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ln</span>  <span class="comment">//link 生成链接文件</span></span><br><span class="line"><span class="selector-tag">ln</span> <span class="selector-attr">[-s]</span> <span class="selector-attr">[原文件]</span> <span class="selector-attr">[目标文件]</span></span><br><span class="line"><span class="selector-tag">-s</span> 生成软链接，否则生成硬链接</span><br><span class="line"><span class="comment">//软链接类似快捷方式，硬链接类似拷贝cp-p并可同步更新，id相同，不针对目录</span></span><br></pre></td></tr></tbody></table></figure><h2 id="权限管理命令">权限管理命令</h2><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chmod</span> <span class="comment">//change the permissions mode of a file改变文件或目录权限</span></span><br><span class="line"><span class="selector-tag">chmod</span> <span class="selector-attr">[{ugoa}{+-=}{rwx}]</span> <span class="selector-attr">[文件或目录]</span></span><br><span class="line"><span class="selector-tag">chmod</span> <span class="selector-attr">[777]</span> <span class="selector-attr">[文件名或目录]</span></span><br><span class="line"><span class="selector-tag">r-4</span> <span class="selector-tag">w-2</span> <span class="selector-tag">x-1</span></span><br><span class="line"><span class="selector-tag">rwxrw-r--</span> <span class="selector-tag">764</span></span><br><span class="line"><span class="selector-tag">-R</span> 递归修改</span><br><span class="line">只有所有者<span class="selector-tag">u</span>和管理员<span class="selector-tag">root</span>可以更改权限</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">file</span><span class="selector-pseudo">:r</span><span class="selector-pseudo">:cat</span>/<span class="selector-tag">more</span>/<span class="selector-tag">head</span>/<span class="selector-tag">tail</span>/<span class="selector-tag">less</span></span><br><span class="line"> <span class="selector-tag">w</span><span class="selector-pseudo">:vim</span></span><br><span class="line"> <span class="selector-tag">x</span><span class="selector-pseudo">:script</span> <span class="selector-tag">command</span></span><br><span class="line"><span class="selector-tag">directory</span><span class="selector-pseudo">:r</span><span class="selector-pseudo">:ls</span></span><br><span class="line">  <span class="selector-tag">w</span><span class="selector-pseudo">:touch</span>/<span class="selector-tag">mkdir</span>/<span class="selector-tag">rmdir</span>/<span class="selector-tag">rm</span></span><br><span class="line">  <span class="selector-tag">x</span><span class="selector-pseudo">:cd</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight less"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">chown</span> <span class="comment">//change file ownership 改变文件或目录的所有者</span></span><br><span class="line"><span class="selector-tag">useradd</span> <span class="selector-tag">xx</span></span><br><span class="line"><span class="selector-tag">chown</span> <span class="selector-attr">[用户]</span> <span class="selector-attr">[文件或目录]</span></span><br><span class="line">只有管理员<span class="selector-tag">root</span>可以操作</span><br><span class="line"><span class="selector-tag">chgrp</span> <span class="comment">//change file froup ownership 改变所属组</span></span><br><span class="line"><span class="selector-tag">groupadd</span> <span class="selector-tag">xx</span></span><br><span class="line"><span class="selector-tag">chgrp</span> <span class="selector-attr">[用户组]</span> <span class="selector-attr">[文件或目录]</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">umask [-S] <span class="comment">//显示设置文件的缺省(default)权限</span></span><br><span class="line">mkdir的文件具有 rwxr-xr-x(目录)</span><br><span class="line">touch的文件在mkdir的基础上去掉x rw-r--r--(文件)</span><br><span class="line"></span><br><span class="line">-S以rwx的形式显示新建文件的缺省权限，否则直接显示数字</span><br><span class="line">umask <span class="number">0022</span>  <span class="number">0</span>:特殊权限 <span class="number">022</span>----w--w- 逻辑异或:rwxr-xr-x(目录)</span><br><span class="line"></span><br><span class="line">umask <span class="number">077</span> <span class="comment">//更改权限成 rwx------(目录)</span></span><br></pre></td></tr></tbody></table></figure><h2 id="文件搜索命令">文件搜索命令</h2><ul><li>find locate which whereis grep</li></ul><figure class="highlight sqf"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span> <span class="comment">//文件搜索</span></span><br><span class="line"><span class="built_in">find</span> [搜索范围] [匹配条件]</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> [目录/] -<span class="built_in">name</span> [文件名]  <span class="comment">//精准搜索</span></span><br><span class="line">-iname 不区分大小写</span><br><span class="line">*内容* <span class="comment">//文件名包含内容，匹配任意字符</span></span><br><span class="line">内容*  <span class="comment">//以内容开头</span></span><br><span class="line">内容???<span class="comment">//内容后有3个字符，?单个字符</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">size</span> +<span class="number">204800</span>  <span class="comment">//大于100MB的文件</span></span><br><span class="line">+n大于 -n小于 n等于</span><br><span class="line"><span class="number">1</span>数据块 <span class="number">512</span>字节 <span class="number">0.5</span>k</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> /home -user [user]</span><br><span class="line"><span class="built_in">find</span> /home -<span class="built_in">group</span> [grp]</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> /home -cmin -<span class="number">5</span></span><br><span class="line">-amin 访问时间 access</span><br><span class="line">-cmin 文件属性 change</span><br><span class="line">-mmin 文案进内容 modify</span><br><span class="line">-<span class="number">5</span> <span class="number">5</span><span class="built_in">min</span>之内</span><br><span class="line">+<span class="number">5</span> 超过<span class="number">5</span>minn</span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">type</span> {fdl} <span class="comment">//文件类型 f文件d目录l软链接文件</span></span><br><span class="line"><span class="built_in">find</span> / -inum <span class="number">23333</span> <span class="comment">//i节点 文件名很奇怪的时候“”</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">size</span> +<span class="number">163840</span> -a -<span class="built_in">size</span> -<span class="number">204800</span></span><br><span class="line">-a 同时满足<span class="built_in">and</span> </span><br><span class="line">-o 二者之一<span class="built_in">or</span></span><br><span class="line"><span class="built_in">find</span> / -<span class="built_in">name</span> [] -<span class="built_in">exec</span> [操作ls -l] {} \;</span><br><span class="line">-<span class="built_in">exec</span>/-ok 命令 {} \; 对搜素结果执行操作</span><br></pre></td></tr></tbody></table></figure><figure class="highlight gauss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">locate</span> <span class="comment">//速度快，在文件资料库中查找文件</span></span><br><span class="line">updatedb <span class="comment">//更新文件资料库(root权限)(对tmp临时文件无效)</span></span><br><span class="line"><span class="keyword">locate</span> -i xx 不区分大小写</span><br></pre></td></tr></tbody></table></figure><figure class="highlight stata"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">which</span> <span class="comment">//搜素命令所在目录及别名信息</span></span><br><span class="line"><span class="keyword">which</span> [cp/<span class="keyword">ls</span>]</span><br><span class="line">whereis <span class="comment">//搜索命令所在目录以及帮助文档路径</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight gradle"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grep</span> <span class="comment">//文件内容中搜素</span></span><br><span class="line"><span class="keyword">grep</span> -iv [指定字串] [文件]</span><br><span class="line">-i 不区分大小写</span><br><span class="line">-v 排除指定字串</span><br><span class="line"></span><br><span class="line"><span class="keyword">grep</span> -v ^# <span class="regexp">/etc/i</span>nittab <span class="comment">//排除以#开头的行</span></span><br></pre></td></tr></tbody></table></figure><h2 id="帮助命令">帮助命令</h2><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">man</span> <span class="string">//manual 获得帮助信息</span></span><br><span class="line"><span class="attr">man</span> <span class="string">[命令或配置文件]</span></span><br><span class="line"><span class="meta">命令</span>: <span class="string">NAME 作用 /选项</span></span><br><span class="line"><span class="meta">配置文件</span>: <span class="string">NAME 存放信息文件格式，直接写文件名，不需要写绝对路径</span></span><br><span class="line"><span class="attr">1</span> <span class="string">命令的帮助 5 配置文件的帮助 (同名的时候)  例:man 5 passwd</span></span><br><span class="line"></span><br><span class="line"><span class="attr">whatis</span> <span class="string">命令 apropos 配置文件(简短介绍信息)</span></span><br><span class="line"><span class="attr">xx</span> <span class="string">--help  选项信息</span></span><br><span class="line"><span class="attr">info</span> <span class="string">与man类似</span></span><br><span class="line"><span class="attr">date</span> <span class="string">查看时间</span></span><br><span class="line"><span class="attr">man</span> <span class="string">date 更改系统时间</span></span><br><span class="line"><span class="attr">help</span> <span class="string">[命令] //获得shell内置命令的帮助信息(找不到路径) 例:help umask</span></span><br></pre></td></tr></tbody></table></figure><h2 id="用户管理命令">用户管理命令</h2><figure class="highlight 1c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">useradd 用户名 <span class="comment">//添加新用户</span></span><br><span class="line">passwd 用户名 <span class="comment">//password设置用户密码，root任何人，passwd改自己密码</span></span><br><span class="line">who <span class="comment">//查看登录用户名，登录终端，tty本地终端，pts远程终端，登录时间，IP地址</span></span><br><span class="line">w <span class="comment">//比who还能获得当前系统时间，连续运行时间uptime，几个用户登录，负载均衡指数</span></span><br></pre></td></tr></tbody></table></figure><h2 id="压缩解压命令">压缩解压命令</h2><figure class="highlight properties"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">.gz</span></span><br><span class="line"><span class="attr">gzip</span> <span class="string">//压缩文件，不能压缩目录，tar且不保留原文件</span></span><br><span class="line"><span class="attr">gunzip</span> <span class="string">//GNU unzip 解压gz的压缩文件</span></span><br><span class="line"></span><br><span class="line"><span class="attr">tar</span> <span class="string">//打包目录。.tar 再gip压缩成 .tar.gz</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-zcf 压缩后文件名 目录</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-zxvf 解压 压缩包</span></span><br><span class="line"><span class="meta">c打包</span> <span class="string">v显示详细信息 f指定文件名 z打包同时压缩/解压缩 x解包 </span></span><br><span class="line"></span><br><span class="line"><span class="attr">zip压缩文件或目录</span></span><br><span class="line"><span class="attr">zip</span> <span class="string">-r 压缩后文件名 文件或目录</span></span><br><span class="line"><span class="attr">r压缩目录</span></span><br><span class="line"><span class="attr">unzip</span> <span class="string">解压缩</span></span><br><span class="line"></span><br><span class="line"><span class="attr">bzip2</span> <span class="string">-k 文件// 文件格式 .bz2</span></span><br><span class="line"><span class="attr">k是否保留压缩包</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-cjf xx.tar.bz2 xx</span></span><br><span class="line"><span class="attr">bunzip2</span> <span class="string">-k 压缩文件</span></span><br><span class="line"><span class="attr">tar</span> <span class="string">-xjf xx.tar.bz2</span></span><br></pre></td></tr></tbody></table></figure><ul><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/25/NDuLUs.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li></ul><h2 id="网络命令">网络命令</h2><figure class="highlight applescript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span></span><br></pre></td></tr></tbody></table></figure><h2 id="关机重启命令">关机重启命令</h2><figure class="highlight angelscript"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项-h] [时间<span class="number">20</span>:<span class="number">30</span>/now] </span><br><span class="line">-c 取消前一个关机命令</span><br><span class="line">-h 关机</span><br><span class="line">-r 重启</span><br><span class="line">其他关机命令 halt，poweroff，init <span class="number">0</span></span><br><span class="line">其他重启命令 reboot，init <span class="number">6</span></span><br><span class="line">系统运行级别 init <span class="number">0123456</span> 帮助文档 help inittab</span><br><span class="line">查询当前的运行级别 runlevel</span><br><span class="line">改变运行级别 init n</span><br><span class="line">退出登录命令 logout</span><br></pre></td></tr></tbody></table></figure><p>先切换到超级用户 su root</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一点点Linux的命令，待续…&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="Linux" scheme="http://Pluto-wei.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>科目四（驾考）</title>
    <link href="http://pluto-wei.github.io/2020/06/16/drivingLicenseExam/"/>
    <id>http://pluto-wei.github.io/2020/06/16/drivingLicenseExam/</id>
    <published>2020-06-16T05:17:44.000Z</published>
    <updated>2020-06-26T03:12:31.427Z</updated>
    
    <content type="html"><![CDATA[<p>拿到本本了！快落</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NrAJ4f.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>疫情之前✍的一点点👇，虽然后面再考的时候没怎么看笔记</p><p>而且可能没刷过题的看不懂，刷过题的不用看hhh</p><a id="more"></a><p>还被小朋友笑了😡😡😡😤😤😤qsl</p><p>反正我用不上了，就发出来好了。。</p><p>科一的时候差点没过，当时太浑了，细节都记不住hh，科二科三都有写一点点要点总结，就不发了，那个因人而异吧，每个人容易忘记的地方不太一样嗷。科四很顺利就拿本本了，不过从1月23到6月16，推迟了5个月，抢了生日前的最后一场考试。</p><h2 id="第一章-违法行为综合判断与案例分析">第一章 违法行为综合判断与案例分析</h2><h5 id="1-动画有几种违法行为">1.动画有几种违法行为</h5><p><strong>动画456是三种 其他都是两种</strong><br>打电话，不系安全带，占用公交车道通行，行驶中遮挡号牌，超过最高限速行驶，闯红灯，不按导向箭头行驶，酒后驾驶，无证驾驶，遇前方拥挤走应急车道，占用非机动车道右转</p><h5 id="2-某某的主要违法行为">2.某某的主要违法行为</h5><p>醉酒（80mg/100）  超速  疲劳（连续驾驶4小时） 肇事  不按规定会车   不按规定使用灯光  客车超员（大客车47人 中型客车19人）<br>超速（泥泞30公里每小时 冰雪30 弯道30 无信号灯30）(高速公路中型客车[货运车辆]100公里每小时)  （能见度小于50m不超过20km/h，要开5个灯，与同车道保持20是对的）<br>货车超载（核载是允许装载质量)  货车车厢非法载客  逾期未检验  准驾车型不符(A1才能开客车)  驾驶具有安全隐患的机动车  饮酒驾驶（20mg/100） 非法改装机动车   逆向行驶  高速公路停车  占用应急车道</p><h2 id="第二章-安全行车常识">第二章 安全行车常识</h2><p>有裂纹或损伤轮胎–爆胎<br>紧急制动时ABS（防抱死）系统–保持转向能力,防止侧滑和原地掉头，紧急制动时要<strong>用力踏</strong>制动踏板，才能启动ABS系统。但紧急制动的同时转向可能会发生侧滑。制动距离是踩下制动踏板后的轮胎拖印距离，冰雪潮湿路面会变长，一般路面会变短<br>城市道路不得开启远光灯，近光灯可以提高能见度<br>驾车时<strong>迅速</strong>一般是错的<br>安全带只有减轻受伤程度的作用<br>让–减速慢行，停–停车<br>主流在支流左边<br>有障碍的一方让对方先行<br>上坡先行<br>雨天临时停车-危险报警闪光灯<br>远近光灯–急弯 坡路 拱桥 人行横道 没有交通信号灯控制的路口 双向行驶隧道<br>没灯光时可以变换灯光–让其他车辆行人提前预防<br>高速公路加速车道60（-120）<br>雾天在高速公路上发生事故后，车上人员不要随便下车行走（×）  迷惑 反正不能在车里呆着<br>火柴、硫黄和赤磷属于 易燃固体<br>经过铁路道口 一听二看三通过<br>在摩擦系数比较小的路面（比如最常见的冰雪路面上），车辆制动时车轮容易抱死，不能紧急制动（爆胎时也不能），也不能急转向<br>交叉路口、铁路道口、急弯路、宽度不足4米的窄路、桥梁、陡坡、隧道以及距离上述地点50米以内的路段，不得停车<br>机动车在高速公路上行驶，车速超过每小时100公里时，应当与同车道前车保持100米以上的距离。<br>车速低于每小时100公里时，与同车道前车距离可以适当缩短，但最小距离不得少于50米。</p><h2 id="第三章-常见交通标志标线交通手势辨识">第三章 常见交通标志标线交通手势辨识</h2><p>红圈蓝底 ×禁止停车 一条线-可临时 禁止长时间停车<br>哪种车型不能通过-正脸机动车 侧脸小型车<br>牛是牲畜 鹿是野生动物<br>实心是路面高凸 空心是驼峰桥<br>铁路道口 栅栏有人看守 （上面带×和折现就是多股铁路与道路相交）火车头无人看守（一道杠50米）<br><strong>一黑一红为会车让行</strong></p><h2 id="第四章-驾驶职业道德和文明驾驶常识">第四章 驾驶职业道德和文明驾驶常识</h2><h2 id="第五章-恶劣气候和复杂道路条件下驾驶常识">第五章 恶劣气候和复杂道路条件下驾驶常识</h2><p>隧道上面的信号灯是给自己看的<br>下长坡时 挂低速档，用行车制动（踏制动踏板）会使制动器制动效果下降<br>下长坡控制车速 要充分利用<strong>发动机制动</strong><br>山区落石地段要注意观察 尽快通过  没有落石可低速通过<br>上坡路段保持大距离停车<br>上坡要提前减挡<br>上坡临时停车时方向盘左转可以避免机动车后留  下坡方向盘向右打<br>长时间停车要塞东西<br>啥时候都要靠右行驶<br>靠山提的一侧先行–靠悬崖危险</p><h2 id="第六章-紧急情况下避险常识">第六章 紧急情况下避险常识</h2><h2 id="第七章-交通事故救护及常见危化品处置常识">第七章 交通事故救护及常见危化品处置常识</h2><h2 id="第八章-武汉地区题库">第八章 武汉地区题库</h2><p>现场处罚向违法当事人开具–简易处罚决定书<br>缴纳–指定银行网点 易站通 易行江城…（什么都可以）<br>自助处理电子眼的基本条件–200元以下并且12分以下<br>电子眼处理方式–大队窗口 易站通自助机 武汉交警微信/app 支付宝 易行江城（最先不是武汉交警微信）<br>学习减分举措–一个记分周期减3分，只有一次操作机会<br>交管网处理电子眼时适用网银卡–中国银行，建设银行<br>发生车损为撤离交通堵塞–200元处罚<br>在线处理车损–姓名电话 保险公式 事故所在区域<br>上传5张事故照片–位置 车牌号 接触部位 驾驶证 行驶证<br>东西湖区也能快速理赔<br>车损事故理赔时间—7-19<br>财产损失要自行撤离，不能等候<br><strong>最先推出的是武汉交警微信–电子眼是错的 在线处理交通事故是对的</strong></p><p>包扎止血不能用麻绳<br>手势（考的少）！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;拿到本本了！快落&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://s1.ax1x.com/2020/06/26/NrAJ4f.md.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
&lt;p&gt;疫情之前✍的一点点👇，虽然后面再考的时候没怎么看笔记&lt;/p&gt;
&lt;p&gt;而且可能没刷过题的看不懂，刷过题的不用看hhh&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>芜湖</title>
    <link href="http://pluto-wei.github.io/2020/06/13/huhuhu/"/>
    <id>http://pluto-wei.github.io/2020/06/13/huhuhu/</id>
    <published>2020-06-13T07:07:32.000Z</published>
    <updated>2020-06-25T17:00:07.301Z</updated>
    
    <content type="html"><![CDATA[<p><strong>咕咕咕</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NDBP4x.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>总结（碎碎念）又咕咕了</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/ND0IBj.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>把桌面清干净了好快乐！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NDrd3V.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/06/26/NDrtNn.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;咕咕咕&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://s1.ax1x.com/2020/06/26/NDBP4x.md.jpg&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>记第一次面试经历</title>
    <link href="http://pluto-wei.github.io/2020/05/02/interview/"/>
    <id>http://pluto-wei.github.io/2020/05/02/interview/</id>
    <published>2020-05-02T13:51:01.000Z</published>
    <updated>2020-05-03T02:05:14.752Z</updated>
    
    <content type="html"><![CDATA[<p>🎉🎉🎉</p><p><strong>人生</strong>之<strong>大喜大悲</strong></p><p><strong>得之我幸，失之我命</strong></p><a id="more"></a><h1>序</h1><p>🎊—迟到了一周的记事</p><p>👉还是想记一下</p><ul><li>要说也不是第一次面试了，上大学之前似乎没有面试过，当时考外校好像是交了材料以后就没后文了，那些材料也都是我爸帮我准备的，我也不知道有些啥东西。上了大学之后呢，刚开学还是经历了好多，有技术中心部门面试，俱乐部面试，创新创业中心面试，这都是过了的，还有没过的，影像工作室，辩论队。。哎呀这一数还挺多的</li><li>除了某部门面试超划水以外，其他的面试感觉还是挺正规的。形式呢有自我介绍+提问，无领导小组讨论（二面）。每一次都会提前准备，都会紧张。面试前真的都特别特别紧张（跟跑800米之前一样的感觉，即使结果再不重要，我真的没见过跑800米之前比我更紧张的了，从初中高中到大学的所有运动会+测试，即使可以到前3）</li><li>然后呢，这个是第一次线上面试，最大场面，也是最。。大喜大悲吧</li></ul><h1>面试前</h1><ul><li><p>一直在<strong>逃避</strong></p></li><li><p>从公布面试时间到面试有7天左右的时间吧，就一直不愿意想这件事，不想准备，甚至不想参加不想去了。</p></li><li><p>当时找英才dg问了一些课程设置，然后也是有一点劝退吧，基本上已经是决定放弃了。。因为要补很多课啊🍐会很大，而且这个疫情这个情况。。就很纠结</p></li><li><p>小朋友真的是劝了我好久，让我再认真想想</p></li><li><p>然后dl建议我去某乎或者清水河畔了解一下，</p></li><li><p>&amp;&amp;两个小姐妹：冲就完事了</p></li><li><p>然后我就真香了。。。</p><p><img src="http://5b0988e595225.cdn.sohucs.com/images/20190202/87be30c072ca48ed99827e949cfa310e.gif" alt=""></p><hr></li><li><p>既然准备参加了就好好准备吧，毕竟一向认为做一件事又不认真做那还不如不做</p></li><li><p>准备了简历+发言稿，在超级简历里找的一个研究生复试模板</p></li><li><p>$Attention$：一定要自信，说自己擅长的地方，这不是你需要谦虚的时候，你自己都不相信自己可以，那别人凭什么要你？你自己不把闪光点说出来，那别人怎么知道？</p></li></ul><blockquote><p>–：你说的都是你的优点，那你觉得你有什么缺点呢<br>xpy: 经验还不足，阅历不够（年纪小）</p></blockquote><ul><li>具体的我就不说了，还是感谢这学期学的某几个课程做的项目，还有从俱乐部学到的很多东西，让我有那么一点点可以说的。当时自认为简历写的好好啊😂😂结果后来被告知不被参考？？那至少也说明了我的态度吧哈哈（除非他们根本就不打开看），整理了简历之后在写自我介绍也顺手多了</li></ul><h1>大插曲</h1><ul><li><p>由于五一假期调休，本来的两天面试调到一天，第二天调成第一天，说好头一天晚上发面试时间的，结果等到12点都没等到，也没人说发还是不发了</p></li><li><p>第二天10点醒的，当时还没练过怎么自我介绍，收到了消息说下午2：10面试，说的这么具体以为是具体的时间，从11点多种开始就一直进入面试的网站，说我前面还有18个人，一个人10分钟，算起来刚刚好的样子。</p></li><li><p>然后就一直等，等到4个人的时候好像人数就不减少了，2个小时过去了，同学说前面一直有一个人几个小时过了人数都不变？？？</p></li><li><p>结果才知道这前面的人数跟时间都是虚拟时间？？？心态崩了。从12点的超级紧张，到2点钟的不想等了，到3点钟的气愤，4点钟等来了短信，结果硬是等到了5点半才开始？？？</p></li><li><p>真的搞人心态啊？安排一个次序，计算一个面试时间，哪怕是前后1个小时的误差，有那么难吗？？？</p><p><img src="https://s1.ax1x.com/2020/05/03/JxcpHe.th.png" alt=""></p></li></ul><h1>极不顺利的面试</h1><p>接下来就到了大悲环节</p><p>简直就是极不顺利</p><p>👎自我介绍在一下午的等待时间中试过几次，倒是没什么大差错，感觉海星</p><p>但是面试官的问题。。为什么就一个都答不上来呢👇</p><p>（面试官当时是为了一张大桌子，会议室那种，对着你一个摄像头，但是在我的瞩目里面只有一个小屏，我没有放大，没看清他们具体的样子）</p><blockquote><p>Q：你觉得在科研室做科研和在高校做科研有什么不同之处？</p><p>A：blablabla</p><p>Q：我问的是区别，有什么不同的地方？</p><p>Q：我问的是区别！你说的是科研室还是大学？</p><p>Q：你觉得科研室要好？那你说的这些大学都不具备吗？</p><p>A：…</p></blockquote><blockquote><p>Q：你在做五子棋的时候用到了那些具体的算法知识？</p><p>A：极大值极小值搜素…</p><p>Q：极大值极小值在数学上是怎么定义的？</p><p>Q：不我要你说的具体的数学式子</p><p>Q：极大极小思想在物理方面有什么应用？</p><p>A：…</p></blockquote><blockquote><p>Q：你觉得你写一些博客对以后的科研有什么帮助？</p><p>Q：你觉得线性代数中贯穿始终的是什么思想？</p><p>Q：（打断）用一个词来表示</p><p>Q：是空间，。。线性代数里面根本就没有你说的 xx 词</p><p>A：…</p></blockquote><blockquote><p>Q：好了今天的面试就到这里了，右下角可以退出了。。</p></blockquote><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/05/03/Jx2pYd.th.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>就这？就这？就这？？？我还啥都没说出来呢？？？？</p><p>我凉了  我没了 /微笑/微笑</p><hr><p>然后大哭了一场。</p><p>为什么哭？因为白白浪费了一整天的时间，第二天又要上课，唯一的一天休息时间？？就这就这就这？？？还有acm3个小时的讲座没有听，还有别的几门课真的。。掉了好多好多课！！orz！简直气死了，完全已经觉得，这面试官完全没眼光啊！！！不管宁是不是在刁难我，毕竟没答上宁的问题，但是我就是好生气！！！！！！气死了气死了气死了！！！</p><p>面试官就是没有眼光，lj学院有什么了不起，时间管理都没学会，浪费爷一下午，计院他不香吗？？（就当我是吃不到葡萄说葡萄酸，罢了罢了）</p><hr><p>然后这一天就成为了我，继除夕回家以来，第一次出门！！！-----下楼去打了个pingpong球 — 其实小区里早就有小朋友在下面玩了，其实武汉已经解封大半个月了 — 但是我就是一直没出门</p><hr><p>好了，那一切就该放下了。就当是一场梦，醒来很久还是很感动</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/05/03/JxfV0K.th.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h1>这也能反转？？</h1><p>第二天，结果出来了，同学先发来的消息，说我过了，我？？？？？？</p><p>小问号你是否有很多朋友？？？？？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/05/03/Jz9hn0.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>我人傻了</p><p>迷惑我八百年。。。就这？？？？有内鬼停止交易？？</p><hr><p>后续…等有时间再写吧，，</p><hr><blockquote><p>坚持固然重要，但选择比坚持更重要。       --杰尼龟</p></blockquote><p>我本就是一个喜欢尝试的人，恨不得所有的东西都弄一下，可能也就是在试错成本最低的大一吧。但是你要知道这么多的尝试是为了选择做准备，人的精力是有限的，这从来都不是一句玩笑话。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/05/03/JzSJHO.th.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><blockquote><p>有舍才有得，全都要只会一无所有</p></blockquote><hr><p>ps：有人说我的博客有点随意，我估摸着，我也不是个纯技术分享博主，这不是我开心就好🐎，而且估计也没人看到这哦哈哈哈，要是有的话，祝你看的开心，哈哈</p><p>ps：不要以为进了英才有什么了不起的，比你厉害的大有人在，计院前面几名真的，都超级强，超级厉害！！每个人都有自己擅长的方面！！不过是选择不同罢了。还是要给我好好学习！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;🎉🎉🎉&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;人生&lt;/strong&gt;之&lt;strong&gt;大喜大悲&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;得之我幸，失之我命&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="生活" scheme="http://Pluto-wei.github.io/categories/%E7%94%9F%E6%B4%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>五子棋 AI</title>
    <link href="http://pluto-wei.github.io/2020/04/19/GobangAI/"/>
    <id>http://pluto-wei.github.io/2020/04/19/GobangAI/</id>
    <published>2020-04-19T15:29:19.000Z</published>
    <updated>2020-04-20T04:11:02.515Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/20/JMLxV1.md.png" alt=""></p><a id="more"></a><p>其实这也不是一篇写算法的文章 哈哈哈哈哈</p><p>c语言后期作业–五子棋AI–几周过后我终于开始了</p><p>肝了4天！！！！！！！！<br>0基础学Qt（有一种顺便学了c++的感觉），图形界面从0开始，边在小破站学边画 画了2天实现交互（按键可以显示并储存）–实现人机一样一步机器随机下–五子棋ai！！</p><p>从0开始的五子棋AI！！！（夸我！！）</p><p>太不容易了！！！！！！</p><h2 id="👉效果">👉效果</h2><p>先放两张效果图👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMLjbR.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMLxV1.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>UI界面得到了赞美（骄傲）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOkKH.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><h2 id="👉测试">👉测试</h2><ul><li>我一开始瞎下，基本上1/5的胜率 orz</li><li>然后拿给群友测试了一下</li></ul><h3 id="获胜">获胜</h3><ul><li>获胜的小朋友还是挺多的</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOeat.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOZVI.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOArd.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOEqA.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h3 id="战败">战败</h3><ul><li>当然也有输的呀（看来这AI 还是不错的😜）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOixe.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMLzUx.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>还有怎么都下赢不了自闭的（x</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMO9PK.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOC8O.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>还有坚持下了半个小时一定要赢AI 的安宝😂😂😂</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOP2D.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="👉改进">👉改进</h2><ul><li>还有一些群友意见&amp;&amp;灵感😂😂😂</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMOS56.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="👉特别感谢😂">👉特别感谢😂</h2><ul><li>特别感谢提供棋子图片&amp;陪我解决打包.exe文件图片不显示问题&amp;啥问题都可以问的小朋友（竟然也一盘都没赢？？？太菜了吧😏😏👎）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JQ1Yin.png" alt="JQ1Yin.png" title="">                </div>                <div class="image-caption">JQ1Yin.png</div>            </figure><h2 id="👉说明">👉说明</h2><ul><li>其实这AI就只搜素了两层而且没用剪枝那些（用的时候bug了就删了），只是删去了那些周围都没有棋子的。还有好多高级的算法需要学习</li></ul><blockquote><p>顺便说一下层数的问题，首先思考层数必须是偶数。因为奇数节点是AI，偶数节点是玩家，如果AI下一个子不考虑玩家防守一下，那么这个估分明显是有问题的。<br>然后，至少需要进行4层思考，如果连4四层都考虑不到，那就是只看眼前利益，那么棋力会非常非常弱。 如果能进行6层思考基本可以达到对战普通玩家有较高胜率的水平了（普通玩家是指没有专门研究过五子棋的玩家，棋力大约是4层的水平），如果能达到8层或以上的搜索，对普通玩家就有碾压的优势，可以做到90%以上胜率。</p></blockquote><ul><li><p>两层搜素能达到这个效果我已经很开心了，本来是写了四层的但是bug了就删了，后来发现还不错就没有改了，毕竟对于普通玩家还是有一定的胜率的。之前跟这个教程做的AI下棋我是真的没赢过，太没有游戏体验了（👎）</p></li><li><p><a href="https://github.com/lihongxun945/myblog/labels/%E4%BA%94%E5%AD%90%E6%A3%8BAI%E6%95%99%E7%A8%8B%E7%AC%AC%E4%BA%8C%E7%89%88" target="_blank" rel="noopener">五子棋AI教程</a> ＆ 这个教程做的 <a href="http://gobang.light7.cn/" target="_blank" rel="noopener">http://gobang.light7.cn/</a></p></li></ul><h2 id="👉爪巴">👉爪巴</h2><ul><li><p>好了把五子棋肝出来了，短期内也不想改了，这个星期的课都没怎么听，要补大物模电微积分离散了。晚上做了一个微积分的mooc错了一个气死了，算出来没答案（确信是题目错了x）模电跟离散好多节课都没听了orz</p></li><li><p>要准备英才面试了，纠结了好久…随缘吧，进不进都挺好的，既然参加面试就好好准备吧，尽力就🆗</p></li><li><p>哦对了还有acm，前几天参加了一个cf一个牛客，只能做几个水题，而且好慢还会罚时，后面的题会是会做但是贼慢，没时间呀…</p><p>还是因为对图树啥的存储和模型不是很熟，上次想把无权图转化成树（是树）想了好久没想出来，其实直接用有向图就可以呀，无向图-&gt;有向图其实就是在每一条边标出指向（起点）就可以了。有时间还要熟悉一下模型</p></li><li><p>还有入党积极分子的党课要上…</p><p><img src="https://s1.ax1x.com/2020/04/20/JQAHG4.md.jpg" alt=""></p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://s1.ax1x.com/2020/04/20/JMLxV1.md.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Qaq</title>
    <link href="http://pluto-wei.github.io/2020/04/11/qaq/"/>
    <id>http://pluto-wei.github.io/2020/04/11/qaq/</id>
    <published>2020-04-11T15:24:55.000Z</published>
    <updated>2020-04-20T06:43:30.870Z</updated>
    
    <content type="html"><![CDATA[<p>哎呀，都有1个多月没更新了，过的也太快（shui）了</p><p>今天的我👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JQeymn.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><p>太符合了</p><p>一杯茶一包烟一道oj题做一天💔</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JQeBlQ.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>云返校（想看甜甜的爱情）：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JQeDyj.md.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><p>最近真的太水了doge</p><p>离开学还得一个月吧，要好好学习了呜呜呜</p><p>上个月有几个算法发在csdn了，有时间搬运一下，顺便再整一下博客（比如设一下密码，访问人数，评论啥的）</p><p>（还想一天学一个算法的，想peach，，）</p><p>先这样吧。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;哎呀，都有1个多月没更新了，过的也太快（shui）了&lt;/p&gt;
&lt;p&gt;今天的我👇&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://s1.ax1x.com/2020/04/20/JQeymn.md.png&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="心情qaq" scheme="http://Pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>自闭日常</title>
    <link href="http://pluto-wei.github.io/2020/03/07/autistic/"/>
    <id>http://pluto-wei.github.io/2020/03/07/autistic/</id>
    <published>2020-03-07T07:16:40.000Z</published>
    <updated>2020-04-11T15:31:23.242Z</updated>
    
    <content type="html"><![CDATA[<p>又是自闭的一天</p><a id="more"></a><p>git add之后忘记git commit直接push了，也不知道用了什么操作，本地代码就不见了，git log呀啥的都没显示，在网上一通乱找啥都没找到，好像也有这样的说恢复不了了。</p><p>vscode上面好像有local history，但是装了之后才开始记录，之前的还是没有了，于是就再写了一遍。。。哭了</p><p>然后，几个小时。。。</p><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash;</span><br><span class="line">git stash pop;</span><br></pre></td></tr></tbody></table></figure><p>怎么就出来了？？~！！！</p><p>白给orz</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;又是自闭的一天&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>好气！</title>
    <link href="http://pluto-wei.github.io/2020/02/28/angry/"/>
    <id>http://pluto-wei.github.io/2020/02/28/angry/</id>
    <published>2020-02-28T13:42:13.000Z</published>
    <updated>2020-04-20T01:53:02.291Z</updated>
    
    <content type="html"><![CDATA[<p>好气啊！前几篇博客的图片都显示不了了！！</p><p>调了半天还是只有自己可以看见！删了算了哈哈哈</p><a id="more"></a><hr><p>沙雕博客被发现了！以后不发沙雕文了哈哈哈😜😜😬😬</p><p>开学了一个星期天天满课，(((φ(◎ロ◎;)φ))) 晕了</p><p>床上上课体验极差！每天被各种大佬虐😭😭😭</p><p>几门水课都要做ppt，吐了🤮！！</p><p>武汉必定最后一批返校，估计得4月底咯，惨</p><hr><p>这篇水文顺便看看图片还能不能显示👇</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/2020/02/28/angry/想见你4.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/2020/02/28/angry/想见你5.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/2020/02/28/angry/想见你1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/2020/02/28/angry/想见你2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/blog/2020/02/28/angry/想见你3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><hr><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://q6f4hplvr.bkt.clouddn.com/%E6%83%B3%E8%A7%81%E4%BD%A04.JPG" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://q6f4hplvr.bkt.clouddn.com/%E6%83%B3%E8%A7%81%E4%BD%A05.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://q6f4hplvr.bkt.clouddn.com/%E6%83%B3%E8%A7%81%E4%BD%A01.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://q6f4hplvr.bkt.clouddn.com/%E6%83%B3%E8%A7%81%E4%BD%A02.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://q6f4hplvr.bkt.clouddn.com/%E6%83%B3%E8%A7%81%E4%BD%A03.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>要是👆还是没有图…</p><p>我就哭了</p><hr><p>2020/04/20 更新：</p><p>github的图床又被墙了？？OMG</p><p><a href="https://imgchr.com/" target="_blank" rel="noopener">https://imgchr.com/</a></p><p>先测试一下新图床的图片大小区别</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMH8N8.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMH8N8.md.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://s1.ax1x.com/2020/04/20/JMH8N8.th.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好气啊！前几篇博客的图片都显示不了了！！&lt;/p&gt;
&lt;p&gt;调了半天还是只有自己可以看见！删了算了哈哈哈&lt;/p&gt;
    
    </summary>
    
    
      <category term="心情qaq" scheme="http://Pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>C++标准模板库STL介绍</title>
    <link href="http://pluto-wei.github.io/2020/02/16/C++STL/"/>
    <id>http://pluto-wei.github.io/2020/02/16/C++STL/</id>
    <published>2020-02-16T15:58:50.000Z</published>
    <updated>2020-02-17T06:28:29.313Z</updated>
    
    <content type="html"><![CDATA[<p>大概是两天看完的，这一部分主要还是以后需要查阅，只是知道了大概的用法吧。想学数据结构了，应该接下来就是了！淦！！</p><a id="more"></a><p>《想见你》大结局啦，哭死了，这部剧挺好的，撒花❀<br>详情见下一篇文章qaq😢</p><h1>C++标准模板库（STL）介绍</h1><p>💡写在前面：</p><ul><li>除了vector和string外的STL容器都不支持*(it+i)的访问方式，只能it=name.begin( )+i    it++;    *it</li></ul><h2 id="vector的常见用法">vector的常见用法</h2><ul><li>向量，可变长数组</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; name; <span class="comment">//typename可以是任意类型int，double,char</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">vector</span>&lt;node&gt; name; <span class="comment">//node是结构体类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; name;  <span class="comment">//&gt;&gt;之间要加空格，否则视为移位操作</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; Arrayname[arrySize];<span class="comment">//一维可伸长，上面的是二维</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>元素访问（下标访问和迭代器iterator访问）</p><p>迭代器类似指针,通过*it访问vector里元素</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt; vi;</span><br><span class="line">vi[index];<span class="comment">//下标访问</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=i;i&lt;=<span class="number">5</span>;i++){</span><br><span class="line">    vi.push_back(i);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vi.<span class="built_in">begin</span>();i!=vi.<span class="built_in">end</span>();i++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);</span><br><span class="line">}</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;vi.<span class="built_in">size</span>();i++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,v[i]);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">typename</span>&gt;::iterator it = vi.<span class="built_in">begin</span>();<span class="comment">//取首地址vi[0]</span></span><br><span class="line">vi.push_back(i);<span class="comment">//在末尾赋值</span></span><br><span class="line">vi.<span class="built_in">end</span>();<span class="comment">//取尾地址的下一个地址</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,*(it+i));<span class="comment">//输出vi[i];</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>常用函数</p><p>用的时候都是name.👇</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push_back(x);<span class="comment">//在vector后面添加元素x</span></span><br><span class="line">pop_back();<span class="comment">//删除vector尾元素</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回vector中元素的个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空所有元素</span></span><br><span class="line">insert(it,x);<span class="comment">//vi.insert(vi.begin()+2,-1)在vi[2]处插入-1</span></span><br><span class="line">erase();<span class="comment">//vi.erase(vi.begin()+3)删除vi[3]</span></span><br><span class="line">        <span class="comment">//vi.erase(vi.begin()+1,vi.begin()+4);删除vi[1]-vi[3]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>用途：储存数据like数组，用邻接表储存图</li></ul><h2 id="set的常见用法详解">set的常见用法详解</h2><ul><li>集合，内部自动有序且不含重复元素的容器</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义（其实和前面的一样）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; name;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">double</span>&gt; name;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">char</span>&gt; name;</span><br><span class="line"><span class="built_in">set</span>&lt;node&gt; name;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt; Arrayname[arraySize];</span><br></pre></td></tr></tbody></table></figure><ul><li>访问，只能用迭代器iterator访问，且只能枚举</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">typename</span>&gt;::iterator it;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">st.insert(<span class="number">3</span>);</span><br><span class="line">st.insert(<span class="number">5</span>);</span><br><span class="line">st.insert(<span class="number">2</span>);</span><br><span class="line">st.insert(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=st.<span class="built_in">begin</span>();i!=st.<span class="built_in">end</span>();it++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,*it);</span><br><span class="line">}</span><br><span class="line">输出为<span class="number">2</span> <span class="number">3</span> <span class="number">5</span>（自动递增，删除重复元素）</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 st.👇</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">insert(x);<span class="comment">//将x插入set容器，自动增序，去重</span></span><br><span class="line"><span class="built_in">find</span>(value);<span class="comment">//返回set中对应值为value的迭代器，it=find(2)</span></span><br><span class="line">erase();erase(it);erase(value);erase(first,last);<span class="comment">//迭代器</span></span><br><span class="line"><span class="comment">//st.erase(st.find(200));  st.erase(400);</span></span><br><span class="line"><span class="comment">//st.erase(it,st.end)</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//元素个数</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>用途：自动去重并升序</p><p>unordered_set可以只去重不排序</p><p>multiset可以处理不唯一的情况</p></li></ul><h2 id="string的常见用法详解">string的常见用法详解</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">string</span> str=<span class="string">"abcd"</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>访问</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str[i];</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;str;</span><br><span class="line">count&lt;&lt;str;<span class="comment">//读入读出整个字符串只能用cin count，除非转换👇</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str.c_str());<span class="comment">//用c_str()将string型str变成字符数组</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::iterator it;</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">string</span>::iterator it=str.<span class="built_in">begin</span>();it!=str.<span class="built_in">end</span>();it++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c"</span>,*it);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>常见函数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str3=str1+str2;<span class="comment">//将str1和str2拼接，赋值给str3</span></span><br><span class="line">str1+=str2;<span class="comment">//将str2直接拼接到str1上</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1&lt;str2) ...</span><br><span class="line">== != &lt; &lt;= &gt; &gt;=  比较规则是字典序</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">length()/<span class="built_in">size</span>()</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d"</span>,str.length(),str.<span class="built_in">size</span>());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">insert()</span><br><span class="line">insert(pos,<span class="built_in">string</span>);<span class="comment">//在pos号位置插入sring</span></span><br><span class="line">insert(it,it2,it3);<span class="comment">//在it处插入[it2,it3)</span></span><br><span class="line">str.insert(<span class="number">3</span>,str2);</span><br><span class="line">str.insert(str.<span class="built_in">begin</span>()+<span class="number">3</span>,str2.<span class="built_in">begin</span>(),str2.<span class="built_in">end</span>());</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">erase(it);</span><br><span class="line">erase(first,last);</span><br><span class="line">erase(pos,length);<span class="comment">//需要删除的起始位置+删除个数</span></span><br><span class="line">str.erase(str.<span class="built_in">begin</span>()+<span class="number">4</span>);</span><br><span class="line">str.erase(str.<span class="built_in">begin</span>()+<span class="number">2</span>,str.<span class="built_in">end</span>()<span class="number">-1</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">clear</span>();</span><br><span class="line">str.<span class="built_in">clear</span>();</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">substr(pos,len);<span class="comment">//返回从pos号位开始，长度为len的字串</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;str.substr(<span class="number">14</span>,<span class="number">4</span>)&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>::npos==<span class="number">-1</span>/<span class="number">4294967295</span>;作为函数失配时的返回值</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>();</span><br><span class="line">str.<span class="built_in">find</span>(str2);<span class="comment">//str2是子串时返回第一次出现的位置，否则返回👆</span></span><br><span class="line">str.<span class="built_in">find</span>(str2,pos);<span class="comment">//从str的第pos号为开始匹配，返回值与上相同</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">replace(pos,len,str2);<span class="comment">//把str从pos号位长度为len的字串替换为str2</span></span><br><span class="line">replace(it1,it2,str2);<span class="comment">//str[it1,it2)替换为str2</span></span><br></pre></td></tr></tbody></table></figure><ul><li>将数转化成科学计数法并比较的题A1060（看书(x)）</li></ul><h2 id="map的常用用法详解">map的常用用法详解</h2><ul><li>映射，可以建立任何基本类型之间的映射</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;typename1,typename2&gt; mp;<span class="comment">//键，值</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;<span class="comment">//如果时字符串到整型只能是string，不能是char</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>访问</p><p>会按键从小到大自动排序（内部红黑树实现同set）</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp[<span class="string">'m'</span>]=<span class="number">20</span>;</span><br><span class="line">mp[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">mp[<span class="string">'a'</span>]=<span class="number">40</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,mp[<span class="string">'c'</span>]);</span><br><span class="line">mp&lt;typename1,typename2&gt;::iterator it;<span class="comment">//迭代器</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=mp.<span class="built_in">begin</span>();it!=mp.<span class="built_in">end</span>();it++){</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c %d\n"</span>,it-&gt;first,it-&gt;second);</span><br><span class="line">}</span><br><span class="line">it-&gt;first是当前映射的键，it-&gt;second是当前映射的值</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 mp.👇</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(key);<span class="comment">//返回键为key的映射的迭代器 it=mp.find('b');</span></span><br><span class="line">erase(); mp.erase(it); mp.erase(key); mp.erase(first,last);</span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//映射的对数</span></span><br><span class="line"><span class="built_in">clear</span>();</span><br></pre></td></tr></tbody></table></figure><ul><li><p>用途：需要建立字符与整数之间的映射，判断大整数或者其他类型数据是否存在，字符串和字符串的映射</p></li><li><p>一般一一对应，mutimap一个键可以对应多个值</p><p>unordered_map以散列代替map内部红黑树实现，不按key排序，更快</p></li></ul><h2 id="queue的常见用法详解">queue的常见用法详解</h2><ul><li>队列，先进先出的容器</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span> &lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></tbody></table></figure><ul><li>元素访问</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(i);<span class="comment">//push(i)将i压入队尾</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,q.front(),q.back());</span><br><span class="line"><span class="comment">//只能通过front()来访问队首元素，back()访问对尾元素</span></span><br></pre></td></tr></tbody></table></figure><ul><li>函数 q.👇</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(x);<span class="comment">//x进入队列</span></span><br><span class="line">front();back();<span class="comment">//分别获得对首元素和队尾元素</span></span><br><span class="line">pop();<span class="comment">//令队首元素出列</span></span><br><span class="line">empty();<span class="comment">//检测队列是否为空，返回true则空，false则非空</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回queue内元素的个数</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>用途：需要实现广度优先搜素</p></li><li><p>💡使用front和pop函数前必须用empty函数判断队列是否为空，否则可能出现错误</p></li><li><p>deque，双端队列，首尾皆可插入</p><p>priority_queue，优先队列，使用堆实现，默认将最大元素至置于对首</p></li></ul><h2 id="priority-queue的常见用法详解">priority_queue的常见用法详解</h2><ul><li>优先队列，队首元素为当前队列中优先级最高的（底层的数据结构堆heap会随时调整结构）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude<span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>定义</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></tbody></table></figure><ul><li>访问，没有front和back，只有top访问队首元素（堆顶元素）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">q.push(<span class="number">3</span>);</span><br><span class="line">q.push(<span class="number">4</span>);</span><br><span class="line">q.push(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,q.top());</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 q.👇</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(x);<span class="comment">//令x入列</span></span><br><span class="line">top();<span class="comment">//获得队首元素</span></span><br><span class="line">pop();<span class="comment">//令首队元素出队</span></span><br><span class="line">empty();<span class="comment">//检测队列是否为空，true/false</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回元素个数</span></span><br></pre></td></tr></tbody></table></figure><ul><li>元素优先级的设置</li><li>基本数据类型（int,double,char）, 默认数字大的优先级更高（字典序）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; q;<span class="comment">//和下面一个相同</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//数字大的优先级大</span></span><br><span class="line">priority_queue&lt;<span class="keyword">int</span>,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;<span class="comment">//数字小的</span></span><br><span class="line">priority_queue&lt;<span class="keyword">double</span>,<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt;,less&lt;<span class="keyword">double</span>&gt; &gt; q;</span><br><span class="line">priority_queue&lt;<span class="keyword">char</span>,<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;,less&lt;<span class="keyword">char</span>&gt; &gt; q;</span><br></pre></td></tr></tbody></table></figure><ul><li>结构体</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>{</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">};<span class="comment">//现在希望水果价格高的优先级高，需要用到重载小于号&lt;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fruit</span>{</span></span><br><span class="line">    <span class="built_in">string</span> name;</span><br><span class="line">    <span class="keyword">int</span> price;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (fruit f1,fruit f2){  <span class="comment">//&gt;会出错</span></span><br><span class="line">        <span class="keyword">return</span> f1.price &lt; f2.price;</span><br><span class="line">    }<span class="comment">//重载后小于号还是小于号</span></span><br><span class="line">}</span><br><span class="line">priority_queue&lt;fruit&gt; q;<span class="comment">//内部就是价格高的优先级高</span></span><br><span class="line"><span class="comment">//将return中的&lt;改成&gt;即实现价格低的优先级高</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果结构体内的数据较为庞大，出现字符串/数组，建议使用引用</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> fruit &amp;f1,<span class="keyword">const</span> fruit &amp;f2){</span><br><span class="line">    <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>也可以重载在结构体外面</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cmp</span>{</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(fruit f1,fruit f2)</span></span>{</span><br><span class="line">        <span class="keyword">return</span> f1.price &gt; f2.price;</span><br><span class="line">    }<span class="comment">//这里返回true的优先级低一些</span></span><br><span class="line"><span class="comment">/*  bool operator()(const fruit &amp;f1,const fruit &amp;f2){</span></span><br><span class="line"><span class="comment">        return f1.price &gt; f2.price;</span></span><br><span class="line"><span class="comment">    }  */</span></span><br><span class="line">}</span><br><span class="line">prioity_queue&lt;fruit,<span class="built_in">vector</span>&lt;fruit&gt;,cmp&gt; q;</span><br></pre></td></tr></tbody></table></figure><ul><li>常见用途：可以解决一些贪心问题，对Dijkstra算法进行优化</li><li>💡使用top前必须用empty判断队列是否为空</li></ul><h2 id="stack的常见用法详解">stack的常见用法详解</h2><ul><li>栈，后进先出的容器</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">typename</span>&gt; name;</span><br></pre></td></tr></tbody></table></figure><ul><li>访问，只能top</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">st.push(i);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,st.top());</span><br></pre></td></tr></tbody></table></figure><ul><li>函数 st.👇</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push(x);</span><br><span class="line">top();<span class="comment">//获得栈顶元素</span></span><br><span class="line">pop();<span class="comment">//弹出栈顶元素</span></span><br><span class="line">empty();<span class="comment">//检查是否为空，返回true/false</span></span><br><span class="line"><span class="built_in">size</span>();<span class="comment">//返回元素个数</span></span><br></pre></td></tr></tbody></table></figure><ul><li>常见用途：实现一些递归，防止程序对栈内存的限制而导致程序出错</li></ul><h2 id="pair的常见用法详解">pair的常见用法详解</h2><ul><li>两个元素绑在一起作为一个合成元素，可以看作内部有两个元素的结构体</li><li>且两个元素的类型可以指定</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pair</span>{</span></span><br><span class="line">    typeName1 first;</span><br><span class="line">    typeName2 second;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;utility&gt;  //或者#include&lt;map&gt;,里面包含utility</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;typeName1,typeName2&gt; name;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p;</span><br><span class="line">pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; p(<span class="string">"haha"</span>,<span class="number">5</span>);</span><br></pre></td></tr></tbody></table></figure><ul><li>元素访问，pair中只有两个元素，first和second</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p.first = <span class="string">"haha"</span>;</span><br><span class="line">p.second = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p = make_pair(<span class="string">"xixi"</span>,<span class="number">55</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">p=pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"heihei"</span>,<span class="number">555</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;p.first&lt;&lt;<span class="string">" "</span>&lt;&lt;p.second&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li><p>函数，比较操作数   ==      !=      &lt;     &lt;=     &gt;    &gt;=</p><p>先以first大小作为标准，再比较second</p></li><li><p>用途：代替二元结构体机器构造函数</p><p>作为map的键值对进行插入</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line">mp.insert(make_pair(<span class="string">"heihei"</span>,<span class="number">5</span>));</span><br><span class="line">mp.insert(pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;(<span class="string">"haha"</span>,<span class="number">10</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="algorithm头文件下的常用函数">algorithm头文件下的常用函数</h2><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="max-min-abs">max,min,abs</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(x,y);<span class="built_in">max</span>(x,<span class="built_in">max</span>(y,z));<span class="comment">//返回最大值</span></span><br><span class="line"><span class="built_in">min</span>(x,y);</span><br><span class="line"><span class="built_in">abs</span>(x);<span class="comment">//x必须是整数，浮点型用math头文件下的fabs</span></span><br></pre></td></tr></tbody></table></figure><h3 id="swap">swap</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swap(x,y);<span class="comment">//用来交换x和y的值</span></span><br></pre></td></tr></tbody></table></figure><h3 id="reverse">reverse</h3><ul><li>可以将数组指针在[it,it2)之间的元素或容器的迭代器在[it,it2)的元素进行反转</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reverse(it,it2);</span><br></pre></td></tr></tbody></table></figure><h3 id="next-permutation">next_permutation</h3><ul><li>给出一个序列在全排序中的下一个序列</li><li>已到达全排序最后一个则返回false</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line"><span class="keyword">do</span>{</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d%d%d\n"</span>,a[<span class="number">0</span>],a[<span class="number">1</span>],a[<span class="number">2</span>]);</span><br><span class="line">}<span class="keyword">while</span>(next_permutation(a,a+<span class="number">3</span>));</span><br></pre></td></tr></tbody></table></figure><h3 id="fill">fill</h3><ul><li>可以把数组或容器中的某一段区间赋为某个相同的值</li><li>和memset不同，这里的赋值可以赋任意值</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>};</span><br><span class="line"><span class="built_in">fill</span>(a,a+<span class="number">5</span>,<span class="number">233</span>);</span><br></pre></td></tr></tbody></table></figure><h3 id="sort">sort()</h3><ul><li>sort函数的使用</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">sort (首元素地址,尾元素地址的下一个地址,比较函数(非必填));</span><br><span class="line"><span class="comment">//第二项-排序几个数就是首元素地址加几</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>第三个可选参数就是compare函数（cmp），用来实现排序规则</p></li><li><p>💡注意！！这个cmp是函数！返回bool类型，要放在main外面！！</p></li><li><p>①基本数据类型数组</p><p>默认从小到大，想要从大到小:</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line"><span class="keyword">return</span> a &gt;b; <span class="comment">//当a&gt;b时把a放到b前面</span></span><br><span class="line">}</span><br><span class="line">sort(a,a+<span class="number">4</span>,cmp);</span><br></pre></td></tr></tbody></table></figure><ul><li>②结构体数组的排序</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line"><span class="keyword">int</span> x,y;</span><br><span class="line">}ssd[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//按照x从大到小(一级排序)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a.x&gt;b.x; </span><br><span class="line">}</span><br><span class="line"><span class="comment">//x相等时按y排序(二级排序)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(node a,node b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a.x != b.x) <span class="keyword">return</span> a.x &gt; b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.x &lt; a.y;</span><br><span class="line">}</span><br><span class="line">sort(ssd,ssd+<span class="number">3</span>,cmp);<span class="comment">//排序</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>③容器的排序</p><p>只有vector，string，deque是可以用sort的</p><p>像set，map这种容器都是用红黑树实现的，元素本身有序的</p></li><li><p>vector</p></li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> a&gt;b;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    vi.push_back(<span class="number">3</span>);</span><br><span class="line">    vi.push_back(<span class="number">1</span>);</span><br><span class="line">    vi.push_back(<span class="number">2</span>);</span><br><span class="line">    sort(vi.<span class="built_in">begin</span>(),vi.<span class="built_in">end</span>(),cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>,vi[i]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>string，默认字典序从小到大</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果要字符串长度从小到大</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="built_in">string</span> str1,<span class="built_in">string</span> str2)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> str1.length() &lt; str2.lengh();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="lower-bound-和-upper-bound">lower_bound 和 upper_bound</h3><ul><li>lower_bound(first,last,val)返回范围内第一个值<strong>大于等于</strong>val的元素的位置（指针/迭代器）</li><li>upper_bound(first,lasst,val)返回第一个值<strong>大于</strong>val元素的位置</li><li>如果找不到返回的是该元素应当在的位置</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>]={<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>};</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d\n"</span>,lower_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a, /</span><br><span class="line">       upper_bound(a,a+<span class="number">10</span>,<span class="number">3</span>)-a);</span><br></pre></td></tr></tbody></table></figure><p>k</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大概是两天看完的，这一部分主要还是以后需要查阅，只是知道了大概的用法吧。想学数据结构了，应该接下来就是了！淦！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://Pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C++" scheme="http://Pluto-wei.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>数学入门</title>
    <link href="http://pluto-wei.github.io/2020/02/15/MathQuickStart/"/>
    <id>http://pluto-wei.github.io/2020/02/15/MathQuickStart/</id>
    <published>2020-02-15T03:12:29.000Z</published>
    <updated>2020-02-15T04:33:12.909Z</updated>
    
    <content type="html"><![CDATA[<p>唔，这里是算法笔记第五章-数学问题💓<br>大概是两天半吧，内容挺少的。后面还划水了一部分😜<br>至此入门的三章算是看完咯！</p><a id="more"></a><p>迟到的情人节快乐哟🤗</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-5844382797ca18ab.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p></p><h1>入门篇3–数学问题</h1><h2 id="简单数学">简单数学</h2><ul><li>只要掌握简单的数理逻辑</li></ul><h2 id="最大公约数与最小公倍数">最大公约数与最小公倍数</h2><ul><li>一般用gcd(a,b)表示a,b的最大公约数</li><li>一般用欧几里得算法（辗转相除法）</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> gcd(b,a%b);</span><br><span class="line">    <span class="comment">//简洁：return !b?a:gcd(b,a%b);</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>一般用lcm(a,b)来表示最小公倍数</li><li>最大公约数d，最小公约数a/d*b</li></ul><h2 id="分数的四则运算">分数的四则运算</h2><h3 id="分数的表示和化简">分数的表示和化简</h3><ul><li>假分数，只有分子和分母</li><li>注意分母不能为0啦</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fraction</span>{</span> <span class="comment">//分数</span></span><br><span class="line">    <span class="keyword">int</span> up,down; <span class="comment">//分子分母</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>down为非负数</li><li>若分数为0，则up=0，down=1</li><li>分子分母没有除了1以外的公约数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分数的化简</span></span><br><span class="line"><span class="function">Fraction <span class="title">reduction</span><span class="params">(Fraction result)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(result.dowm&lt;<span class="number">0</span>){</span><br><span class="line">        result.up=-result.up;</span><br><span class="line">        result.down=-result.down;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(result.up==<span class="number">0</span>) {</span><br><span class="line">        result.down=<span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">int</span> d=gcd(<span class="built_in">abs</span>(result.up),result.down);</span><br><span class="line">        result.up/=d;</span><br><span class="line">        result.down/=d;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="分数的四则运算-2">分数的四则运算</h3><ul><li>加减乘除</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Fraction <span class="title">add</span><span class="params">(Fraction f1,Fraction f2)</span></span>{</span><br><span class="line">Fraction result;</span><br><span class="line">    result.up=f1.up*f2.down+f2.up*f1.down;<span class="comment">//分数和的分子</span></span><br><span class="line">    result.down=f1.down*f2,down;<span class="comment">//分数和的分母</span></span><br><span class="line">    <span class="keyword">return</span> reduction(result);<span class="comment">//化简    </span></span><br><span class="line">}</span><br><span class="line"><span class="function">Fraction <span class="title">minu</span><span class="params">(Fraction f1,Fraction f2)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">multi</span><span class="params">(Fraction f1,Fraction f2)</span></span>;</span><br><span class="line"><span class="function">Fraction <span class="title">divide</span><span class="params">(Fraction f1,Fraction f2)</span></span>;</span><br></pre></td></tr></tbody></table></figure><h3 id="分数的输出">分数的输出</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showResult</span><span class="params">(Fraction r)</span></span>{    <span class="comment">//输出分数r</span></span><br><span class="line">    r=reduction(r);</span><br><span class="line">    <span class="keyword">if</span>(r.down==<span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%lld"</span>,r.up);  <span class="comment">//整数</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">abs</span>(r.up)&gt;r.down) {   <span class="comment">//假分数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d/%d"</span>,\</span><br><span class="line">               r.up/r.down,<span class="built_in">abs</span>(r.up)%r.down,r.down); </span><br><span class="line">    }<span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d/%d"</span>,r.up,r.down);   <span class="comment">//真分数</span></span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>💡分数的乘法和除法过程中可能使分子或分母超过int，一般用long long</li></ul><h2 id="素数">素数</h2><h3 id="素数的判断">素数的判断</h3><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//特判</span></span><br><span class="line">    <span class="keyword">int</span> sqr=(<span class="keyword">int</span>)<span class="built_in">sqrt</span>(<span class="number">1.0</span>*n); <span class="comment">//根号n, math.h</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;sqr;i++){ <span class="comment">//用i*i&lt;n容易溢出</span></span><br><span class="line">        <span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    }<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="素数表">素数表</h3><ul><li>筛法，通过bool实现</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> prime[maxn];</span><br><span class="line"><span class="keyword">bool</span> isPrime[maxn]={<span class="number">0</span>};</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findPrime</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">2</span>;i&lt;maxn;i++){</span><br><span class="line">        <span class="keyword">if</span>(!isPrime[i]){</span><br><span class="line">            prime[j++]=i;  <span class="comment">//第j个素数是i</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=i+i;k&lt;maxn;k+=i){</span><br><span class="line">                isPrime[k]=<span class="number">1</span>; <span class="comment">//标识i的倍数</span></span><br><span class="line">            }</span><br><span class="line">        }<span class="keyword">if</span>(j==n) <span class="keyword">break</span>;</span><br><span class="line">    }<span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></tbody></table></figure><h2 id="质因子分解">质因子分解</h2><ul><li>定义结构体factor，用来存放质因子及其个数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">factor</span>{</span></span><br><span class="line">    <span class="keyword">int</span> x,cnt; <span class="comment">//x为质因子，cnt为其个数    </span></span><br><span class="line">}fac[<span class="number">10</span>];</span><br></pre></td></tr></tbody></table></figure><ul><li>fac[ ]数组存放n的所有质因子，int范围只需要fac[10]就够了</li></ul><h2 id="大整数运算">大整数运算</h2><h3 id="大整数存储">大整数存储</h3><ul><li>没有考虑负数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bign</span>{</span>  <span class="comment">//bignumber</span></span><br><span class="line">    <span class="keyword">int</span> d[<span class="number">1000</span>];</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">    bign(){</span><br><span class="line">        <span class="built_in">memset</span>(d,<span class="number">0</span>,<span class="keyword">sizeof</span>(d));  <span class="comment">//初始化</span></span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>输入字符串时，先用字符串读入，再把字符串另存为bign结构体</li><li>char数组读入时，整数的高位存储在低位，所以倒着赋给d[ ]数组</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">change</span><span class="params">(<span class="keyword">char</span> str[])</span></span>{<span class="comment">//把整数转化为bign</span></span><br><span class="line">    bign a;</span><br><span class="line">    a.len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len;i++){</span><br><span class="line">        a.d[i]=str[a.len-i<span class="number">-1</span>]-<span class="string">'0'</span>;<span class="comment">//逆着赋值</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>比较大小</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(bign a,bign b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a.len&gt;b.len) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//a大</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(a.len&lt;b.len) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//a小</span></span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i--){</span><br><span class="line">            <span class="keyword">if</span>(a.d[i]&gt;b.d[i]) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(a.d[i]&lt;b.d[i]) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        }<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//相等</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="高精度四则运算">高精度四则运算</h3><ul><li>存在负号另外处理</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">add</span><span class="params">(bign a,bign b)</span></span>{  <span class="comment">//两正数相加</span></span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry=<span class="number">0</span>; <span class="comment">//进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++){</span><br><span class="line">        <span class="keyword">int</span> temp =a.d[i]+a.d[i]+carry;</span><br><span class="line">        c.d[c.len++]=temp%<span class="number">10</span>;  <span class="comment">//注意这里是c.len</span></span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>){</span><br><span class="line">        c.d[c.len++]=carry;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">sub</span><span class="params">(bign a,bign b)</span></span>{  <span class="comment">//大数减小数，否则交换</span></span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.len||i&lt;b.len;i++){</span><br><span class="line">        <span class="keyword">if</span>(a.d[i]&lt;b.d[i]){</span><br><span class="line">            a.d[i+<span class="number">1</span>]--;</span><br><span class="line">            a.d[i]+=<span class="number">10</span>;</span><br><span class="line">        }c.d[c.len++]=a.d[i]-b.d[i];</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(c.d[c.len<span class="number">-1</span>]==<span class="number">0</span>&amp;&amp;c.len!=<span class="number">1</span>){</span><br><span class="line">        c.len--;<span class="comment">//保证结果至少有一位数</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">multi</span><span class="params">(bign a,<span class="keyword">int</span> b)</span></span>{ <span class="comment">//高精度乘低精度</span></span><br><span class="line">    bign c;</span><br><span class="line">    <span class="keyword">int</span> carry;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len.a;i++){</span><br><span class="line">        <span class="keyword">int</span> temp=a.d[i]*b+carry;</span><br><span class="line">        c.d[c.len++]= temp%<span class="number">10</span>;</span><br><span class="line">        carry=temp/<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(carry!=<span class="number">0</span>){</span><br><span class="line">        c.d[c.len++]=carry%<span class="number">10</span>;</span><br><span class="line">        carry/=<span class="number">10</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bign <span class="title">devide</span><span class="params">(bign a,<span class="keyword">int</span> b,<span class="keyword">int</span>&amp; r)</span></span>{ <span class="comment">//使r值可以传出，初值为0</span></span><br><span class="line">    bign c;</span><br><span class="line">    c.len=a.len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=a.len<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--){</span><br><span class="line">        r=r*<span class="number">10</span>+a.d[i];</span><br><span class="line">        c.d[i]=r/b;</span><br><span class="line">        r=r%b;</span><br><span class="line">    }<span class="keyword">while</span>(c.d[c.len]==<span class="number">0</span>&amp;&amp;c.len!=<span class="number">1</span>){</span><br><span class="line">        c.len--;</span><br><span class="line">    }<span class="keyword">return</span> c;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="拓展欧几里得算法">拓展欧几里得算法</h2><ul><li>👇都是整数解</li><li>求解 ax+by=gcd(a,b)</li><li>求解ax+by=c，c是gcd的倍数才有解</li><li>同余式ax≡c(mod m)的求解</li><li>逆元的求解</li><li>计算(b/a)%m</li></ul><p>唔，这个看书吧</p><p>迷迷糊糊</p><h2 id="组合数">组合数</h2><ul><li>n的阶乘的质因子p的个数</li><li>组合数的计算</li></ul><p>好麻烦啊，，看书吧，后面跳过了几种方法，没看完。逐渐失去兴趣</p><p><strong>over</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;唔，这里是算法笔记第五章-数学问题💓&lt;br&gt;
大概是两天半吧，内容挺少的。后面还划水了一部分😜&lt;br&gt;
至此入门的三章算是看完咯！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://Pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://Pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>写个博客纪念一下</title>
    <link href="http://pluto-wei.github.io/2020/02/13/ForMemory/"/>
    <id>http://pluto-wei.github.io/2020/02/13/ForMemory/</id>
    <published>2020-02-13T11:03:17.000Z</published>
    <updated>2020-02-28T16:19:45.554Z</updated>
    
    <content type="html"><![CDATA[<p>应该昨天就发的！</p><p>因为就是在昨天，我的博客终于有了标签和分类，算是有了完整的界面。终于没有那么多地方点开都是404了！！</p><p>但是还是好丑嗷~~</p><p><a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">https://www.jianshu.com/p/e17711e44e00</a><br><a href="https://blog.csdn.net/KnownAll/article/details/81360235" target="_blank" rel="noopener">https://blog.csdn.net/KnownAll/article/details/81360235</a></p><p><a href="https://www.jianshu.com/p/c311d31265e0" target="_blank" rel="noopener">https://www.jianshu.com/p/c311d31265e0</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;应该昨天就发的！&lt;/p&gt;
&lt;p&gt;因为就是在昨天，我的博客终于有了标签和分类，算是有了完整的界面。终于没有那么多地方点开都是404了！！&lt;/p&gt;
&lt;p&gt;但是还是好丑嗷~~&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/e17711e44e
      
    
    </summary>
    
    
      <category term="心情qaq" scheme="http://Pluto-wei.github.io/categories/%E5%BF%83%E6%83%85qaq/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>算法入门！</title>
    <link href="http://pluto-wei.github.io/2020/02/12/AlgorithmQuickStart/"/>
    <id>http://pluto-wei.github.io/2020/02/12/AlgorithmQuickStart/</id>
    <published>2020-02-12T05:03:48.000Z</published>
    <updated>2020-02-12T07:37:14.641Z</updated>
    
    <content type="html"><![CDATA[<p>算法终于入门了！！<br>快乐！！！<br>从2月6号算起来刚好一个星期<br>这里是《算法笔记》3,4 章</p><a id="more"></a><p>2333还行吧，最近看剧《想见你》有点上头<br>还有10天就要开学了呜呜呜，学的东西好少😢淦！</p><p>下面👇进入正题</p><h1>入门篇1–入门模拟</h1><ul><li>简单模拟</li><li>查找元素</li><li>图形输出</li><li>日期处理</li><li>进制转换</li><li>字符串处理</li></ul><p>💡 以下是一些做题过程中的笔记</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">step</span> = <span class="number">0</span>;<span class="comment">//计数器</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;<span class="comment">//计数，num好奇怪</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> temp;<span class="comment">//临时存放</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100010</span>;<span class="comment">//?? 210??</span></span><br><span class="line"><span class="keyword">int</span> a[<span class="number">100</span>]={<span class="number">0</span>};<span class="comment">//这是全部为0，但{1}=1,0,0,0,</span></span><br><span class="line"><span class="keyword">int</span> row,col;<span class="comment">//行，列</span></span><br><span class="line"><span class="keyword">int</span> rank,score;<span class="comment">//排名，分数</span></span><br><span class="line"><span class="keyword">char</span> id[<span class="number">15</span>];<span class="comment">//当int不够用的时候</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;<span class="comment">//标志</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>日期有点意思，</p></li><li><p>关于进制</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不能直接读入读出二进制数</span></span><br><span class="line">%d 十进制</span><br><span class="line">%o 八进制</span><br><span class="line">%x %X 十六进制 小写大写形式</span><br><span class="line">%u 无符号十进制</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="comment">//可以直接用bool</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">唔，<span class="built_in">scanf</span>到底什么时候返回<span class="number">0</span>什么时候返回EOF啊？？</span><br><span class="line">反正黑框输入的时候必须ctrl+z手动结束</span><br></pre></td></tr></tbody></table></figure><h1>入门篇2–算法初步</h1><p>💡 笔记中有些代码示例没有写明哪些是主函数里的，哪些不是，需自行区分</p><h2 id="排序">排序</h2><h3 id="排序-2">排序</h3><ul><li><p>冒泡排序</p></li><li><p>选择排序</p></li><li><p>插入排序</p><p>（插入用于排列多个结构体的时候就需要交换两个结构体变量，而不能直接交换他们的排名，因为实际位置不变的话，就无法寻找排名的上一位然后去比较，所以还是用sort函数吧）</p><p>（而且插入排序的顺序记录好像就是数组下标，不能出现并列的情况）</p></li></ul><h3 id="排序题与sort函数的应用">排序题与sort函数的应用</h3><ul><li>对于涉及到排序的题目，建议直接使用c++中的sort函数，将精力放在题目逻辑本身</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sort函数的使用（详情见c++标准模板库STL）</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line">sort (首元素地址,尾元素地址的下一个地址,比较函数(非必填));</span><br></pre></td></tr></tbody></table></figure><ul><li>排序题型常用的解题步骤</li></ul><ol><li>相关结构体的定义</li><li>cmp函数的编写</li><li>排名的实现</li></ol><p>💡 要判断两个字符串是否相等，不能直接==，要用strcmp，返回正数，0，负数<br>💡（有些东西不自己做还真不知道）</p><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//cmp函数的编写</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(student a,student b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a.score != b.score) <span class="keyword">return</span> a.score &gt; b.score;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">strcmp</span>(a.name,b.name)&lt;<span class="number">0</span>;<span class="comment">//string.h</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把排名记录下来</span></span><br><span class="line">stu[<span class="number">0</span>].r=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">    <span class="keyword">if</span>(stu[i].score == stu[i<span class="number">-1</span>].score){</span><br><span class="line">        stu[i].r = stu[i<span class="number">-1</span>].r;</span><br><span class="line">    }<span class="keyword">else</span> {</span><br><span class="line">        stu[i].r = i+<span class="number">1</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要输出排名的时候，不在结构体里定义可以让代码变得简洁</span></span><br><span class="line"><span class="keyword">int</span> rank = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++){</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;stu[i].score!=stu[i<span class="number">-1</span>].score){</span><br><span class="line">        rank=i+<span class="number">1</span>;</span><br><span class="line">    }<span class="comment">//就可以printf了，否则rank就跟上一个一样</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="散列">散列</h2><ul><li>散列(hash)是常用的算法思想之一</li><li>将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素，这个转换函数称为散列函数H</li></ul><h3 id="整数-key">整数 key</h3><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hashTable数组，记录正整数是否出现过</span></span><br><span class="line"><span class="keyword">bool</span> hashTable[maxn] = {<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">    hashTable[x]=<span class="literal">true</span>; <span class="comment">//x出现过</span></span><br><span class="line">}<span class="comment">//或者用int型记录次数</span></span><br></pre></td></tr></tbody></table></figure><ul><li>key 元素转换后变成整数 H ( key )</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">H(key)=key;<span class="comment">//直接定址法中的恒等变换</span></span><br><span class="line">H(key)=a*key+b;<span class="comment">//直接定址法中的线性变换</span></span><br><span class="line">H(key)=key%mod;<span class="comment">//除留余数法，转换很大的数，mod取成表长TSize</span></span><br></pre></td></tr></tbody></table></figure><ul><li>有时会出现冲突的情况，可以直接用标准库模板库中的map</li></ul><h3 id="字符串-hash-初步">字符串 hash 初步</h3><ul><li>将字符串转化为唯一的整数</li><li>二十六进制，五十二进制转换为十进制，len不能太长</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hashFunc</span><span class="params">(<span class="keyword">char</span> s[],<span class="keyword">int</span> len)</span></span>{   <span class="comment">//转换函数</span></span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++){</span><br><span class="line">        <span class="comment">//id = id*26+(s[i]-'A');//26-&gt;10</span></span><br><span class="line">        <span class="keyword">if</span>(s[i]&gt;=<span class="string">'A'</span>&amp;&amp;s[i]&lt;=<span class="string">'Z'</span>){</span><br><span class="line">            id =id*<span class="number">52</span>+s[i]-<span class="string">'A'</span>;</span><br><span class="line">        }<span class="keyword">else</span> <span class="keyword">if</span>(s[i]&gt;=<span class="string">'a'</span>&amp;&amp;s[i]&lt;=<span class="string">'z'</span>){</span><br><span class="line">            id = id*<span class="number">52</span>+(s[i]-<span class="string">'a'</span>)+<span class="number">26</span>;</span><br><span class="line">        }<span class="comment">//52-&gt;10</span></span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">int</span> hashTable[<span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span>+<span class="number">10</span>]={<span class="number">0</span>};<span class="comment">//3位大写字母+日常加10</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,s[i]);</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(s[i],<span class="number">3</span>);</span><br><span class="line">        hashTable[id]++;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++){</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>,temp);</span><br><span class="line">        <span class="keyword">int</span> id = hashFunc(temp,<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,hashTable[id]);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="递归">递归</h2><h3 id="分治">分治</h3><ul><li>分而治之，分解、解决、合并，是一种算法思想，可以用递归的手段实现</li><li>分治法分解出的子问题应当是相互独立没有交叉的</li><li>子问题个数为1称为减治，子问题个数大于1称为分治</li></ul><h3 id="递归-2">递归</h3><ul><li>反复调用自身函数，把问题范围缩小，直到可以直接得到边界</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//求Fibonacci数列第n项</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">F</span><span class="params">(<span class="keyword">int</span> n)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//递归边界</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> F(n<span class="number">-1</span>)+F(n<span class="number">-2</span>); <span class="comment">//递归式   </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出1~n的全排列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn],hashTable[maxn]={<span class="literal">false</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(index == n+<span class="number">1</span>){ <span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">        }<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++){</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>){</span><br><span class="line">            P[index]=x;</span><br><span class="line">          hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">            generateP(index+<span class="number">1</span>); <span class="comment">//递归在这里！！！</span></span><br><span class="line">            hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">generateP(<span class="number">1</span>);<span class="comment">//从1开始的全排序</span></span><br></pre></td></tr></tbody></table></figure><ul><li>暴力法–枚举所有情况判断是否合法</li><li>回溯法–在到达递归边界前的某层，由于不需要再往前递归，直接返回上一层</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//n皇后问题，对每种可能的情况暴力法</span></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++){</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(i-j)==<span class="built_in">abs</span>(P[i]-P[j])){</span><br><span class="line">            flag=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}<span class="keyword">if</span>(flag) num++;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//回溯法就是把该判断每加一个数就执行一次，实时检验</span></span><br><span class="line"><span class="comment">//还是自己写的好理解👇</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> P[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> n;<span class="comment">//n是总数</span></span><br><span class="line"><span class="keyword">int</span> m,x;<span class="comment">//m是要填的数，x是填到的位置</span></span><br><span class="line"><span class="keyword">int</span> hash[<span class="number">10</span>]={<span class="literal">false</span>};</span><br><span class="line"><span class="keyword">int</span> count=<span class="number">0</span>;<span class="comment">//符合条件的个数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gP</span><span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(x==n+<span class="number">1</span>){</span><br><span class="line">        count ++;      </span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">//该函数结束，不是break哦</span></span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;=n;m++){ </span><br><span class="line">    <span class="comment">//记住是把m填到x位上，对应就是(m,x)坐标</span></span><br><span class="line">        <span class="keyword">if</span>(hash[m]==<span class="literal">false</span>){</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=x<span class="number">-1</span>;i++){</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(i-x)==<span class="built_in">abs</span>(P[i]-m)){</span><br><span class="line">                    flag=<span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                }</span><br><span class="line">            }<span class="keyword">if</span> (flag){</span><br><span class="line">                P[x]=m;</span><br><span class="line">                hash[m]=<span class="literal">true</span>;</span><br><span class="line">                gP(x+<span class="number">1</span>);</span><br><span class="line">                hash[m]=<span class="literal">false</span>;</span><br><span class="line">            }</span><br><span class="line"><span class="comment">//else m就不能填在x位，那么进行下一个循环m+1，看是否可以</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="贪心">贪心</h2><ul><li>贪心法是求解一类最优化问题的方法</li><li>考虑当前状态下的局部最优，来使全局最优</li><li>证明一般采用反证法和数学归纳法</li><li>有简单贪心问题和区间贪心，即区间不相交问题和区间选点问题</li><li>💡注意这个不能左端点从小到大，只能<strong>右端点从小到大</strong>，<strong>左端点从大到小</strong>！！不需要代码额外减去更大包含别人了的区间，会自己很好排除掉</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">110</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Inteval</span>{</span>         <span class="comment">//interval是区间</span></span><br><span class="line">    <span class="keyword">int</span> x,y;<span class="comment">//开区间左右端点</span></span><br><span class="line">}I[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(Inteval a,Inteval b)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(a.y=b.y) <span class="keyword">return</span> a.x&gt;b.x;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> a.y&lt;b.y;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n),n!=<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++){</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;I[i].x,&amp;I[i].y);</span><br><span class="line">        }</span><br><span class="line">    }sort(I,(I+n),cmp);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">1</span>,Y=I[<span class="number">0</span>].y;<span class="comment">//计数,记到的位置，右边的坐标</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++){</span><br><span class="line">        <span class="keyword">if</span>(I[i].x&gt;Y){</span><br><span class="line">            Y=I[i].y;</span><br><span class="line">            <span class="built_in">step</span> ++;</span><br><span class="line">        }</span><br><span class="line">    }<span class="built_in">printf</span>(<span class="string">"%d"</span>,<span class="built_in">step</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="二分">二分</h2><h3 id="二分查找">二分查找</h3><ul><li>O ( $logn$ )</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">//A[]为严格递增序列，left为二分下界，right为二分上界，x为欲查询的数，二分区间为闭区间，传入的初值为[0,n-1]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right){</span><br><span class="line">        mid = (left + right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(A[mid]==x) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(A[mid]&gt;x) right=mid<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">else</span> left=mid+<span class="number">1</span>;</span><br><span class="line">    }<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//查找失败，返回-1</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//二分上届如果超过int数据类型的一半，查询元素靠后的时候right+left就有可能溢出，一般使用👇代替</span></span><br><span class="line">mid=left+(right-left)/<span class="number">2</span>;</span><br></pre></td></tr></tbody></table></figure><ul><li>“寻找有序序列第一个满足某条件的元素的位置”问题的固定模板</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right){</span><br><span class="line">        mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(条件成立){</span><br><span class="line">            right=mid;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            left=mid+<span class="number">1</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="二分法拓展">二分法拓展</h3><ul><li>求近似值，方程的近似根</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-5</span>;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f</span><span class="params">(<span class="keyword">double</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> L,<span class="keyword">double</span> R)</span></span>{</span><br><span class="line">    <span class="keyword">double</span> left = L,right = R;</span><br><span class="line">    <span class="keyword">while</span>(right-left &gt; eps){</span><br><span class="line">        mid = (rigth+left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(f(mid)&gt;<span class="number">0</span>){  <span class="comment">//递增</span></span><br><span class="line">            right = mid;</span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            left = mid;</span><br><span class="line">        }</span><br><span class="line">    }<span class="keyword">return</span> mid;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li><p>关于书上留的一个思考题，👇是别人的一些解答</p><p><a href="https://blog.csdn.net/a845717607/article/details/79079862" target="_blank" rel="noopener">https://blog.csdn.net/a845717607/article/details/79079862</a></p><p><a href="https://blog.csdn.net/liuerin/article/details/98961797" target="_blank" rel="noopener">https://blog.csdn.net/liuerin/article/details/98961797</a></p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-7f4fc03acde6231a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>最后一排表达式应该是等号，下面是关于圆心在外部的理解，也就是说，有外接圆存在的组合只有一种可能，R没有别的可能性，变大变小都不可能构成多边形（想想也知道R变小除最大边以外都不变的话，最大边必须要变小）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://img-blog.csdn.net/20180130102605806?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTg0NTcxNzYwNw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>最后用二分法求解即可</li></ul><h3 id="快速幂">快速幂</h3><ul><li>要求$a^b$%m，循环部分为ans = ans * a % m，注意<strong>每一次都要%m</strong>，<strong>a=a%m</strong>，但是可能还是很大，当b&lt;$10^{18}$时，复杂度太高</li><li>m要是等于1直接就是0了</li><li>二分指数b，将时间复杂度变为logn，递归写法👇</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(b%<span class="number">2</span>==<span class="number">1</span>) <span class="keyword">return</span> a*binaryPow(a,b<span class="number">-1</span>,m)%m;</span><br><span class="line">    <span class="keyword">else</span>{</span><br><span class="line">        LL mul = binary(a,b/<span class="number">2</span>,m);</span><br><span class="line">        <span class="keyword">return</span> mul*mul%m; </span><br><span class="line">        <span class="comment">//要是两个binary(a,b/2,m)相乘，复杂度又变成b了</span></span><br><span class="line">    }</span><br><span class="line">}<span class="comment">//(b%2==1)等价于(b&amp;1) 位与操作</span></span><br></pre></td></tr></tbody></table></figure><ul><li>迭代写法👇（二进制，$a^b$可以写成$a^{2^k}$,…,$a^8$,$a^4$,$a^2$,$a^1中若干项的乘积）</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">binaryPow</span><span class="params">(LL a,LL b,LL m)</span></span>{</span><br><span class="line">    LL ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(b&gt;<span class="number">0</span>){</span><br><span class="line">        <span class="keyword">if</span>(b&amp;<span class="number">1</span>) ans = ans*a%m;</span><br><span class="line">        a=a*a%m;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>; <span class="comment">//将b的二进制右移一位，即b=b/2</span></span><br><span class="line">    }<span class="keyword">return</span> ans;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="two-pointers">two pointers</h2><h3 id="two-pointers-and-序列合并">two pointers and 序列合并</h3><ul><li>利用有序序列的枚举特性降低复杂度–编程计较</li><li>最原始就是指的下面第一个问题，广义就是利用问题本身与序列的特性，使用下标 i,j 对序列进行扫描</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在递增序列中找和为定值的两个数</span></span><br><span class="line"><span class="keyword">while</span>(i&lt;j){</span><br><span class="line">    <span class="keyword">if</span>(a[i]+a[j]==m){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>,a[i],a[j]);</span><br><span class="line">        i++;j--;</span><br><span class="line">    }<span class="keyword">else</span> <span class="keyword">if</span>(a[i]+a[j]&lt;m){</span><br><span class="line">i++;        </span><br><span class="line">    }<span class="keyword">else</span> j--;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列合并问题,将递增序列A B合并到C里</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> B[],<span class="keyword">int</span> C[],<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>{</span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>,index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n&amp;&amp;j&lt;m){</span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;=B[j]){</span><br><span class="line">            C[index++]=A[i++];<span class="comment">//这里就不要啰嗦了好不好</span></span><br><span class="line">        }<span class="keyword">else</span>{</span><br><span class="line">            C[index++]=B[j++];</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">while</span>(i&lt;n) C[index++]=A[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;m) C[index++]=B[i++];</span><br><span class="line">    <span class="keyword">return</span> index;<span class="comment">//为什么要返回序列的长度？？</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h3 id="归并排序">归并排序</h3><ul><li>是一种基于归并思想的一种排序方法</li><li>最基本的2-路归并排序</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-40a623c5577ca22b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="归并排序" title="">                </div>                <div class="image-caption">归并排序</div>            </figure><ul><li>递归实现</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">100</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(left&lt;right){</span><br><span class="line">        <span class="keyword">int</span> mid = (left+right)/<span class="number">2</span>;</span><br><span class="line">        mergeSort(A,left,mid);</span><br><span class="line">        mergeSort(A,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//注意1和2的时候mid是1，这两个都是left=right</span></span><br><span class="line">        <span class="comment">//也就是排序(1,1)和(2,2)</span></span><br><span class="line">        merge(A,left,mid,mid+<span class="number">1</span>,right);</span><br><span class="line">        <span class="comment">//和two pointers类似</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>非递归实现</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(<span class="keyword">int</span> A[])</span></span>{</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> <span class="built_in">step</span>=<span class="number">2</span>;<span class="built_in">step</span>/<span class="number">2</span>&lt;=n;<span class="built_in">step</span>*<span class="number">2</span>){</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i+=<span class="built_in">step</span>){</span><br><span class="line">            <span class="keyword">int</span> mid =i+<span class="built_in">step</span>/<span class="number">2</span><span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid +<span class="number">1</span>&lt;=n){<span class="comment">//如果右子区间存在</span></span><br><span class="line">                merge(A,i,mid,mid+<span class="number">1</span>,<span class="built_in">min</span>(i+<span class="built_in">step</span><span class="number">-1</span>,n));</span><br><span class="line">                <span class="comment">//注意这里的min去更小的一个</span></span><br><span class="line">            }</span><br><span class="line">        }<span class="comment">//每循环排列step个，但step可能&gt;n,例如step16，n12</span></span><br><span class="line">    }</span><br><span class="line">}<span class="comment">//可以说这种方法要考虑很多了</span></span><br></pre></td></tr></tbody></table></figure><h3 id="快速排序">快速排序</h3><ul><li><p>quickSort 函数</p></li><li><p>Partition 函数，👇，返回相遇的下标，即原先最左边的函数</p></li><li><p>randPartition函数，在上面的函数基础上增加了随机数</p></li><li><p>选取<strong>最左边的元素</strong>，排成：比他小的在左边，比他大的在右边的顺序</p><p>对他左边和右边通过递归采取同样的操作</p></li><li><p>当序列中的元素排列随机是效率较高，元素接近时会达到最坏时间复杂度（因为主元没有将区间划分成两个长度接近的区间）</p></li><li><p><strong>随机主元</strong>可以保证任意数据的<strong>期望</strong>时间复杂度是nlogn</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//产生随机数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="comment">//在main函数的开头加，生成随机数的种子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++){</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,rand());<span class="comment">//使用随机数</span></span><br><span class="line">    }<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rand()范围[0,RAND_MAX]这是stdlib里的一个常数</span></span><br><span class="line"><span class="comment">//给定范围[a,b]</span></span><br><span class="line">rand()%(b-a+<span class="number">1</span>)+a;</span><br><span class="line"><span class="comment">//更大范围的随机数b-a&gt;max</span></span><br><span class="line">(<span class="keyword">int</span>)((<span class="keyword">double</span>)rand()/<span class="number">32767</span>*(b-a+<span class="number">1</span>)+a);</span><br></pre></td></tr></tbody></table></figure><h2 id="其他高效技巧和算法">其他高效技巧和算法</h2><h3 id="打表">打表</h3><ul><li>将所有可能用到的结果事先计算出来，用的时候直接查表获得</li><li>适用于：需要大量查询某数据；没有想到好的算法超时；从大量数据中找规律</li></ul><h3 id="活用递推">活用递推</h3><ul><li>过程中可能存在的递推关系</li><li>例如某值可以通过左右两侧的结果得到</li></ul><h3 id="随机选择算法">随机选择算法</h3><ul><li>从无序数组中找到第K大的数</li><li>与随机快速排序算法类似</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从A[left,right]中返回第K大的数</span></span><br><span class="line"><span class="keyword">int</span> randSelect[<span class="keyword">int</span> A[],<span class="keyword">int</span> left,<span class="keyword">int</span> right,<span class="keyword">int</span> K]{</span><br><span class="line">    <span class="keyword">if</span>(left==right) <span class="keyword">return</span> A[left];</span><br><span class="line">    <span class="keyword">int</span> p=randPartition[A,left,right];</span><br><span class="line">    <span class="comment">//划分后主元的位置p。该函数详情见快速排序👆</span></span><br><span class="line">    <span class="comment">//注意该函数对数组的修改就是对原数组的修改</span></span><br><span class="line">    <span class="keyword">int</span> M = p-left+<span class="number">1</span>;<span class="comment">//A[p]是原A序列中的第M大</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(K==M) <span class="keyword">return</span> A[p];</span><br><span class="line">    <span class="keyword">if</span>(K&lt;M) <span class="keyword">return</span> randSelect[A,left,p<span class="number">-1</span>,K];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> randSelect[A,p+<span class="number">1</span>,right,K-M];</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>完整的代码见4.7.3</li></ul><p><strong>OVER !</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;算法终于入门了！！&lt;br&gt;
快乐！！！&lt;br&gt;
从2月6号算起来刚好一个星期&lt;br&gt;
这里是《算法笔记》3,4 章&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://Pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://Pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
      <category term="算法" scheme="http://Pluto-wei.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>关于全排序的一些理解</title>
    <link href="http://pluto-wei.github.io/2020/02/09/AllSorts/"/>
    <id>http://pluto-wei.github.io/2020/02/09/AllSorts/</id>
    <published>2020-02-09T14:29:04.000Z</published>
    <updated>2020-02-12T05:43:56.989Z</updated>
    
    <content type="html"><![CDATA[<p>这个递归真的想了好久<br>就是觉得别扭，想bb几句🤐</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-98104d5e39d449c2.gif?imageMogr2/auto-orient/strip" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><a id="more"></a><h1>来理解一下全排序(递归)</h1><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输出1~n的全排列</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn =<span class="number">11</span>;</span><br><span class="line"><span class="keyword">int</span> n,P[maxn],hashTable[maxn]={<span class="literal">false</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">generateP</span><span class="params">(<span class="keyword">int</span> index)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(index == n+<span class="number">1</span>){ <span class="comment">//递归边界</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">        }<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">1</span>;x&lt;=n;x++){</span><br><span class="line">        <span class="keyword">if</span>(hashTable[x]==<span class="literal">false</span>){</span><br><span class="line">            P[index]=x;</span><br><span class="line">          hashTable[x]=<span class="literal">true</span>;</span><br><span class="line">            generateP(index+<span class="number">1</span>); <span class="comment">//递归在这里！！！</span></span><br><span class="line">            hashTable[x]=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line">generateP(<span class="number">1</span>);<span class="comment">//从1开始的全排序</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>要写从1~3的全排序：</p></li><li><p>一共三位</p><p>第一位从1开始循环，每一轮回就是引用一次剩下2个数的全排列</p></li><li><p>每用一个数，就用hashTable标记该数已经使用，然后开始下一位的全排列，并在排列完并输出以后，恢复这个数没有使用的状态，并且这个数没到最大值的话，这一位上的这个数就要加一了，否则就会退出。（该前面的数恢复了）</p></li><li><p>n个数排完后会执行generateP(n+1)，就会输出这n个数，然后返回继续后面的步骤，继续排列</p></li></ul><hr><ul><li>比如generateP(2)，就是从第二位开始的全排列，不会给前面赋值，第一位每个数都会调用一次generateP(2)，当然前面用过的数会不再使用</li><li>直到最后一个数的全排序，就等于剩下的那个数</li></ul><hr><ul><li>但是递归边界又不能写只剩最后一个数，</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n,m,P[<span class="number">100</span>];<span class="comment">//n是总数，m是当前填的数，x是位数</span></span><br><span class="line"><span class="keyword">bool</span> hT[<span class="number">100</span>]={<span class="literal">false</span>};</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span> <span class="params">(<span class="keyword">int</span> x)</span></span>{</span><br><span class="line">    <span class="keyword">if</span>(x==n){  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="keyword">if</span>(hT[x]==<span class="literal">false</span>){</span><br><span class="line">                P[x]=i;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++){</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d"</span>,P[i]);</span><br><span class="line">        }<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }<span class="keyword">for</span>(<span class="keyword">int</span> m=<span class="number">1</span>;m&lt;n;m++){</span><br><span class="line">        <span class="keyword">if</span>(hT[m]==<span class="literal">false</span>){</span><br><span class="line">            P[x]=m;</span><br><span class="line">            hT[m]=<span class="literal">true</span>;</span><br><span class="line">            g(x+<span class="number">1</span>);</span><br><span class="line">            hT[m]=<span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>为什么这样是不行的，因为g(n)运行完后跳到上一位变成false，m+1以后到了n没有循环了</li><li>也就是倒数第二位不会变成最大的数，就以为自己的全排列已经结束了</li><li>也就是最大的数永远不会出现在前面</li><li>所以递归边界不能写n，必须是n+1</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span>{</span><br><span class="line">    n=<span class="number">4</span>;</span><br><span class="line">    g(<span class="number">1</span>);</span><br><span class="line">}</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1234</span></span><br><span class="line"><span class="number">1324</span></span><br><span class="line"><span class="number">2134</span></span><br><span class="line"><span class="number">2314</span></span><br><span class="line"><span class="number">3124</span></span><br><span class="line"><span class="number">3214</span></span><br><span class="line">n=<span class="number">3</span> 时输出：</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="number">213</span></span><br></pre></td></tr></tbody></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-c18c9fe808091d6c.gif?imageMogr2/auto-orient/strip" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个递归真的想了好久&lt;br&gt;
就是觉得别扭，想bb几句🤐&lt;/p&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                    &lt;img src=&quot;https://upload-images.jianshu.io/upload_images/20644861-98104d5e39d449c2.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;&quot; title=&quot;&quot;&gt;
                &lt;/div&gt;
                &lt;div class=&quot;image-caption&quot;&gt;&lt;/div&gt;
            &lt;/figure&gt;
    
    </summary>
    
    
      <category term="瞎想" scheme="http://Pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>一些做题时遇到的问题</title>
    <link href="http://pluto-wei.github.io/2020/02/08/SomeQuestion/"/>
    <id>http://pluto-wei.github.io/2020/02/08/SomeQuestion/</id>
    <published>2020-02-08T13:00:14.000Z</published>
    <updated>2020-02-12T05:43:16.459Z</updated>
    
    <content type="html"><![CDATA[<p>有些问题发现之后就直接补充到笔记了</p><p>还有一些不直到归到哪里的问题👇</p><a id="more"></a><p>就直接写吧</p><ul><li>结构和函数要事先声明（定义），在使用之前！或者写成 .h，否则报错</li><li>有时候数据只能读取一部分，不能继续读取并且终止了程序，很可能是循环条件写错了。逻辑问题而不是语法问题，debug啊！！</li><li>13位的整数，写long long给我扣了几分，答案是char  id[15]，不是很明白。改的时候别忘了比大小要改成strcmp</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有些问题发现之后就直接补充到笔记了&lt;/p&gt;
&lt;p&gt;还有一些不直到归到哪里的问题👇&lt;/p&gt;
    
    </summary>
    
    
      <category term="瞎想" scheme="http://Pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>关于指针的初始化问题</title>
    <link href="http://pluto-wei.github.io/2020/02/08/pointer/"/>
    <id>http://pluto-wei.github.io/2020/02/08/pointer/</id>
    <published>2020-02-08T06:07:36.000Z</published>
    <updated>2020-02-12T05:43:49.826Z</updated>
    
    <content type="html"><![CDATA[<p>不要给任何没有初始化的指针赋值！<br>不要给任何没有初始化的指针赋值！<br>不要给任何没有初始化的指针赋值！<br>重要的事情说亿遍！！！！</p><a id="more"></a><p>老是忘掉！！！</p><p>💡应该在给 *p赋值前要给 *p分配一个空间</p><p>💡scanf读入字符串一定要事先为它申请足够的空间</p><ul><li>字符串</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">20</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></tbody></table></figure><ul><li>结构体指针</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> gender;</span><br><span class="line">        studentInfo* next;</span><br><span class="line">    }*p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;p-&gt;id, &amp;p-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c"</span>, p-&gt;id, p-&gt;gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="comment">//这样是无法输出的，因为对结构体指针没有进行初始化操作</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">        <span class="keyword">int</span> id;</span><br><span class="line">        <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">        <span class="keyword">char</span> gender;</span><br><span class="line">        studentInfo* next;</span><br><span class="line">    }stu, *p;</span><br><span class="line">    p = &amp;stu;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %c"</span>, &amp;p-&gt;id, &amp;p-&gt;gender);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %c"</span>, p-&gt;id, p-&gt;gender);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}<span class="comment">//这样才可以！</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//结构体数组指针也是一样</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">student</span>{</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name;</span><br><span class="line">}stu[<span class="number">100</span>],*p;</span><br><span class="line">p = stu;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %s"</span>,&amp;(p+i)-&gt;id,(p+i)-&gt;name);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %s"</span>,(p+i)-&gt;id,(p+i)-&gt;name);</span><br></pre></td></tr></tbody></table></figure><ul><li>而那个结构体的构造函数，是用于给结构体赋值方便的一个函数，那个初始化跟这个初始化不一样</li></ul><p>💡 其实不过就是你在给指针指向的地方赋值的时候，总得知道他指向哪里吧</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要给任何没有初始化的指针赋值！&lt;br&gt;
不要给任何没有初始化的指针赋值！&lt;br&gt;
不要给任何没有初始化的指针赋值！&lt;br&gt;
重要的事情说亿遍！！！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="瞎想" scheme="http://Pluto-wei.github.io/categories/%E7%9E%8E%E6%83%B3/"/>
    
    
      <category term="碎碎念" scheme="http://Pluto-wei.github.io/tags/%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 3）</title>
    <link href="http://pluto-wei.github.io/2020/02/06/CrashCourseComputerScience%203/"/>
    <id>http://pluto-wei.github.io/2020/02/06/CrashCourseComputerScience%203/</id>
    <published>2020-02-06T05:19:55.000Z</published>
    <updated>2020-02-12T07:38:09.683Z</updated>
    
    <content type="html"><![CDATA[<p>本部分内容：<strong>计算机的现状和未来</strong><br>完结撒花！！！！<br><em><a id="more"></a></em><br>今天是2020/02/06<br>Crash Course Computer science 计算机科学速成课 终于看完啦！！<br>根据浏览器判断是2020/01/23开始的😏<br>除去没看的几天，一共看了13天😬还不错啦！<br>强推！真的很棒！感谢款待！！<br>小姐姐在此！超可爱哦！！</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-5b63cc139a5449fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="xjj" title="">                </div>                <div class="image-caption">xjj</div>            </figure><h1>计算机的现状和未来</h1><h2 id="机器学习ML＆人工智能AI">机器学习ML＆人工智能AI</h2><ul><li>机器学习算法可以让计算机从数据中学习，然后自行做出预测和决定</li><li>机器学习是为了实现人工智能这个更宏大的目标的技术之一</li><li><strong>分类</strong>：用算法减小复杂性，把数据简化成特征，特征帮助分类</li><li>机器学习算法的目的是最大化正确分类&amp;最小化错误分类，找到最好的决策边界</li><li>源于统计学的技术：<strong>决策树，森林，支持向量机</strong></li><li><strong>人工神经网络</strong>，来源于大脑里的神经元。输入层，隐藏层，输出层。</li><li>算法调整偏差和权重来训练神经网络，用标记数据训练和测试，提高准确性。有激活函数，线性传递函数</li><li>加权，求和，偏置，激活函数应用于一层里的每一个神经元，并向前传播</li><li>弱人工智能：只能做特定任务，分类，找人脸，翻译，自动驾驶</li><li>强人工智能：真正通用，像人一样聪明</li><li>强化学习：学习什么管用，什么不管用</li></ul><h2 id="计算机视觉">计算机视觉</h2><ul><li>颜色跟踪算法，一块块像素处理</li><li>核/过滤器，把核引用于像素块叫做卷积</li><li>核能做很多图像转换，例如锐化图像，模糊图像；可以匹配特定形状，例如边缘检测；可以描述简单的形状，例如找线段圆圈（眼睛鼻子）</li><li>多个核组合在一起，找到特征组合</li><li>卷积神经网络，用一堆神经元处理图像数据，每个都会输出一个新图像，本质上是被不同的核处理了，逐层深入，卷积，由小的特征组合成大的特征，直到一层把所有的特征集合到一起</li><li>生物识别 标志点 情感识别算法</li></ul><h2 id="自然语言处理">自然语言处理</h2><ul><li>Natural Language Processing</li><li>把句子切成一块块，词性，短语结构规则，把语言结构化</li><li>用规则做出分析树</li><li>聊天机器人的最基本部件：处理，分析，生成文字。应用于客服</li><li>指定简单协议用于沟通–&gt;机器学习，从语言数据库中学习，深度学习网络</li><li>语音识别，波形转化成频率（快速傅里叶变换）</li><li>构成声音的不同片段：音素</li><li>语音合成</li></ul><h2 id="机器人">机器人</h2><ul><li>自动运行的机器，大规模生产，高效不知疲惫</li><li>可编程工业机器人，简单控制回路，负反馈回路</li><li>PID–有控制回路和反馈机制 “比例-积分-微分控制器”</li><li>机器人三定律</li></ul><h2 id="计算机心理学">计算机心理学</h2><ul><li>社会心理学，认知心理学，行为心理学，感知心理学</li><li>易用读：人造物体达到目的的效率有多高</li><li>UI设计：视觉，认知系统 ，直观性</li><li>视频可以增强凝视</li><li>人机交互HRI</li><li>几乎像人类和真的人类之间的小曲线–恐怖谷</li></ul><h2 id="教育科技">教育科技</h2><ul><li>智能辅导系统</li><li>判断规则+选择算法–域模型</li><li>贝叶斯知识追踪</li><li>自适应式程序</li><li>教育数据挖掘</li><li>虚拟现实和增强现实</li></ul><h2 id="奇点，天网，未来">奇点，天网，未来</h2><ul><li>奇点：智能科技的失控性发展</li><li>复杂度刹车：S性曲线，而非J型</li><li>手工型工作，思维型工作；重复性工作，非重复性工作</li><li>加密货币，无线通讯，3D打印，生物信息学，量子计算…</li></ul><p>推荐：<br>哲学速成课，人工智能速成课，<br>西部世界<br>钻石时代</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本部分内容：&lt;strong&gt;计算机的现状和未来&lt;/strong&gt;&lt;br&gt;
完结撒花！！！！&lt;br&gt;
&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机科学速成课" scheme="http://Pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>C语言 快速入门！！</title>
    <link href="http://pluto-wei.github.io/2020/02/05/C--QuickStart/"/>
    <id>http://pluto-wei.github.io/2020/02/05/C--QuickStart/</id>
    <published>2020-02-05T04:25:10.000Z</published>
    <updated>2020-02-12T07:36:06.706Z</updated>
    
    <content type="html"><![CDATA[<p>233333<br>我终于快速入门了！！</p><a id="more"></a><p>2月2号开始看的《算法笔记》<br>今天终于把快速入门看完了==<br>4天嗷~</p><p>突然想放一张散散~生日快乐</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-6f36adacb730b7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="@7.png" title="">                </div>                <div class="image-caption">@7.png</div>            </figure><p>下面进入正题~</p><h1>基本数据类型</h1><h2 id="变量类型：">变量类型：</h2><ul><li><p>整型：short， int ，long long</p><p>绝对值在**$10^9$**范围内（32位）都可以定义为int</p><p>$10^{10}$-$10^{18}$就得用long long（64位）</p><p>（若赋大于int最大($2^{31}-1$)的值，则需要在初值后面加LL，才能编译成功）</p></li><li><p>浮点型：float，double</p><p>精度 float 6-7位，double15-16位</p><p>记住：遇到浮点用double</p></li><li><p>字符型：</p><p>标准ASCII范围是0-127，包含控制字符（转义字符\n\t\0）和可显示字符</p><p>记住：<strong>小写字母比大写字母ASCII码大32，</strong></p><p>‘字符’%c “字符串”%s</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">'z'</span>,c2 = <span class="string">'j'</span>,c3 = <span class="number">117</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c%c%c"</span>,c1,c2,c3);</span><br><span class="line"><span class="comment">//字符常量（单个字符）用单引号标注</span></span><br><span class="line"><span class="comment">//输出为 zju</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>布尔值：</p><p>c语言中要<strong>stdbool.h</strong></p><p>true（非零）false（零）</p></li></ul><h2 id="强制类型转换">强制类型转换</h2><p>（新类型名）变量名</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%.f"</span>,(<span class="keyword">double</span>)a/(<span class="keyword">double</span>)b);</span><br></pre></td></tr></tbody></table></figure><h2 id="定义常量">定义常量</h2><ul><li><p>符号常量-宏定义</p><p>define是原封不动直接替换，记得加（）</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 常量/任何语句或片段</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pi 3.14</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>const常量</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 数据类型 变量名 = 常量；</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>；</span><br></pre></td></tr></tbody></table></figure></li></ul><h2 id="运算符">运算符</h2><ul><li><p>算术运算符</p><p>/ 取商，向下取整，舍去小数  %取余数</p><p>i++先用再加，++i先加再用</p></li><li><p>关系运算符</p><p>&lt; &gt; &lt;= &gt;= == !=</p></li><li><p>逻辑运算符</p><p>&amp;&amp;与    ||或    ！非</p></li><li><p>条件运算符</p><p>唯一的三目运算符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A ? B : C ; <span class="comment">//A真则B，A假则C</span></span><br></pre></td></tr></tbody></table></figure></li><li><p>位运算符</p><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = (<span class="number">1</span> &lt;&lt; <span class="number">30</span>)<span class="number">-1</span>; <span class="comment">//无穷大，上限，</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3fffffff</span>;<span class="comment">//避免两个数相加超过int最大值</span></span><br></pre></td></tr></tbody></table></figure><p>按二进制进行:  左移&lt;&lt;  右移&gt;&gt;  位于&amp;  位或|  位异或^  位取反~</p></li></ul><h1>顺序结构</h1><h2 id="赋值表达式">赋值表达式</h2><ul><li>注意 +=   -=   /=    *=   %=  的运用</li></ul><h2 id="scanf和printf输入输出">scanf和printf输入输出</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">"格式控制"</span>，变量地址)；</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);  <span class="comment">//int</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lld"</span>,&amp;n); <span class="comment">//long long</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;fl); <span class="comment">//float</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;db); <span class="comment">//double</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%c"</span>,&amp;c);  <span class="comment">//char</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,str); <span class="comment">//字符串char*，char str[]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>除char数组整个输入 不加&amp;，其他变量类型都要加&amp;</li><li>除%c，scanf对其他格式符的输入（%d，%s）是以空白符为结束的</li><li>%c是可以读入空格跟换行的</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"格式控制"</span>，变量名称)；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,n);  <span class="comment">//int</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld"</span>,n); <span class="comment">//long long</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,fl); <span class="comment">//float</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>,db); <span class="comment">//double</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>,c);  <span class="comment">//char</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s"</span>,str); <span class="comment">//字符串char*，char str[]</span></span><br></pre></td></tr></tbody></table></figure><ul><li>唯一不同：double输出格式%f ，输入%lf</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%%"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\\"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t \n"</span>);</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%md"</span>,a);<span class="comment">//%md不足m位的int以m位进行右对齐输出，高位空格补齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%-md"</span>,a);<span class="comment">//左对齐</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%0md"</span>,a); <span class="comment">//高位补0而不是补空格</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.mf"</span>,a); <span class="comment">//保留m位小数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%n.mf"</span>,a); <span class="comment">//保留m位小数,宽度占n位</span></span><br></pre></td></tr></tbody></table></figure><h2 id="getchar与putchar输入输出">getchar与putchar输入输出</h2><ul><li>输入输出单个字符，可以识别存储换行符\n</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1,c2;</span><br><span class="line">c1 = getchar();</span><br><span class="line">getchar();</span><br><span class="line">c2 = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(c1);</span><br><span class="line"><span class="built_in">putchar</span>(c2);</span><br></pre></td></tr></tbody></table></figure><h2 id="typedef">typedef</h2><ul><li>给复杂的数据类型起别名</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line">LL a = <span class="number">123456789012345</span>,b = <span class="number">34567890123456</span>;<span class="comment">//直接使用LL</span></span><br></pre></td></tr></tbody></table></figure><h2 id="常用math函数">常用math函数</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fabs</span>(<span class="keyword">double</span> x); <span class="comment">//对double型变量取绝对值</span></span><br><span class="line"><span class="built_in">floor</span>(<span class="keyword">double</span> x);<span class="comment">//对double型变量向下取整，得到的值更小，无论正负</span></span><br><span class="line"><span class="built_in">ceil</span>(<span class="keyword">double</span> x); <span class="comment">//对double型变量向上取整</span></span><br><span class="line"><span class="built_in">pow</span>(<span class="keyword">double</span> r,<span class="keyword">double</span> p); <span class="comment">//返回$r^p$</span></span><br><span class="line"><span class="built_in">sqrt</span>(<span class="keyword">double</span> x);<span class="comment">//返回算术平方根</span></span><br><span class="line"><span class="built_in">log</span>(<span class="keyword">double</span> x);<span class="comment">//取以e为底对数，任意底数要用换底公式</span></span><br><span class="line"><span class="built_in">sin</span>(<span class="keyword">double</span> x),<span class="built_in">cos</span>(<span class="keyword">double</span> x),<span class="built_in">tan</span>(<span class="keyword">double</span> x);<span class="comment">//参数要求弧度制</span></span><br><span class="line"><span class="built_in">asin</span>(<span class="keyword">double</span> x),<span class="built_in">acos</span>(<span class="keyword">double</span> x),<span class="built_in">atan</span>(<span class="keyword">double</span> x);</span><br><span class="line">round(<span class="keyword">double</span> x);<span class="comment">//四舍五入到个位，返回类型double</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>但是这些函数直接以%f输出会都很多零</p><p>最好还是要控制位数%.0f   %.mf</p><p>也可以 %d ，(int)db</p></li><li><p>double x 只是说明这是一个double型变量，并不需要加上double</p></li><li><p>pi精确定义为acos(-1.0)</p></li></ul><h1>选择结构</h1><h2 id="if-语句">if 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (条件A) {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">else</span> <span class="keyword">if</span> (条件B) {</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>技巧：if（n==0） 等价于if（!n），if（n!=0）等价于if（n）</li><li>if语句的嵌套</li></ul><h2 id="switch-语句">switch 语句</h2><ul><li>用于分支条件比较多的情况</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式){</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">1</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式<span class="number">2</span>:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量表达式n:</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">...</span><br><span class="line">}   <span class="comment">//break结束当前switch，表达式等于常量表达式n就执行第n条</span></span><br></pre></td></tr></tbody></table></figure><h1>循环结构</h1><h2 id="while-语句">while 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件A){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="do-while-语句">do while 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>{</span><br><span class="line">    ...</span><br><span class="line">} <span class="keyword">while</span> (条件A);</span><br></pre></td></tr></tbody></table></figure><h2 id="for-语句">for 语句</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(表达式A;表达式B;表达式C){</span><br><span class="line">    ...</span><br><span class="line">} <span class="comment">//先执行A，再判断B，每个循环后执行C</span></span><br></pre></td></tr></tbody></table></figure><h2 id="break-和-continue-语句">break 和 continue 语句</h2><ul><li>break直接退出以上三种循环，switch语句</li><li>continue临时结束循环的当前轮回，进入下一轮回</li></ul><h1>数组</h1><ul><li>注意从a[0]开始</li></ul><h2 id="一维数组">一维数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名 [数组大小] = { , , };</span><br><span class="line">数组名称[下标]; <span class="comment">//访问</span></span><br></pre></td></tr></tbody></table></figure><h2 id="二维数组">二维数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据类型 数组名 [第一维大小][第二维大小] = { { , , },{ },      };</span><br></pre></td></tr></tbody></table></figure><ul><li>如果数组较大（$10^6$级别），需要将其定义在主函数之外</li><li>多维数组类似</li></ul><h2 id="memset-函数">memset 函数</h2><ul><li>对数组中的每一个元素赋相同的值</li><li>需要头文件string.h</li><li>建议只赋0/-1，其他数字（会出错）使用fill函数</li><li>因为memset使用的是按字节赋值</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(数组名,值,<span class="keyword">sizeof</span>(数组名));</span><br></pre></td></tr></tbody></table></figure><h2 id="字符数组">字符数组</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = <span class="string">"Good Story!"</span>; <span class="comment">//直接赋值仅限于初始化</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">15</span>] = {<span class="string">'G'</span>,<span class="string">'o'</span>,...}; <span class="comment">//记得长度要多一个存\0</span></span><br></pre></td></tr></tbody></table></figure><h2 id="gets和puts-输入输出">gets和puts 输入输出</h2><ul><li><p><strong>scanf 输入 printf 输出</strong>（见上文）</p></li><li><p><strong>getchar 输入 putchar 输出</strong> （见上文）</p><p>二维数组时 用 getchar ( ) 吸收掉每行末尾的换行符</p></li><li><p><strong>gets 输入 puts 输出</strong></p><p>gets 识别换行符\n作为输入结束，可以读入空格</p><p>puts 输出后会紧跟一个换行</p></li><li><p>puts 和 printf 通过识别 \0作为字符串的结尾</p></li><li><p>如果不是 scanf的%s 或gets输入（例如getchar），要在字符串末尾加\0</p></li><li><p>只有char型数组需要\0，int型数组不需要</p></li></ul><h2 id="string-h-头文件">string.h 头文件</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(字符数组);<span class="comment">//得到第一个\0前的字符的个数</span></span><br><span class="line"><span class="built_in">strcmp</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//按字典序比较两个字符串大小</span></span><br><span class="line"><span class="built_in">strcpy</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//把字符数组2复制给字符数组1，包括\0</span></span><br><span class="line"><span class="built_in">strcat</span>(字符数组<span class="number">1</span>,字符数组<span class="number">2</span>);<span class="comment">//把字符数组2接到字符数组1后面</span></span><br></pre></td></tr></tbody></table></figure><ul><li><p>strcmp：</p><p>从前往后比，a小于b，aaaa小于aab，</p><p>字符数组1&lt;字符数组2,则返回一个负整数；</p><p>字符数组1==字符数组2,则返回0；</p><p>字符数组1&gt;字符数组2,则返回一个正整数；</p></li></ul><h2 id="sscanf-与-sprintf">sscanf 与 sprintf</h2><ul><li>第一个s理解为string，均在stdio头文件下</li><li>scanf 和 printf 只是把下面的str 换成screen</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sscanf</span>(str,<span class="string">"%d"</span>,&amp;n);<span class="comment">//把字符数组str中的内容以%d的格式写入n</span></span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d"</span>,n);<span class="comment">//把n以%d的格式写到str字符数组中</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>]=<span class="string">"2048:3.14,hello"</span>;</span><br><span class="line"><span class="built_in">sscanf</span> (str,<span class="string">"%d:%lf,%s"</span>,&amp;n,&amp;db,&amp;str2) ;<span class="comment">//从左边读到右边</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">32</span>;</span><br><span class="line"><span class="keyword">double</span> db = <span class="number">3.1415</span>;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>],str2[<span class="number">100</span>]=<span class="string">"good"</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str,<span class="string">"%d:%.2f,str"</span>,n,db,str2); <span class="comment">//从右边读到左边</span></span><br></pre></td></tr></tbody></table></figure><ul><li>sscanf 还支持 <a href="https://www.runoob.com/regexp/regexp-tutorial.html" target="_blank" rel="noopener">正则表达式</a>（匹配）</li></ul><h1>函数</h1><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名称(参数类型 参数){</span><br><span class="line">    函数主体</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意全局变量和局部变量，形参和实参</li><li>以<strong>数组作为函数参数</strong>时，对数组元素的修改就是对原数组的修改（与普通的局部变量不同）</li><li>但不可以返回数组</li><li>函数的嵌套调用，例如max三个数可以用到max两个数</li><li>函数的递归调用，自己调用自己，例如算n的阶乘</li></ul><h1>指针</h1><ul><li>❗ 不要给任何没有初始化的指针的赋值！</li><li>❗ 应该在给<em>p赋值前要给</em>p分配一个空间</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1,*p2;</span><br><span class="line"><span class="keyword">double</span> *p；</span><br><span class="line"><span class="keyword">char</span> *p;</span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a,*p2;</span><br><span class="line">p2 = &amp;b; <span class="comment">//取地址</span></span><br><span class="line">*p = <span class="number">233</span>; <span class="comment">//取址</span></span><br></pre></td></tr></tbody></table></figure><ul><li>int *是指针变量的类型，p才是变量名</li><li>因此地址&amp;a是赋给p而不是*p</li><li>指针变量支持自增自减操作</li><li>a=&amp;a[0]</li><li>a+i = &amp;a[i+1]</li><li>两个int型指针相加减，等价于之间相差了几个int</li><li>指针变量作为函数参数，只有在获取地址的情况下才能真正修改变量</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//?? scanf能赋值给字符数组，不能赋值给指针的问题</span></span><br><span class="line"><span class="comment">//scanf读入字符串一定要事先为它申请足够的空间</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> *str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">15</span>*<span class="keyword">sizeof</span>(<span class="keyword">char</span>));</span><br></pre></td></tr></tbody></table></figure><h2 id="引用">引用</h2><ul><li>c++语法，产生变量的别名</li><li>&amp;加在，会对原变量进行修改</li><li>就是说x是对原来a取的一个别名，改变x就是改变a，当然这里的x用a也可以</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> &amp;x)</span></span>{</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line">change(a);</span><br></pre></td></tr></tbody></table></figure><h1>结构体的使用</h1><h2 id="结构体的定义">结构体的定义</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Name</span>{</span></span><br><span class="line">    <span class="comment">//一些基本的数据结构或者自定义的数据类型</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>结构体能定义除了自己本身的任何数据类型</li><li>不能定义自身，但可以定义自身类型的指针变量</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>{</span></span><br><span class="line">    node n; <span class="comment">//不能定义node型变量</span></span><br><span class="line">    node* next; <span class="comment">//可以定义node*型指针变量</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><h2 id="访问结构体内的元素">访问结构体内的元素</h2><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    studentInfo* next;</span><br><span class="line">}stu,*p;</span><br><span class="line"><span class="comment">//访问变量：stu.id stu.name stu.next</span></span><br><span class="line"><span class="comment">//访问指针变量p中的元素：(*p).id  p-&gt;id p-&gt;name p-&gt;next</span></span><br></pre></td></tr></tbody></table></figure><h2 id="结构体的初始化">结构体的初始化</h2><ul><li>构造函数：用以初始化</li><li>结构体内有默认构造函数，函数名和结构体名相同</li><li>只要参数个数和类型不完全相同，就可以定义任意多个构造函数，适应不同场合</li><li>好处：在结构体元素交多时显得代码精炼，不需要临时变量就可以初始化一个结构体</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span>{</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    chat gender;   </span><br><span class="line">    <span class="comment">//用以不初始化就定义结构体变量</span></span><br><span class="line">    studentInfo(){}</span><br><span class="line">    <span class="comment">//只初始化gender</span></span><br><span class="line">    studentInfo(<span class="keyword">char</span> _gender){</span><br><span class="line">        gender = _gender</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//同时初始化id和gender</span></span><br><span class="line">    studentInfo(<span class="keyword">int</span> _id,<span class="keyword">char</span> _gender){</span><br><span class="line">        id = _id;</span><br><span class="line">        gender = _gender;</span><br><span class="line">    }<span class="comment">//可以简化为</span></span><br><span class="line">    studentInfo(<span class="keyword">int</span> _id,<span class="keyword">char</span> _gender):id(_id),gender(_gender){}</span><br><span class="line">}stu[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//初始化的时候就可以直接使用构造函数</span></span><br><span class="line">stu[i]=studentInfo(<span class="number">2019</span>,<span class="number">0</span>);<span class="comment">//类似这样子</span></span><br></pre></td></tr></tbody></table></figure><h1>补充</h1><h2 id="cin-与-cout">cin 与 cout</h2><ul><li>添加头文件 #include <iostream> 和 using namespace std;才能使用</iostream></li><li>不需要指定输入输出格式，不需要取地址符&amp;</li></ul><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; n; <span class="comment">//输入一个整数n</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; db; <span class="comment">//double型浮点数</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; c;<span class="comment">//char型数组</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n &gt;&gt; db &gt;&gt; c &gt;&gt; str; <span class="comment">//同时读入多个变量</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">cin</span>.getline(str,<span class="number">100</span>); <span class="comment">//读入一整行到char型数组str[]中</span></span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line">getline(<span class="built_in">cin</span>,str); <span class="comment">//string容器输入</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" "</span>&lt;&lt; db &lt;&lt; <span class="string">" "</span> &lt;&lt; c &lt;&lt; str; <span class="comment">//输出时不会加空格</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">"haha"</span> &lt;&lt; <span class="string">"\n"</span> &lt;&lt; db &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//endl也会换行</span></span><br></pre></td></tr></tbody></table></figure><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//控制double的型的精度</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(<span class="number">2</span>) &lt;&lt; <span class="number">1.2345</span></span><br></pre></td></tr></tbody></table></figure><ul><li>只有在十分必要的时才使用cin和cout，例如 string</li></ul><h2 id="浮点数的比较">浮点数的比较</h2><ul><li>浮点数在经过运算后可能会变成3.14000001，3.1399999，就不会判为==</li><li>引入极小数eps来对误差进行修正</li><li>成立返回true，想要使用不等于!Equ(a,b),可直接对浮点数进行比较</li><li>加括号防止宏定义可能带来的错误</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>)</span><br><span class="line">#define Equ(a,b) ((<span class="built_in">fabs</span>((a)-(b)))&lt;(eps)) <span class="comment">//等于运算符==</span></span><br><span class="line">#define More(a,b) (((a)-(b))&gt;(eps)) <span class="comment">//大于运算符&gt;</span></span><br><span class="line">#define Less(a,b) (((a)-(b))&lt;(-eps)) <span class="comment">//小于运算符&lt;</span></span><br><span class="line">#define MoreEqu(a,b) (((a)-(b))&gt;(-eps)) <span class="comment">//大于等于运算符&gt;=</span></span><br><span class="line">#define LessEqu(a,b) (((a)-(b))&lt;(eps)) <span class="comment">//小于等于运算符&lt;=</span></span><br></pre></td></tr></tbody></table></figure><ul><li>类似的还有开根号,asin,acos，需要eps保证变量在定义域内的问题</li><li>0.00还会变成-0.00，则要与-0.00进行比较，若比对成功则加上eps来修正</li></ul><h2 id="复杂度">复杂度</h2><ul><li><p><strong>时间复杂度</strong>O(n)，基本运算次数</p><p>一般的OJ系统，一秒能承受的运算次数$10^7$ ~ $10^8$</p></li><li><p><strong>空间复杂度</strong>，消耗的数据空间</p><p>空间一般够用，常常以空间换时间</p></li><li><p><strong>编码复杂度</strong>，定性的概念</p></li></ul><h1>黑盒测试</h1><h2 id="单点测试">单点测试</h2><p>判断每组数据是否正确</p><h2 id="多点测试">多点测试</h2><p>一次性运行所有数据</p><ul><li><p>while… EOF型，默认读到文件末尾，EOF=-1状态</p><p>无法读取时，scanf会返回-1（关于scanf的返回值，还需要多测试）</p><p>手动触发EOF：&lt;Ctrl+Z&gt; ^z 再按回车就可结束</p></li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n) != EOF){</span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while…break型</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>),&amp;a,&amp;b != EOF){</span><br><span class="line">    <span class="keyword">if</span>(a==<span class="number">0</span> &amp;&amp; b==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">}</span><br><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;a，&amp;b),a||b){ <span class="comment">//简洁版，ab有一个不为0就循环</span></span><br><span class="line">    ...</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>while(T–)型，给出测试数据的组数</li></ul><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三种输出类型</span></span><br><span class="line"><span class="number">1.</span>正常输出</span><br><span class="line"><span class="number">2.</span>每组数据输出出后额外加一个空格</span><br><span class="line"><span class="number">3.</span>最后一组数据后面没有空行</span><br><span class="line"><span class="keyword">while</span>(T--){</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span>(T &gt; <span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure><ul><li>注意每次循环都要重置变量和数组</li><li>重置数组一般使用memset函数或fill函数</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;233333&lt;br&gt;
我终于快速入门了！！&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="http://Pluto-wei.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C语言" scheme="http://Pluto-wei.github.io/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 2）</title>
    <link href="http://pluto-wei.github.io/2020/02/02/CrashCourseComputerScience2/"/>
    <id>http://pluto-wei.github.io/2020/02/02/CrashCourseComputerScience2/</id>
    <published>2020-02-02T05:17:44.000Z</published>
    <updated>2020-02-12T07:37:58.951Z</updated>
    
    <content type="html"><![CDATA[<p><strong>人机交互</strong><br><strong>计算机网络</strong></p><p><em><a id="more"></a></em></p><h1>人机交互</h1><h2 id="命令行">命令行</h2><ul><li><p>历史</p><p><strong>机械输入</strong>，齿轮 旋钮 开关 等机械结构 ，一大堆机械面板和线，<br>–&gt;<strong>打孔纸卡和磁带</strong>，输入依然是打印纸ang实时指示灯<br>–&gt;<strong>键盘 打字机</strong><br>–&gt;电传打字机：可用电话线发送和接收文本（蒸汽朋克版聊天室）<br>–&gt;<strong>电传</strong>交互（来回对话）–命令行界面 cmd<br>–&gt;<strong>屏幕</strong>代替电传打字机：虚拟电传打印机/玻璃电传打印机 --叫做终端 terminal<br>–&gt; 文字游戏，互动式小说–&gt; MUD 多人地牢游戏（MMORPG的前辈–大型多人在线角色扮演）</p></li></ul><h2 id="命令行指令">命令行指令</h2><p>ls (list) 列出当前目录里的所有文件</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-025053e99b6ad400.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>cat (concatenate 连接)（unix）显示文件内容</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-18f8e9994a107312.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>finger  找朋友</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-78dea6ed56276912.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><h2 id="屏幕-and-2D图形显示">屏幕 and 2D图形显示</h2><ul><li><p>早期屏幕的用途：跟踪程序的运行情况，结果打印在纸上，或是保存更永久的地方<br>（屏幕更新快，对临时值简直完美）</p></li><li><p>阴极射线管CRT：把电子发射到有磷光体图层的屏幕上，路径由磁场控制<br>1.矢量扫描，用电子束描述出形状<br>2.光栅扫描，一行行，从上自下，从左往右，只在特定地方打开电子束</p></li><li><p>早期不存像素（占用内存过多），存符号<br>字符生成器–第一代显卡<br>只读存储器 ROM，存每个字符的图形（点阵图案）<br>访问内存中的屏幕缓冲区（专为图形保留）<br><img src="https://upload-images.jianshu.io/upload_images/20644861-d8ba76044a699ab9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>用字符模仿图形界面：_ + 画盒子和线<br>字符集：<br><img src="https://upload-images.jianshu.io/upload_images/20644861-ccaa11179970cbdc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p></li><li><p>用额外的bit定义字体颜色和背景颜色</p></li><li><p>用CRT上的矢量模式，所有的东西都用线组成 （海龟作图）–&gt;动画</p></li><li><p><strong>位图显示</strong>–内存中的位对应屏幕上的像素</p></li><li><p>Sketchpad （几何画板）一个<strong>交互式</strong>图形界面–计算机辅助设计 CAD<br>输入设备–光笔</p></li></ul><h2 id="图形界面">图形界面</h2><ul><li>直接显示了你可以做什么，直接在屏幕上找选项即可，"选择并点击界面”<br>图形用户界面–GUI</li><li>鼠标–用户和屏幕上的信息互动（光标）</li><li>桌面–模拟实际桌面，有窗口，时钟等小组件</li><li>用户触发事件–如点击按钮，选一个菜单项，滚动窗口–有对应的执行函数</li></ul><h2 id="3D图形">3D图形</h2><p>有图型算法负责把3D坐标拍平显示到2D屏幕上–3D投影</p><ul><li>线框渲染：正交投影，透视投影</li><li><strong>扫描线渲染</strong>（填充图形）：<strong>抗锯齿</strong><br><img src="https://upload-images.jianshu.io/upload_images/20644861-b1118218da0afb51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="抗锯齿.png"></li><li>遮挡：排序算法，画家算法–由远到近</li><li>深度缓冲</li><li><strong>明暗处理</strong>：平面着色–最基本的照明算法，高洛德着色，冯氏着色<br><img src="https://upload-images.jianshu.io/upload_images/20644861-bab45421c4564a82.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="明暗处理.png"></li><li><strong>纹理</strong>：纹理映射</li><li>加速渲染：<br>并行渲染</li><li>GPU–图形处理单元（在显卡上，周围有专用的RAM）</li></ul><h1>计算机网络</h1><h2 id="👉开放式系统互联通信参考模型-OSI">👉开放式系统互联通信参考模型 OSI</h2><p><strong>物理层</strong>：线路里的电信号，无线网络里的无线信号<br><strong>数据链路层</strong>：负责管理物理层<br>有媒体访问控制地址MAC，冲突检测，指数退避和其他的一些底层协议<br><strong>网络层</strong>：负责各种报文交换和路由 IP<br><strong>传输层</strong>：UDP TCP这些协议，负责在计算机之间进行点到点的传输，检修和修复错误<br><strong>会话层</strong>：使用UDO TCP创建连接，传递信息，然后关掉连接<br><strong>表示层和应用程序层</strong>：浏览器，HTML解码，在线看电影</p><p>详情：&lt;<a href="https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://baike.baidu.com/item/OSI%E6%A8%A1%E5%9E%8B</a>&gt;</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-a0ab560094b00893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OSI.png" title="">                </div>                <div class="image-caption">OSI.png</div>            </figure><h2 id="互联网">互联网</h2><ul><li><p>早期</p><p>需要分享数据和资源–&gt;公司或研究室内部使用<br>球鞋网络，共享物理资源–大家共享一台联网的打印机<br>早期网络也共享存储空间，不是每台电脑都有存储器</p></li><li><p>局域网</p><p>计算机近距离构成的小型网络LAN<br>最著名最成功的：<strong>以太网</strong></p></li><li><p>载波侦听多路访问 CSMA（属于链路层②）<br><img src="https://upload-images.jianshu.io/upload_images/20644861-0a58f3fc52194c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CSMA.png"></p><p><strong>使用共享载体</strong><br>以一台以太电线连接所有计算机，以电信号的形式将数据传入电缆<br>每台机器需要有唯一的媒体访问控制地址（MAC地址）<br>数据的接受方的地址放在数据的头部，作为数据的前缀发送到网络中<br>计算机看到自己的MAC才处理数据<br>这种 <strong>多台电脑共享一个传输媒介</strong> 的方法 叫–CSMA <strong>载波侦听多路访问</strong><br>含义：载体，运输数据的共享媒体，以太网的载体是铜线，wifi的载体是传播无线电波的空气。很多计算机同时侦听载体，侦听，多路。<br>带宽：载体传播数据的速度</p></li><li><p>冲突（属于<strong>链路层②</strong>）</p><p>多个计算机想同时传入数据时就会冲突。<br>如果冲突，会等一小段随机时间，指数退避–指数级增长等待时间（以太网）<br>载体和其中的设备–冲突域<br>可以用交换机把其分成两个冲突域，交换机位于两个更小的网络之间，必要时才在两个网络间传数据（属于链路层）</p><p><img src="https://upload-images.jianshu.io/upload_images/20644861-fa77e1182cbfd9dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网络.png"></p><p>大的计算机网络也是如此，包括最大的网络–互联网，也是多个连在一起的小一点的网络，是不同网络之间可以传递信息</p></li><li><p>路由（属于<strong>网络层③</strong>）</p><p>路由—通过互联的网络把信息从源地址传输到目的地址的活动<br>专用的通信线路（电路交换，电话占线）—&gt;报文交换（如同邮件系统，有几个站点）（分布式网络）<br>报文交换的好处：可以用不同路由使通信更可靠更能容错</p><p>消息沿路由跳转的次数，跳数限制–解决路由问题</p></li><li><p>协议（属于<strong>传输层④</strong>）</p><p>报文交换的缺点是某个文件太大堵塞网络<br>解决方法：把大报文分成很多小块–<strong>数据包</strong>–分组交换</p><p>报文具体格式由互联网协议定义–IP（网络层？）</p></li></ul><p><code>**IP是一个非常底层的协议 Internet Protocol**</code><br>IP之上还有其他协议：用户数据报协议 UDP<br>IP负责把数据包送到正确的电脑IP header</p><p><code>**UDP负责把数据包送到正确的程序 （UDP中的端口port）**</code><br>UDP头部还有校验和–checksum，但不提供数据修复和数据重发，并无法得知数据包是否到达（应用于直播，视频通话，对时间要求很高：射击游戏，“丢包”）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-9c6ca36ff8ff0e02.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UDP.png" title="">                </div>                <div class="image-caption">UDP.png</div>            </figure><p><code>**传输控制协议 TCP（所有数据必须到达）：**</code><br>TCP头部也有端口号和校验和</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-8de54ef4d7929c37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP IP.png" title="">                </div>                <div class="image-caption">TCP IP.png</div>            </figure><p>👇 这个组合被称为TCP/IP</p><ul><li>TCP数据包有序号，使得接收方可以把数据包正确排序</li><li>接收方校验无误后会给发送方发送一个确认码ACK</li><li>能删掉重复数据包</li><li>可以同时发多个数据包，接收多个确认码</li><li>可以调整同时发包数量，解决拥堵问题（确认码的成功率和来回时间可以推断网络的拥堵程度）</li><li>缺点：确认码数据包把数量翻了一倍但并没有传播更多的信息</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-ac678397b2bd5a03.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="TCP.png" title="">                </div>                <div class="image-caption">TCP.png</div>            </figure><hr><ul><li><p>每台联网的计算机都需要一个IP地址，以点分隔的四组数据172.217.7.238</p></li><li><p>阻塞控制–路由器会平衡与其他路由器之间的负载，以确保传输可以快速可靠</p></li><li><p>当计算机访问一个网站时，需要两个东西：IP地址，端口号<br>互联网负责把域名和IP地址一一对应，就像电话簿–<strong><code>域名系统 DNS</code></strong></p><p>DNS服务器由互联网供应商ISP提供</p></li></ul><hr><p><a href="http://xn--youtube-ri9ko68a3zbl11jdo3d4zpukhkm45l.com" target="_blank" rel="noopener">👉在浏览器里输入youtube.com</a>，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求**（会话层④）**</p><ul><li>为了更好的管理上亿个域名，DNS存成树状结构（有3千万个二级域名）</li><li>顶级域名，二级域名，子域名</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-ddfb9f76a8f76fdb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="DNS.png" title="">                </div>                <div class="image-caption">DNS.png</div>            </figure><p>这些数据散布在很多DNS服务器上</p><p>WIFI 路由器连接的所有设备组成了局域网LAN，局域网再连接到广域网WAN，广域网的路由器属于你的互联网提供商ISP<br>广域网先连接到一个区域性路由器（覆盖一个街区），然后连接到一个更大的WAN（覆盖整个城市），最终到达<strong>互联网主干</strong>（由一群超大型，带宽超高路由器组成）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-3f8be06893441231.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="网.jpg" title="">                </div>                <div class="image-caption">网.jpg</div>            </figure><h2 id="万维网-world-wide-web">万维网 world wide web</h2><ul><li><p>互联网是传递数据的管道，传播最多数据的程序是万维网<br><strong>万维网的基本单位是页面</strong></p></li><li><p>页面有内容，有去往其他页面的链接–<strong>超链接</strong>，这些超链接形成巨大的互联网络<br>文字超链接–超文本（关联式索引）</p></li><li><p>为了使网页相互连接，每个网页需要一个唯一的地址–统一资源定位器 URL</p></li></ul><p><a href="http://xn--youtube-ri9ko68a3zbl11jdo3d4zpukhkm45l.com" target="_blank" rel="noopener">👉在浏览器里输入youtube.com</a>，浏览器就去问DNS服务器，得到他的IP地址（如果存在），然后浏览器会给这个IP地址发TCP请求，连接到这个IP，这个地址运行着“网络服务器”，网络服务器的标准端口是80端口，下一步是向服务器请求更进一步的页面（这里会用超文本传输协议HTTP：例如GET，还有状态码），例如向服务器发送指令“GET/courses”，服务器收到后会返回该地址对应的网页，然后浏览器会渲染到屏幕上。</p><p>👇超文本标记语言 HTML</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-3e6be56d854e7453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="HTML.png" title="">                </div>                <div class="image-caption">HTML.png</div>            </figure><p>网页浏览器可以和网页服务器沟通<br>浏览器获取网页和媒体，并负责显示<br>人工编辑目录–&gt;搜索引擎–&gt;搜索算法<br>网络中立性：所有的数据包平等，优先级相同</p><h2 id="计算机安全">计算机安全</h2><p>Secrety,Integrity,Availability<br>保密性，完整性，可用性</p><p>威胁模型分析：以能力水平区分</p><p>💡身份认证：</p><ul><li>你知道什么：用户名/密码–复杂组合（暴力攻击）</li><li>你有什么：用户有特定物品，如钥匙🔑和锁🔒</li><li>你是谁：生物识别–但有概率性，不能重设<br>建议“双因素”，“多因素”认证</li></ul><p>💡访问控制：通过权限或访问控制列表ACL来实现</p><ul><li>权限有：Read，Write，Execute</li><li>有很多种访问控制模型，例如：Chinese wall model，Biba model</li></ul><p>例如美国的模型：</p><ul><li>不能“读上”，读更高等级的内容</li><li>不能“写下”，改更低等级的文件（确保顶级机密不外泄）</li></ul><p>其他措施：安全大会，安全行业的来审计代码,安全型代码一般开源</p><h2 id="黑客与攻击">黑客与攻击</h2><ul><li><p>社会工程学：欺骗别人让别人泄露信息</p></li><li><p>配置别人的系统</p></li><li><p>网络钓鱼：邮件发送连接</p></li><li><p>假托：（电信诈骗）</p></li><li><p>邮件里带木马：恶意软件伪装成照片等</p></li><li><p>NAND镜像：暴力攻击被罚时时，增加几根线复制内存，罚时时覆盖内存继续尝试</p></li><li><p>漏洞利用：远程攻击需要攻击者利用系统漏洞来获得某些能力或访问权限</p><p>例如：缓冲区溢出：溢出部分改掉重要值，例如修改权限admin（应对方法：边界检查，随机存放变量在内存中的位置，金丝雀：缓冲区后面跟踪变化）</p></li><li><p>代码注入：攻击用数据库的网站</p><p>结构化查询语言SQL，一种流行的数据库API<br><img src="https://upload-images.jianshu.io/upload_images/20644861-d24ec3c699bedb8f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SQL.png"></p><p>DROP TABLE users，删掉用户这张表。凉凉</p><p>应对：检测特殊字符…</p></li><li><p>蠕虫：恶意程序在电脑间互相传播，这些电脑组成僵尸网络</p></li><li><p>DDoS：僵尸网络里的所有电脑发一大堆垃圾信息，堵塞网络</p></li></ul><h2 id="密码学">密码学</h2><ul><li>明文和密文的转化叫加密和解密</li></ul><h3 id="对称加密">对称加密</h3><p>（密钥一样）</p><p>双方都知道密钥：</p><ul><li>替换加密（字母出现的频率相同，例如<strong>凯撒加密</strong>）和移位加密（列移位加密）</li><li>加密机器：<strong>英格玛</strong>（转子，一种映射，映射随着每次按键而改变）</li><li>硬件加密-&gt;软件加密</li><li>数据加密标准DES，二进制密钥，56bits，暴力破解</li><li>高级加密标准<strong>AES</strong>，更长的密钥，128,192,256bits</li></ul><p>密钥交换：</p><ul><li>不发送密钥，“单向函数-模幂运算”，如同颜色混合，自己算出密钥</li></ul><h3 id="非对称加密">非对称加密</h3><ul><li>有两个不同的密钥：一个公开一个私有</li><li>知道公钥只能加密不能解密，公钥加密后只能用私钥解密</li><li>私钥加密也可以用公钥解密，只有有私钥的人能加密，防伪造</li><li>非对称加密RSA，公钥密码学</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;人机交互&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;计算机网络&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机科学速成课" scheme="http://Pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>Crash Course Computer Science（part 1）</title>
    <link href="http://pluto-wei.github.io/2020/01/31/CrashCourseComputerScience1/"/>
    <id>http://pluto-wei.github.io/2020/01/31/CrashCourseComputerScience1/</id>
    <published>2020-01-31T03:53:23.000Z</published>
    <updated>2020-02-12T07:38:20.448Z</updated>
    
    <content type="html"><![CDATA[<p><strong>硬件Hardware</strong><br><strong>软件Software</strong></p><p><em><a id="more"></a></em></p><h1>硬件Hardware</h1><p>继电器，真空管，晶体管<br>二进制，布尔逻辑，基本操作：NOT AND OR，以及组成的 XOR 异或 （逻辑门）<br>算术存储单元ALU（算术单元和逻辑单元）<br>集成电路（都是晶体管组成的）</p><h2 id="锁存器">锁存器</h2><p>（存储一个位）0 1</p><h2 id="寄存器">寄存器</h2><ul><li>（一组锁存器） 8位寄存器 16 32 64<br>写入寄存器前要先启用里面所有的锁存器（允许写入线）</li><li>存大量寄存器：矩阵排列<br><strong>例如16×16网格的锁存器</strong><br>通过行列的某根线还可以确定到某个确定的锁存器来启动</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-c933cad517e63957.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="emm.png" title="">                </div>                <div class="image-caption">emm.png</div>            </figure><p>允许写入线，允许读取线，数据线 连接所有的锁存器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-599ac4cb2325c885.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多路复用器.png" title="">                </div>                <div class="image-caption">多路复用器.png</div>            </figure><ul><li><p><strong>again 把256位内存作为一个整体</strong><br>（通过8位地址能储存256个数据？错，每一个位置上是一个0或者1，整体表示一个数据，有256个二进制数（也不是256种可能性，而是$2^{256}$））</p><p><img src="https://upload-images.jianshu.io/upload_images/20644861-09608d5675fc2437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="256位内存.png"></p></li><li><p>8位就是一个字节（这里都是单位，八位的字节包含8个二进制数）<br>一个字节有$2^{256}$种0和1的可能性</p></li><li><p><strong>把8个256位内存排一排</strong><br>存储8个数，给他们相同的地址<br>于是一个8位的地址可以存取一个8位数，<br>（这里好奇怪 无法理解：）</p></li></ul><blockquote><p>又把这个256位内存叫一位（可能是一位数字的意思？），把8个这样的内存排一排叫1字节？<br>为了存储这样的一个8位数，我们同时给8个256位内存一样的地址（如图）</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/20644861-7e1efc4a48e425f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="8位数字.png"></p><p>嗷，懂了，这样就能存储一个8位数了！地址是8位<br>Think about it :一位数相当于有256种可能性，$2^{256^8}=2^{2^{64}} $</p><h2 id="整体的可寻址内存">整体的可寻址内存</h2><ul><li><strong>RAM–随机存取存储器</strong><br>8位的地址<br>256个地址 每个地址可以读或写一个8位值（8 bits=$2^8$种）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-b9d7795a2b02153d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="RAM.png" title="">                </div>                <div class="image-caption">RAM.png</div>            </figure><ul><li>前四位是操作码（OPCODE：LOAD ADD）<br>后四位是内存地址（if is LOAD）</li></ul><h2 id="CPU–中央处理器（指令和程序）">CPU–中央处理器（指令和程序）</h2><ul><li>中央处理器（CPU，central processing unit）作为计算机系统的运算和控制核心，是信息处理、程序运行的最终执行单元</li><li>组成 <strong>ALU  控制单元  RAM  时钟</strong></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-e145987f4f2f5bc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU.png" title="">                </div>                <div class="image-caption">CPU.png</div>            </figure><ul><li><strong>取址–&gt;解码–&gt;执行</strong></li><li>可操作的指令有 LOAD ADD SUB JUMP HALT</li><li>英特尔集成4004，第一个集成CPU 有46条指令<br>现代CPU有上千个指令和指令变种，有各种巧妙复杂的电路<br>一秒十亿条指令</li></ul><h2 id="高级CPU设计">高级CPU设计</h2><ul><li><p>缓存</p><p>在RAM中取一整块存在CPU内部，方便数据的存取。<br>CPU与RAM中间只有一根数据线，效率较低<br>当数据有改变时，通过检测<strong>脏位</strong>，将数据同步给RAM</p></li><li><p>提高效率</p><p>并行处理，同时用上CPU中的取址，解码，执行</p></li><li><p><strong>高端处理器</strong></p><p>会猜测JUMP的下一步，进行推测执行</p></li><li><p><strong>超标量处理器</strong></p><p>一个时间周期完成多条指令</p><p><code>优化**一个指令流**的吞吐量</code><br>一个CPU中有多个ALU</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-eae2e80b8ab973f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU2.png" title="">                </div>                <div class="image-caption">CPU2.png</div>            </figure><ul><li><p><strong>多核处理器</strong></p><p>同时运行<strong>多个指令流</strong><br>一个CPU芯片中，有多个独立处理单元</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-854b2e98e87de910.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="CPU3" title="">                </div>                <div class="image-caption">CPU3</div>            </figure><ul><li><p><strong>2个/4个CPU</strong><br>多核不够时可以用多个CPU</p></li><li><p><strong>超级计算机</strong><br>神威太湖之光有40960个CPU，每个CPU有256个核心，每个核心的频率是1.56GHz，每秒钟可以进行9.3亿亿次浮点运算</p></li></ul><h2 id="集成电路">集成电路</h2><p>锗-&gt;硅</p><ul><li><strong>早期 IC 几个晶体管</strong>：把简单电路（逻辑门）封装成单独组件<br><strong>印刷电路板PCB</strong>：通过蚀刻金属线把零件连接在一起</li><li><strong>光刻</strong>：用光把复杂图案印在材料上，如半导体<br>用晶圆做基础，把复杂的金属电路放在上面集成所有东西–氧化层–光</li><li><strong>刻胶</strong>–光掩膜，金属化</li><li>光刻还可以制作电阻 电容<br>一片晶圆可以做很多 IC，整块做完后切割包进微型芯片<br>芯片的核心是 IC</li><li><strong>摩尔定律</strong>：每两年左右，材料和制造技术的发展，同样的空间大小，能塞进两倍数量的晶体管<br><strong>超大规模集成 VLSI 软件</strong>：用来自动生成芯片设计</li></ul><h1>软件Software</h1><h2 id="早期编程方式">早期编程方式</h2><p>程序怎么进入内存？？</p><ul><li><p>一.纸卡</p><p><strong>最早的编程</strong>雅卡尔织布机<br>早期汇总机–不算计算机，只汇总数据（穿孔纸卡），不能编程</p></li><li><p>二.插线板</p><p><strong>Control panel 控制面板–插线板–&gt;可拔插</strong><br>有很多小插孔，可以插电线，让机器的不同部分可以相互传数据和信号<br>世界上第一台通用电子计算机ENIAC–用插线板编程</p><p><strong>存取程序计算机</strong><br>程序和数据都存在–冯诺伊曼结构<br>一个处理器（有算术逻辑单元），数据寄存器，指令寄存器，指令，内存（负责存数据和指令）</p></li><li><p>三.面板编程<br>大量使用开关</p></li></ul><h2 id="编程语言-Software">编程语言(Software)</h2><p>二进制是处理器的母语（机器语言，机器码）<br>对程序的高层次描述–<strong>伪代码</strong></p><ul><li><strong>汇编器</strong><br>读取汇编语言的写的程序。然后转成机器码<br>自己搞定跳转地址（插入可跳转标签）<br>一般一条机器指令对应一条机器指令</li><li><strong>编译器</strong><br>专门把高级语言转成低级语言(汇编或机器码)<br>一行高级编程语言，可能转成几十条二进制指令<br>程序员只需要创建变量–代表内存地址的抽象</li><li><strong>解释器</strong><br>运行时进行转换，而编译器是运行前转换</li></ul><h2 id="编程基础（语句和函数）">编程基础（语句和函数）</h2><ul><li>语法–规定句子结构的一系列规则<br>赋值语句，if语句，循环语句，把代码打包成函数（子程序）</li><li><strong>算法</strong>–解决问题的具体步骤<br>排序：选择排序$n^2$，归并排序$nlogn$<br>图搜索（找最佳路线）：Dijkstra算法</li><li><strong>算法的复杂度</strong>–算法的输入大小和运行步骤</li></ul><h2 id="数据结构">数据结构</h2><ul><li><code>数组</code>（列表，也叫向量）</li><li><code>字符串</code>（数组的亲戚）：字母 数字 标点符号</li><li><code>矩阵</code>（二维数组，数组的数组）</li><li><code>结构体</code>（多个变量打包，多个不同类型数据放在一起）</li><li><code>链表</code>（一个灵活的数据结构，能存很多个节点）：容易重新排序，插入，两端缩减，倒序<br>很多复杂的数据结构也用链表：队列和栈</li><li><code>队列</code>：先进先出</li><li><code>栈</code>：后进先出</li><li><code>树</code>（把一个节点的指针变成多个指针）：根节点，子节点，母/父节点（直属上层节点），叶节点（树结束的地方）<br>二叉树：节点最多只有两个子节点<br>甚至节点可以用链表来存储你所有的子节点<br>树的特点：根到叶是单向的</li><li><code>图</code>：数据随意连接，包括循环。用有多个节点的指针表示，可随意指向</li><li><code>红黑树和堆</code>？</li></ul><h2 id="计算机科学之父–图灵">计算机科学之父–图灵</h2><ul><li><code>图灵机</code>：规则，状态和纸带<br>停机问题 无法解决<br>提出智能，图灵测试（验证码）</li></ul><hr><h2 id="软件工程">软件工程</h2><ul><li>把函数打包成层级，把相关代码都放在一起，打包成对象</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-1415b9e1715a2dee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象.png" title="">                </div>                <div class="image-caption">对象.png</div>            </figure><ul><li>对象可以包含其他对象，函数 和变量</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-fc0f7bef9c874a0d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象2.png" title="">                </div>                <div class="image-caption">对象2.png</div>            </figure><ul><li><p>把函数打包成对象的思想叫面向对象编程 Object Oriented Programming</p></li><li><p>文档 （帮助理解代码都做了什么）以及定义好的程序编程接口API<br>API 控制哪些函数和数据让外部访问，哪些仅供内部</p></li><li><p>面向对象的编程语言可以指定函数是private/public，隐藏复杂度，选择性的公布</p><hr></li><li><p>集成开发环境 IDE</p><p>debug 调试<br>写文档 README</p></li><li><p>源代码管理（版本控制）</p><p>把代码放在一个中心服务器上，叫做代码仓库<br><strong>Code repository</strong><br>check out，commit（提交）<br>master（代码的总版本）<br>质量保证测试 QA<br>β版本软件（快完成时向公众发布）免费的QA团队<br>alpha版本（只在公司内部测试）</p></li></ul><h2 id="操作系统OS"><strong>操作系统OS</strong></h2><ul><li>操作硬件的特殊权限，可以运行和管理其他程序 （1950年代）<br>操作系统充当硬件和软件之间的媒介<br>操作系统提供API来抽象硬件，叫设备驱动程序</li><li><strong>批处理</strong>（连续进行多个程序，自动加载程序）–&gt;在单个CPU上同时运行几个程序–&gt;<strong>多任务处理</strong>（给每个程序分配专属内存块，内存地址的虚拟化，内存保护）–&gt;分时操作系统（处理多个用户）</li><li><strong>Multics</strong>（功能太多）–&gt;<strong>Unix</strong>（把操作系统分为两个部分：内核（内存管理，多任务输入输出处理）和一堆有用的工具（例如程序和运行库），功能并不是很全面，内存崩溃时“恐慌”）–&gt;<strong>Windows</strong>（早期经常蓝屏）–&gt;<strong>Mac OS X,Linux,iOS,Android</strong></li><li>多任务，虚拟内存，内存保护</li></ul><h2 id="内存-储存介质">内存&amp;储存介质</h2><ul><li><p>存储介质</p><p><strong>打孔纸卡，打孔纸带</strong>–&gt;<strong>延迟线存储器</strong>（扬声器压力波/金属线的震动，顺序存储器/循环存储器）–&gt;<strong>磁芯存储器</strong>（可访问某一特定位置）–&gt;<strong>磁带</strong>–&gt;<strong>磁鼓</strong>储存器–&gt;<strong>硬盘</strong>（机械硬盘，固态硬盘SSD）–&gt;<strong>软盘</strong>–&gt;密度更高的软盘（Zip Disks）–&gt;<strong>光学存储器</strong>（光盘CD，DVD）光盘表面有很多小坑，造成光的不同反射，光学传感器捕获并解码为1和0</p></li></ul><h2 id="文件与文件系统">文件与文件系统</h2><ul><li><p>文件格式：</p><p>TXT（文本）WAVE（音频，振幅） Bitmap.bmp（图片，像素块：红绿蓝）<br>元数据（类型，图片宽度，图片高度，深度）+Date</p></li><li><p>怎么储存文件</p><p>为了存多个文件，需要一个特殊文件记录文件的位置（文件目录，通常在最开头）</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-b49c23d7d7f7a0c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件目录.png" title="">                </div>                <div class="image-caption">文件目录.png</div>            </figure><ul><li><p>文件系统专门负责管理文件</p></li><li><p>平面文件系统：</p><p>（文件都在同一个目录里）<br>分配块–增大或减小<br>碎片处理–把数据来回移动，排列成正确的数据</p></li><li><p>分层文件系统</p><p>目录文件不仅要指向文件，还要指向目录</p></li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://upload-images.jianshu.io/upload_images/20644861-2ef3de91bab67389.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="根目录.png" title="">                </div>                <div class="image-caption">根目录.png</div>            </figure><h2 id="压缩-Compression">压缩 Compression</h2><p>把数据占用的空间压到更小<br>作用：高效储存图片，音乐，视频</p><ul><li><p>无损压缩</p><p><strong>消除冗余</strong> <strong>游程编码</strong>适合经常出现相同值的文件<br><strong>用更紧凑的表示方法</strong> <strong>字典编码</strong><br>GIF,PNG,PDF,ZIP</p></li><li><p>有损压缩</p><p><strong>感知编码</strong><br>用不同的精度编码不同的频段<br>例如<strong>声音</strong>，超声波/低音<br>FLAC / WAV --&gt; MP3<br>有损压缩文件格式<br>JPEG<br><strong>视频</strong>，每一帧，时间冗余，只存变化的部分，补丁的移动和转换<br>MPEG-4</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;硬件Hardware&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;软件Software&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机科学速成课" scheme="http://Pluto-wei.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E9%80%9F%E6%88%90%E8%AF%BE/"/>
    
    
      <category term="计算机科学" scheme="http://Pluto-wei.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"/>
    
  </entry>
  
</feed>
